<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>3.面试突破 | ♪张小佑</title><meta name="keywords" content="C++"><meta name="author" content="🎵张小佑♪"><meta name="copyright" content="🎵张小佑♪"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="3.面试突破"><meta name="application-name" content="3.面试突破"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta name="description" content="积极学习C++吧！">
<meta property="og:type" content="article">
<meta property="og:title" content="3.面试突破">
<meta property="og:url" content="http://acall.love/2023/06/10/3.C++%20%E9%9D%A2%E8%AF%95%E7%AA%81%E7%A0%B4/index.html">
<meta property="og:site_name" content="♪张小佑">
<meta property="og:description" content="积极学习C++吧！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/d6g1gl.webp">
<meta property="article:published_time" content="2023-06-09T16:00:00.000Z">
<meta property="article:modified_time" content="2023-06-09T16:00:00.000Z">
<meta property="article:author" content="🎵张小佑♪">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="后端开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/d6g1gl.webp"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://acall.love/2023/06/10/3.C++%20%E9%9D%A2%E8%AF%95%E7%AA%81%E7%A0%B4/"><link rel="preconnect" href="//npm.elemecdn.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://npm.elemecdn.com/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/@fancyapps/ui@4.0.31/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  friends_vue_info: undefined,
  navMusic: true,
  changeMainColorPost: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#3b70fc","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://npm.elemecdn.com/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://npm.elemecdn.com/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '3.面试突破',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-06-10 00:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/1.jpg"/><div class="loading-image-dot"></div><div id="loading-percentage">0%</div></div></div><script>const loadingPercentage = document.getElementById("loading-percentage");
let loadingPercentageTimer = setInterval(function() {
  var progressBar = document.querySelector(".pace-progress");
  if (!progressBar) return
  var currentValue = progressBar.getAttribute("data-progress-text");
  if (currentValue !== loadingPercentage.textContent) {
    loadingPercentage.textContent = currentValue;
    if (currentValue === "100%") {
      clearInterval(loadingPercentageTimer);
    }
  }
}, 100);
const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
    Pace.restart()
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/progress_bar/progress_bar.css"/><script async="async" src="https://npm.elemecdn.com/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div id="web_box"><div id="web_container"><div id="menu-mask"></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://acall.love/" title="博客" target="_blank"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" href="https://image.anheyu.com/" title="安知鱼图床" target="_blank"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">♪张小佑</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child" style="left:17px;"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/202307192211377.png" target="_blank"><img class="post-qr-code-img" alt="wechat" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/202307192211377.png"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/202307192207910.png" target="_blank"><img class="post-qr-code-img" alt="alipayautoh" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/202307192207910.png"/></a><div class="post-qr-code-desc">alipayautoh</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments" onclick="anzhiyu.hideConsole()"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> <span>最新评论</span></span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags" onclick="anzhiyu.hideConsole()"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>23</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" style="font-size: 1.05rem;">后端开发<sup>22</sup></a><a href="/tags/%E9%9D%A2%E7%BB%8F/" style="font-size: 1.05rem;">面经<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>3</sup></a></div></div><hr/></div></div><div class="console-card history" onclick="anzhiyu.hideConsole()"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">五月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">四月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/03/"><span class="card-archive-list-date">三月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/02/"><span class="card-archive-list-date">二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/01/"><span class="card-archive-list-date">一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" onclick="anzhiyu.switchDarkMode()" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div><div class="console-btn-item" id="consoleKeyboard" onclick="anzhiyu.keyboardToggle()" title="快捷键开关"><a class="keyboard-switch"><i class="anzhiyufont anzhiyu-icon-keyboard"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B6%AF/">大学生涯</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/C/" tabindex="-1"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>C++</span></a><a class="article-meta__tags" href="/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" tabindex="-1"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>后端开发</span></a></span></div></div><h1 class="post-title">3.面试突破</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-09T16:00:00.000Z" title="发表于 2023-06-10 00:00:00">2023-06-10</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-09T16:00:00.000Z" title="更新于 2023-06-10 00:00:00">2023-06-10</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">53.8k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>168分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="3.面试突破"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为郑州"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>郑州</span></div></div></div><article class="post-content" id="article-container"><h2 id="C-面试突破"><a href="#C-面试突破" class="headerlink" title="C++ 面试突破"></a>C++ 面试突破</h2><h3 id="C-编译与内存相关"><a href="#C-编译与内存相关" class="headerlink" title="C++ 编译与内存相关"></a>C++ 编译与内存相关</h3><h4 id="C-程序编译"><a href="#C-程序编译" class="headerlink" title="C++ 程序编译"></a>C++ 程序编译</h4><ul>
<li><p>为什么需要编译：</p>
<p>常见的 C&#x2F;C++ 语言，CPU 是无法理解的，这就需要将我们编写好的代码最终翻译为机器可执行的二进制指令，编译的过程本质上也即是翻译的过程，当然中间涉及的细节非常复杂</p>
</li>
<li><p>编译的处理过程：</p>
<p>编译器读取源文件 cpp，并将其翻译为可执行文件「ELF」，ELF 文件可以经过操作系统进行加载执行。常见的编译过程分为四个过程：编译预处理、编译、汇编、链接</p>
<ul>
<li>编译预处理：在预编译过程中<strong>主要处理源代码中的预处理指令</strong>，比如引入头文件（#include），去除注释，处理所有的条件编译指令（#ifdef, #ifndef, #else, #elif, #endif），宏的替换（#define），添加行号，保留所有的编译器指令；</li>
<li>编译：针对预处理后的文件进行词法分析、语法分析、语义分析、符号汇总、汇编代码生成，并针对程序的结构或者特定的 CPU 平台进行优化，其中涉及的过程较为复杂。<strong>简单来说编译的过程即为将 .cpp 源文件翻译成 .s 的汇编代码；</strong></li>
<li>汇编：<strong>将汇编代码 .s 翻译成机器指令 .o 文件</strong>，一个 .cpp 文件只会生成一个 .o 文件；</li>
<li>链接：汇编程序生成的目标文件即为 .o 文件，单独的 .o 文件可能无法执行。因为一个程序可能由多个源文件组成，此时就存在多个 .o 文件。文件 A 中的函数引用了另一个文件 B 中定义的符号或者调用了某个库文件中的函数，这就需要链接处理。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成一个可被操作系统加载执行的ELF 程序文件</li>
</ul>
</li>
<li><p>静态链接与动态链接:</p>
<ul>
<li><strong>静态链接：</strong>代码在生成可执行文件时，将该程序所需要的全部外部调用函数全部拷贝到最终的可执行程序文件中，在该程序被执行时，该程序运行时所需要的全部代码都会被装入到该进程的虚拟地址空间中。在 Linux 系统下，静态链接库一般以 .a 文件，我们可以将多个 .o 文件链接成一个静态链接库</li>
<li><strong>动态链接：</strong>代码在生成可执行文件时，该程序所调用的部分程序被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息，<strong>最终生成的 ELF 文件中并不包含这些调用程序二进制指令</strong>。在程序执行时，当需要调用这部分程序时，<strong>操作系统会从将这些动态链或者共享对象进行加载</strong>，并将全部内容会被映射到该进行运行的虚拟地址的空间。在 Linux 系统下，动态链接库一般以 .so 文件，我们可以将多个 .o 文件链接成一个动态链接库</li>
<li><strong>二者的优缺点：</strong>静态链接<strong>浪费空间</strong>，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难），优点就是执行的时候<strong>运行速度快</strong>，因为可执行程序具备了程序运行的所有内容；动态链接<strong>节省内存、更新方便</strong>，但是动态链接是在程序运行时，每次执行都需要链接，<strong>相比静态链接会有一定的性能损失</strong>。静态链接是由连接器完成的，动态链接最终是由操作系统来完成链接的功能，动态链接在不同的操作系统下可能由不同的实现原理，比如在 Linux 系统下，动态链接库通常以 .so 文件存在，在 windows 下同下，动态链接库一般以 .dll 文件存在</li>
</ul>
</li>
</ul>
<h4 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++ 内存管理"></a>C++ 内存管理</h4><ul>
<li><p>ELF 文件：可执行与可链接格式 (Executable and Linkable Format) 是一种用于可执行文件、目标代码、共享库和<strong>核心转储 （core dump）</strong> 的标准文件格式，每个 ELF 文件都由一个 ELF header 和紧跟其后的文件数据部分组成，可执行程序内部都是分段进行存储的，ELF 文件的构成如下:</p>
<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220910114916326.png" alt="image-20220910114916326" style="zoom: 33%;" />

<ul>
<li>.text section：代码段。通常存放已编译程序的机器代码，一般操作系统加载后，这部分是只读的。</li>
<li>.rodatasection：只读数据段。此段的数据不可修改，存放程序中会使用的常量。比如程序中的常量字符串”aasdasdaaasdasd”。</li>
<li>.datasection：数据段。主要用于存放已初始化的全局变量、常量。</li>
<li>.bsssection: bss 段。该段主要存储未初始化全局变量，仅是占位符，不占据任何实际磁盘空间。目标文件格式区分初始化和非初始化是为了空间效率。</li>
</ul>
<p>操作系统在加载 ELF 文件时会将按照标准依次读取每个段中的内容，并将其加载到内存中，同时为该进程分配栈空间，并将 pc 寄存器指向代码段的起始位置，然后启动进程</p>
</li>
<li><p>内存分区：C++ 程序在运行时也会按照不同的功能划分不同的段，C++ 程序使用的内存分区一般包括：栈、堆、全局&#x2F;静态存储区、常量存储区、代码区。</p>
<ul>
<li>栈：目前绝大部分 CPU 体系都是基于栈来运行程序，栈中主要存放函数的局部变量、函数参数、返回地址等，栈空间一般由操作系统进行默认分配或者程序指定分配，栈空间在进程生存周期一直都存在，当进程退出时，<strong>操作系统才会对栈空间进行回收</strong>。</li>
<li>堆：动态申请的内存空间，就是由 malloc 函数或者 new 函数分配的内存块，由程序控制它的分配和释放，可以在程序运行周期内随时进行申请和释放，如果进程结束后还没有释放，操作系统会自动回收。</li>
<li>全局区&#x2F;静态存储区：主要为 .bss 段和 .data 段，存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。</li>
<li>常量存储区：.rodata 段，存放的是常量，不允许修改，程序运行结束自动释放。</li>
<li>代码区：.text 段，存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。</li>
<li>从操作系统的本身来讲，以上存储区在该程序内存中的虚拟地址分布是如下形式（虚拟地址从低地址到高地址，实际的物理地址可能是随机的）： .text→.data→.bss→heap→unused→stack→⋯</li>
</ul>
</li>
</ul>
<h4 id="堆与栈"><a href="#堆与栈" class="headerlink" title="堆与栈"></a>堆与栈</h4><ul>
<li><p>栈：每次在调用函数时，会按照从右向左的顺序依次将函数调用参数压入到栈中，并在栈中压入返回地址与当前的栈帧，然后跳转到调用函数内部，pc 跳转函数内部执行该函数的指令；</p>
<ul>
<li><p>rsp 寄存器存放的地址即为当前的栈顶rbp 寄存器存放的地址即为当前的栈帧，与 rbp 寄存器相邻的位置存放的数据即为函数的返回地址与调用函数的栈帧，通过以上信息即可获取函数的调用关系</p>
</li>
<li><p><strong>栈溢出</strong>：一般情况操作系统为每个进程会固定栈空间的大小，在实际编写程序时，如果出现两个函数互相调用或者递归无退出条件时，此时栈空间的就会无限增长</p>
</li>
<li><p>栈一般还分为内核栈与用户栈，在栈顶会有一个特殊的内存页 <code>guard</code>，当栈一旦越界访问该特殊的 <code>guard</code> 页时，则会出现栈溢出的错误</p>
</li>
</ul>
</li>
<li><p>堆：当程序在运行时，需要动态申请额外的内存来存放相应的数据和变量，此时就需要用到堆。堆的内存空间一般由操作系统或者专门内存程序来管理的。在 C&#x2F;C++ 一般用 malloc 或者 new 来从堆中申请内存，使用 free 或者 delete 来释放空间，空间释放后会有<strong>操作系统</strong>进行回收。</p>
</li>
<li><p>堆与栈的优缺点：</p>
<ul>
<li>申请方式：栈中存放的变量在编译时由编译器为其在栈上分配了空间，即程序编译后该变量在栈中使用的内存即确定，释放时也由于函数调用的返回，栈的空间会自动进行回收。堆中存放的变量由程序运行时决定的，会有操作系统或者内存管理模块来进行分配的。</li>
<li>申请后系统响应：<ul>
<li>分配栈空间时如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出，绝大多数情况下，栈的空间较小，一般栈上分配的变量不会占用太大的空间，且当函数返回时，当前栈帧中的变量生存周期会结束；</li>
<li>申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上，堆上可以分配较大的空间，如果不进行释放，则堆上存储的变量生存周期一直存在，直到当前进程退出</li>
<li>栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，且只能被当前的线程访问；堆在内存中的空间（向高地址扩展）是不连续的，中间允许有间隔，堆中的内存并不是线程安全的，同一进程的线程都都可访问。</li>
</ul>
</li>
<li>申请效率：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。</li>
<li>存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。</li>
</ul>
</li>
<li><p>实际的内存管理</p>
<ul>
<li>实际的内存管理更为复杂，一般分为两级内存管理。</li>
<li>操作系统按照段页式来管理内存，当需要创建新的进程或者线程时，操作系统会为新创建的进程分配物理页，当运行的进程需要更多的内存时，操作系统也会为其分配新的物理页并将其映射到该进程的虚拟地址空间中。</li>
<li>程序运行时，每个程序都含有一个内存管理的子程序，专门负责程序中的内存申请和释放，其中的技巧可能非常复杂，并且涉及许多内存分配的算法。</li>
</ul>
</li>
</ul>
<h4 id="变量定义与生存周期"><a href="#变量定义与生存周期" class="headerlink" title="变量定义与生存周期"></a>变量定义与生存周期</h4><p><code>C/C++</code> 变量有两个非常重要的属性：作用域与生命周期，这两个属性代表从时间和空间两个不同的维度来描述一个变量</p>
<ul>
<li><p>作用域：作用域即一个变量可以被引用的范围，常见的作用域可分为 6 种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。</p>
<ul>
<li>全局变量：具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。其他不包含全局变量定义的源文件需要用 extern 关键字再次声明这个全局变量。</li>
<li>静态全局变量：具有文件作用域。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被 static 关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。</li>
<li>局部变量：具有局部作用域。它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回，局部变量对于函数外部的程序来说是不可见的。当然内部实际更复杂，实际是以 {} 为作用域的。</li>
<li>静态局部变量：具有局部作用域。它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见, 只有定义该变量的函数内部可以使用访问和修改该变量。</li>
</ul>
</li>
<li><p>生命周期：生命周期即该变量可以被引用的时间段（生存期表示变量存在的时间）。</p>
<ul>
<li>全局变量与局部全局变量: 全局变量在整个程序运行期间都会一直存在，都可以随时访问，当程序结束时，对应的变量则会自动销毁，内存会被系统回收。</li>
<li>局部变量: 局部变量的生命周期仅限于函数被调用期间，当函数调用结束时，该变量会自动销毁。</li>
<li>静态局部变量：实际上静态局部变量的作用域仅限于函数内部，它的作用域与局部变量相同，但实际上该变量在程序运行期间是一直存在的，生命周期贯穿于整个程序运行期间。局部静态变量只能被初始化一次。</li>
</ul>
</li>
<li><p>从分配内存空间看：不同生命周期的变量，在程序内存中的分布位置是不一样的。程序的内存分为代码区（.text）、全局数据区（.data，.bss，.rodata）、堆区（heap）、栈区（stack），不同的内存区域，对应不同的生命周期</p>
<ul>
<li>静态变量一般存储在数据段，包括 data 段、bss 段、rodata 段，其中 data 存储已经已经初始化的静态变量和全局变量，bss 存储未初始化的静态变量与全局变量。静态变量包括全局变量，局部全局变量，静态局部变量。</li>
<li>局部变量一般存储在栈区或者堆区。</li>
</ul>
</li>
<li><p>静态变量和栈变量（存储在栈中的变量）、堆变量（存储在堆中的变量）的区别：静态变量会被放在程序的静态数据存储区（.data 段，bss 段，rodata 段）中（静态变量会自动初始化），这样可以在下一次调用的时候还可以保持原来的赋值。而栈变量或堆变量不能保证在下一次调用的时候依然保持原来的值。</p>
</li>
<li><p>静态变量和全局变量的区别：静态变量仅在变量的作用范围内可见，实际是依靠编译器来控制作用域。全局变量在整个程序范围内都可可见，只需声明该全局变量，即可使用。</p>
</li>
<li><p>全局变量定义在不要在头文件中定义：如果在头文件中定义全局变量，当该头文件被多个文件 include 时，该头文件中的全局变量就会被定义多次，编译时会因为重复定义而报错，因此不能再头文件中定义全局变量。一般情况下我们将变量的定义放在 .cpp 文件中，一般在 .h 文件使用extern 对变量进行声明。</p>
</li>
</ul>
<h4 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h4><ul>
<li><p>什么是内存对齐：计算机中内存空间是按照 byte 来划分划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是：在访问特定类型变量的时候通常在特定的内存地址访问，这就需要对这些数据在内存中存放的位置进行限制，各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。编译器将程序中的每个 数据单元 的地址安排在机器字的整数倍的地址指向的内存之中</p>
</li>
<li><p>为什么要内存对齐：主要是由于 CPU 的访问内存的特性决定，CPU 访问内存时并不是以字节为单位来读取内存，而是以机器字长为单位，由 CPU 的数据总线的宽度来决定的。实际 CPU 运行时，每一次控制内存读写信号发生时，CPU 一次可以读取和写入数据总线宽度的数据。比如 32 位的 CPU，字长为 4 字节，那么 CPU 访问内存的单位也是 4 字节。这么设计的目的是为了减少 CPU 访问内存的次数，加大 CPU 访问内存的吞吐量。假设读取 8 个字节的数据，按照每次读取 4 个字节的速度，则 8 个字节需要 CPU 耗费 2 次读取操作。CPU 始终以字长访问内存，如果不进行内存对齐，很可能增加 CPU 访问内存的次数。</p>
<p>除了能够减少内存访问次数，增加内存读取的吞吐量以外，还有其他原因：</p>
<ul>
<li>比如某些特定的硬件设备只能存取对齐数据，存取非对齐的数据可能会引发异常，比如对于 CPU 中 SIMD 指令，则必须要求内存严格对齐；</li>
<li>每次内存访问是原子的，如果变量的大小不超过字长，那么内存对齐后，对该变量的访问就是原子的。某些硬件设备不能保证在存取非对齐数据的时候的操作是原子操作，因此此时 CPU 需要可能需要读取多次内存，这样就破坏了变量的原子性；</li>
<li>相比于存取对齐的数据，存取非对齐的数据需要花费更多的时间，提高内存的访问效率，因为 CPU 在读取内存时，是一块一块的读取；</li>
<li>某些处理器虽然支持非对齐数据的访问，但会引发对齐陷阱（alignment trap）；</li>
<li>某些硬件设备只支持简单数据指令非对齐存取，不支持复杂数据指令的非对齐存取。</li>
</ul>
</li>
<li><p>内存对齐的原则：</p>
<ul>
<li>实际的内存对齐处理都是由编译器来处理，编译器会自动在内存之间填充字节。结构体重变量对齐的基本规则如下：<ul>
<li>结构体变量的首地址能够被其最宽基本类型成员大小与对齐基数中的较小者所整除；</li>
<li>结构体中的 static 成员变量不占用结构体的空间，由于静态成员变量在程序初始化时已经在静态存储区分配完成，所有该结构体实例中的静态成员都指向同一个内存区域；</li>
<li>结构体每个成员相对于结构体首地址的偏移量 （offset） 都是该成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在成员之间加上填充字节 （internal padding）；</li>
<li>结构体的总大小为结构体最宽基本类型成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在最末一个成员之后加上填充字节 （trailing padding）；</li>
</ul>
</li>
</ul>
</li>
<li><p>在某些特定场景下需要指定结构体内存进行对齐，比如在发送特定网络协议报文、硬件协议控制、消息传递、硬件寄存器访问时，这时就就需要避免内存对齐，因为双方均按照预先定义的消息格式来进行交互，从而避免不同的硬件平台造成的差异，同时能够将双方传递的数据进行空间压缩，避免不必要的空间浪费。可以用 <code>#progma pack(x)</code> 指定结构体以 x 为单位进行对齐</p>
</li>
<li><p>内存对齐使得程序便于在不同的平台之间进行移植，因为有些硬件平台不能够支持任意地址的数据访问，只能在某些地址处取某些特定的数据，否则会抛出异常；另一方面提高内存的访问效率，因为 CPU 在读取内存时，是以块为单位进行读取</p>
</li>
</ul>
<h4 id="大端与小端"><a href="#大端与小端" class="headerlink" title="大端与小端"></a>大端与小端</h4><ul>
<li><p>字节序又称端序或尾序（<code>Endianness</code>），在计算机科学领域中，指电脑内存中或在数字通信链路中，组成多字节的字的字节的排列顺序。</p>
</li>
<li><p>字节的排列方式常见的方式有两种：将一个多位数的低位放在较小的地址处，高位放在较大的地址处，则称小端序（Little-Endian）；反之则称大端序（Big-Endian）。为什么需要字节序这个规定，主要是因为在网络应用中字节序是一个必须被考虑的因素，对于不同 CPU 可能采用不同标准的字节序，所以均按照网络标准转化成相应的字节序。</p>
<ul>
<li>Little-Endian：将低序字节存储在起始地址（低位编址），在变量指针转换的时候地址保持不变，比如 int64* 转到 int32*，对于机器计算来说更友好和自然</li>
<li>Big-Endian：将高序字节存储在起始地址（高位编址），内存顺序和数字的书写顺序是一致的，对于人的直观思维比较容易理解，网络字节序统一规定采用 Big-Endian。</li>
</ul>
</li>
<li><p>检测字节序:<br>一般情况下我们直接调用宏定义 __BYTE_ORDER 即可，可以通过引用 &lt;bits&#x2F;endian.h&gt; 即可。或者也可以编写程序来判断当前的字节序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">byteorder_check</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="type">char</span> *)&amp;a); <span class="comment">/* 1 为小端机，0 为大端机 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字节序转换:在程序中字节序转换时，将高位与低位依次进行交换即可完成</p>
<p>常用的网络字节序转换函数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ntohl</span>(uint32 x)       <span class="comment">// uint32 类型 网络序转主机序</span></span><br><span class="line"><span class="built_in">htonl</span>(uint32 x)       <span class="comment">// uint32 类型 主机序转网络序</span></span><br><span class="line"><span class="built_in">ntohs</span>(uint16 x)       <span class="comment">// uint16 类型 网络序转主机序</span></span><br><span class="line"><span class="built_in">htons</span>(uint16 x)       <span class="comment">// uint16 类型 主机序转网络序</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><ul>
<li>内存泄漏：程序在堆中申请的动态内存，在程序使用完成时没有得到及时的释放。当这些变量的生命周期已结束时，该变量在堆中所占用的内存未能得到释放，从而就导致了堆中可使用的内存越来越少，最终可能产生系统运行较慢或者系统因内存不足而崩溃的问题。</li>
<li>内存泄漏并非指内存从物理上消失，而是指程序在运行过程中，由于疏忽或错误而失去了对该内存的控制，从而造成了内存的浪费。</li>
<li>内存泄漏主要指堆上分配的变量，因为栈中分配的变量，随着函数退出时会自动回收。而堆是动态分配的，一旦用户申请了内存分配而没及时释放，那么该部分内存在整个程序运行周期内都是被占用的，其他程序无法再使用这部分内存。</li>
<li>对于实际的程序来说，在调用过程中使用 malloc、calloc、realloc、new 等分配内存时，使用完后要调用相应的 free 或 delete 释放内存，否则这块内存就会造成内存泄漏。在实际应用中，可能在使用系统资源或者在堆中创建对象时，没有及时将这些资源或者对象进行释放时，也会造成内存泄漏，这些资源或者对象的创建实际也占用了堆中的内存，在使用完成时应及时将其进行释放</li>
<li>内存泄漏导致的问题：由于内存未得到及时释放，从而可能导致可使用的动态内存空间会越来越少，一旦内存空间全部使用完，则程序可能会导致因为内存不够中止运行。由于内存泄漏导致的问题比较严重，现在许多语言都带有 GC 程序会自动对不使用的内存进行回收，从而避免内存泄漏。</li>
</ul>
<h4 id="内存泄漏检测与预防"><a href="#内存泄漏检测与预防" class="headerlink" title="内存泄漏检测与预防"></a>内存泄漏检测与预防</h4><ul>
<li><p>对于 C&#x2F;C++ 没有 GC 程序的语言来说因为内存造成的问题较多，当然一般情况下如果存在严重的内存泄漏，通过查看内存使用统计即可检测到内存泄漏，但是细小的内存泄漏很难通过统计观察到，目前一般都是利用各种内存检测工具来检测内存泄漏，当然关键还是在于统计和分析申请和释放的相关日志。内存检测工具有很多比如valgrind等</p>
</li>
<li><p>如何防止内存泄漏:</p>
<ul>
<li><p>内部封装：将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存；但这样做并不是最佳的做法，在类的对象复制时，程序会出现同一块内存空间释放两次的情况:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">ex</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    A ex1 = ex; </span><br><span class="line">    <span class="type">char</span> *p = ex.<span class="built_in">GetPointer</span>();</span><br><span class="line">    <span class="built_in">strcpy</span>(p, <span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 fun1 这个函数中定义的两个类的对象而言，在离开该函数的作用域时，会两次调用析构函数来释放空间。但是这两个对象指向的是同一块内存空间，所以导致同一块内存空间被释放两次，可以通过增加计数机制来避免这种情况</p>
</li>
<li><p>使用智能指针：智能指针是 C++ 中已经对内存泄漏封装好了一个工具，智能指针对象会自动释放所申请的内存</p>
</li>
<li><p>良好的编码习惯：良好的编码习惯可以有效的避免内存泄漏的问题，内存申请和释放要一一对应：</p>
<ul>
<li>在 C++ 中需要将基类的析构函数定义为虚函数；</li>
<li>遵循 RAII（Resource acquisition is initialization）原则：在对象构造时获取资源，在对象生命期控制对资源的访问使之始终保持有效，最后在对象析构的时候释放资源；</li>
<li>尽量使用智能指针；</li>
<li>有效引入内存检测工具；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="智能指针简介与使用"><a href="#智能指针简介与使用" class="headerlink" title="智能指针简介与使用"></a>智能指针简介与使用</h4><ul>
<li>智能指针是为了解决动态内存分配时带来的内存泄漏以及多次释放同一块内存空间而提出的。C++ 11 中提供了智能指针的定义，所有关于智能指针的定义可以参考 <memory> 头文件。传统的指针在申请完成后，必须要调用 free 或者 delete 来释放指针，否则容易产生内存泄漏的问题；</li>
<li>smart pointer 遵循 RAII 原则，当 smart pointer 对象创建时，即为该指针分配了相应的内存，当对象销毁时，析构函数会自动释放内存。需要注意的是，智能指针不能像普通指针那样支持加减运算。</li>
<li>同时 <code>smart pointer</code> 重载了 <code>*</code> 和 <code>-&gt;</code> 等操作，使用该对象就像 <code>C</code> 语言中的普通指针一样，但是区别于普通指针的它会自动释放所申请的内存资源</li>
<li>按照常用的使用用途，智能指针有三类:<ul>
<li><p>unique_ptr：独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和赋值。但可以进行移动构造和移动赋值构造（调用 move() 函数），即一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，可以通过该方法进行赋值</p>
</li>
<li><p>shared_ptr：与 unique_ptr 不同的是，shared_ptr 中资源可以被多个指针共享，但是多个指针指向同一个资源不能被释放多次，因此使用计数机制表明资源被几个指针共享；通过 use_count() 查看资源的所有者的个数，可以通过 unique_ptr、weak_ptr 来构造，调用 release() 释放资源的所有权，同时将计数减一，当计数减为 0 时会自动释放内存空间，从而避免了内存泄漏。</p>
<ul>
<li>特别需要注意的是 shared_ptr 并不是线程安全的，但 shared_ptr 的计数是原子操作实现的，利用 atmoic CAS 指令实现。可以看到 share_ptr 的内存模型，当引用计数和 weak count 同时为 0 时，share_ptr 对象才会被最终释放掉</li>
<li>shared_ptr 通过引用计数的方式来管理对象，当进行拷贝或赋值操作时，每个 shared_ptr 都会记录当前对象的引用计数，当引用计数为0时，内存将被自动释放。当对 shared_ptr 赋予新值或者被对象被销毁时，引用计数会递减。但特殊情况出现循环引用时，shared_ptr 无法正常释放资源。循环引用，即 A 指向 B，B 指向 A，在表示双向关系时，是很可能出现这种情况的</li>
</ul>
</li>
<li><p>weak_ptr：指向 share_ptr 指向的对象，能够解决由 shared_ptr 带来的循环引用问题。与 shared_ptr 配合使用，将 weak_ptr 转换为 share_ptr 时，虽然它能访问 share_ptr 所指向的资源但却不享有资源的所有权，不影响该资源的引用计数。有可能资源已被释放，但 weak_ptr 仍然存在，share_ptr 必须等待所有引用的 weak_ptr 全部被释放才会进行释放。因此每次访问资源时都需要判断资源是否有效</p>
</li>
</ul>
</li>
</ul>
<h4 id="智能指针的创建"><a href="#智能指针的创建" class="headerlink" title="智能指针的创建"></a>智能指针的创建</h4><ul>
<li>make_unique 在 C++ 14 以后才被加入到标准的 C++ 中，make_shared 则是 C++ 11 中加入的。优先选用 std::make_unique 和 std::make_shared,而非直接 new</li>
<li>make_unique：减少代码量，能够加快编译速度，定义两遍类型时，编译器需要进行类型推导会降低编译速度，某些意外意外情况下可能会导致内存泄漏。但是 make_unique 不允许自定析构器，不接受 std::initializer_list 对象</li>
<li><code>make_shared</code>：这个主要是可以减少对堆中申请内存的次数，只需要申请一次即可<ul>
<li>使用 new 时，我们将 new 出的资源指针赋给 share_ptr 的 ptr, 然后 share_ptr 本身还需要再次在堆上申请一块单独的内存作为它的管理区，存放引用计数、用户自定的函数等，因此创建 shared_ptr 时需要在堆上申请两次。<br><code>C++ [] std::shared_ptr&lt;Widget&gt;(new Widget);</code></li>
<li>当我们使用 make_share 时，我们只需要申请一块大的内存，一半用来存储资源，另一半作为管理区, 存放引用计数、用户自定的函数等，此时需要在堆上申请一次即可。<br><code>C++ auto upw1(std::make_unique&lt;Widget&gt;());</code></li>
<li>make_share 虽然效率高，但是同样不能自定义析构器，同时 share_ptr 的对象资源可能会延迟释放，因为此时对象资源与管理区域在同一块内存中，必须要同时释放。</li>
</ul>
</li>
</ul>
<h4 id="include-“-“-和-lt-gt-的区别"><a href="#include-“-“-和-lt-gt-的区别" class="headerlink" title="include “ “ 和 &lt;&gt; 的区别"></a>include “ “ 和 &lt;&gt; 的区别</h4><ul>
<li>include 关键字主要用来标识 C&#x2F;C++ 程序源代码编译时需要引用的头文件，编译器会自动去查找这些头文件中的变量、函数声明、结构体定义等相关信息，常见的有 include <filename> 和 #include “filename”，二者之间的区别:<ul>
<li>查找文件的位置：include<filename> 通常在编译器或者 IDE 中预先指定的搜索目录中进行搜索，通常会搜索 &#x2F;usr&#x2F;include 目录，此方法通常用于包括标准库头文件；#include “filename” 在当前源文件所在目录中进行查找，如果没有；再到当前已经添加的系统目录（编译时以 -I 指定的目录）中查找，最后会在 &#x2F;usr&#x2F;include 目录下查找 </li>
<li>日常编写程序时，对于标准库中的头文件常用 include<filename>，对于自己定义的头文件常用 #include “filename”。</li>
</ul>
</li>
<li>__has_include：C++ 17 支持该特性，用来检查是否已经包含某个文件:</li>
</ul>
<h3 id="C-语言对比"><a href="#C-语言对比" class="headerlink" title="C++ 语言对比"></a>C++ 语言对比</h3><h4 id="C-和-C-的对比"><a href="#C-和-C-的对比" class="headerlink" title="C 和 C++ 的对比"></a>C 和 C++ 的对比</h4><ul>
<li>C 语言是典型面向过程（Procedure Oriented）的编程语言，C++ 则是典型面向对象（Object Oriented）的编程语言，当然 C++ 也支持面向过程编程。<ul>
<li>面向过程（Procedure Oriented）：一种以过程为中心的编程思想，侧重于分析解决问题所需的步骤，使用函数把这些步骤依次实现。</li>
<li>面向对象（Object Oriented）：侧重于把构成问题的事务分解为各个对象。建立对象的目的不是完成其中的一个步骤，而是描述某个事务在解决整个具体问题步骤中的行为。面向对象语言的显著特征就是支持封装、继承、类的抽象。</li>
</ul>
</li>
<li><code>C</code> 语言是面向过程的编程，它最重要的特点是函数，通过 <code>main</code> 函数来调用各个子函数。程序运行的顺序都是程序员事先决定好的。</li>
<li>C++ 是面向对象的编程，类是它的主要特点，在程序执行过程中，先由主 main 函数进入，定义一些类，根据需要执行类的成员函数，过程的概念被淡化了（实际上过程还是有的，就是主函数的那些语句）。以类驱动程序运行，类就是对象，所以我们称之为面向对象程序设计。面向对象在分析和解决问题的时候，将涉及到的数据和数据的操作封装在类中，通过类可以创建对象，以事件或消息来驱动对象执行处理。</li>
<li>两者之间的比较: C++ 既继承了 C 强大的底层操作特性，又被赋予了面向对象机制。它特性繁多，支持面向对象语言的多继承、对值传递与引用传递的区分以及 const 关键字，现代 C++ 编译器完全兼容 C 语言语法<ul>
<li>相同之处:  C++ 能够大部分兼容 C 的语法，且二者之间相同的关键字和运算符功能和作用也几乎相同；二者之间的内存模型与硬件比较接近，几乎都可以直接操纵硬件。栈、堆、静态变量这些概念在两种语言都存在。</li>
<li>不同之处：<ul>
<li>C 为面向过程的编程语言，不支持面向对象，不支持继承、多态、封装。</li>
<li>类型检查更为严格，C 语言中的类型转换几乎是任意的，但是 C++ 编译器对于类型转换进行非常严格检查，部分强制类型转换在 C 语言编译器下可以通过，但在 C++ 编译器下无法通过。</li>
<li>C 和 C++ 中都有结构的概念，但是在 C 语言中结构只有成员变量，而没成员方法，C 的成员变量没有权限控制，该结构体的变量对所有调用全部可见；而在 C++ 中结构中，它可以有自己的成员变量和成员函数，C++ 对类的成员变量具有访问权限控制。</li>
<li>增加了面向对象的机制、泛型编程的机制（Template）、异常处理、引用、运算符重载、标准模板库（STL）、命名空间（避免全局命名冲突）。</li>
<li>应用领域：对于 C 语言程序员来说，程序的底层实现和内存分布基本上都可见，所以一般常用于直接控制硬件，特别是 C 语言在嵌入式领域应用很广，比如常见的驱动开发等与硬件直接打交道的领域，C++ 可以用于应用层开发，用户界面开发等与操作系统打交道的领域，特别是图形图像编程领域，几乎所有的高性能图形图像库都是用 C++ 实现的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Java-和-C-的对比"><a href="#Java-和-C-的对比" class="headerlink" title="Java 和 C++ 的对比"></a>Java 和 C++ 的对比</h4><ul>
<li><code>Java</code> 和 <code>C++</code> 都是典型的面向对象（<code>Object Oriented</code>）的编程语言</li>
<li><code>Java</code> 是一种广泛使用的计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级 <code>Web</code> 应用开发和移动应用开发；Java 编程语言的风格十分接近 C++ 语言。继承了 C++ 语言面向对象技术的核心，舍弃了容易引起错误的指针，以引用取代；移除了 C++ 中的运算符重载和多重继承特性，用接口取代；增加垃圾回收器功能。引入了泛型编程、类型安全的枚举、不定长参数和自动装&#x2F;拆箱特性。Java 不同于一般的编译语言或解释型语言。它首先将原始码编译成字节码，再依赖各种不同平台上的虚拟机 （JVM）来解释执行字节码，从而具有 “一次编写，到处运行”的跨平台特性</li>
<li><strong>相同之处</strong>: <code>C++</code> 与 <code>Java</code> 均支持面对对象（<code>Object Oriented</code>），支持类、继承、封装等常见的概念</li>
<li>两者之间的不同之处：<ul>
<li>Java 被编译成字节码，并运行在虚拟机 JVM 上，和开发平台无关，具有跨平台的特性；C++ 直接编译成可执行文件，是否跨平台在于用到的编译器的特性是否有多平台的支持</li>
<li>Java 是完全面向对象的语言，所有函数和变量部必须是类的一部分。除了基本数据类型之外，其余的都作为类对象，包括数组。对象将数据和方法结合起来，把它们封装在类中，这样每个对象都可实现自己的特点和行为。而 C++ 允许将函数和变量定义为全局的。</li>
<li>由于Java 被编译为字节码，只要安装能够运行 Java 的虚拟机即可运行 Java 程序，因此 Java 程序具有很强的可移植性，具有 “一次编写，到处运行” 的跨平台特性；而 C++ 跨平台后，必须需要重新编译；</li>
<li>Java 语言具有垃圾回收机制，由系统进行分配和回收内存，编程人员无需考虑内存管理的问题，可以有效的防止内存泄漏，有效的使用空闲的内存。Java 所有的对象都是用 new 操作符建立在内存堆栈上，类似于 C++ 中的 new 操作符，但是当要释放该申请的内存空间时，Java 自动进行内存回收操作，Java 中的内存回收是以线程的方式在后台运行的，利用空闲时间。C++ 则需要程序员进行内存管理，当资源释放时需要程序员进行手动释放内存空间。</li>
<li>C++ 支持多重继承，允许多个父类派生一个类，虽然功能很强大，但是如果使用的不当会造成很多问题，例如：菱形继承；Java 不支持多重继承，但允许一个类可以继承多个接口，可以实现 C++ 多重继承的功能，但又避免了多重继承带来的许多不便。</li>
<li>C++ 支持方法与操作符的重载；但 Java 只支持方法重载，不支持操作符重载。</li>
<li>C++ 用 virtual 关键字标记的方法可以被覆盖；Java 中非 static 方法均可被覆盖，Java 中的方法默认均可以被覆盖。</li>
<li>C++ 可以直接操作指针，容易产生内存泄漏以及非法指针引用的问题；Java 并不是没有指针，虚拟机（JVM）内部还是使用了指针，只是编程人员不能直接使用指针，不能通过指针来直接访问内存，并且 Java 增加了内存管理机制。</li>
<li>C++ 标准库不提供 thread 相关接口；Java 的标准 SDK 提供 thread 类。</li>
<li>C++ 支持结构体（structure）与联合体（union），Java 不支持结构体（structure）与联合体（union）。</li>
<li>从应用场景来说， C++ 可以直接编译成可执行文件，运行效率比 Java 高。Java 目前主要用来开发 Web 应用。C++ 主要用在嵌入式开发、网络、并发编程、图形图像处理、系统编程的方面。</li>
</ul>
</li>
</ul>
<h4 id="Python-和-C-的对比"><a href="#Python-和-C-的对比" class="headerlink" title="Python 和 C++ 的对比"></a>Python 和 C++ 的对比</h4><ul>
<li><p>Python 是一种广泛使用的解释型、高级和通用的编程语言。Python 支持多种编程范型，包括函数式、指令式、反射式、结构化和面向对象编程。它拥有动态类型系统和垃圾回收功能，能够自动管理内存使用，并且其本身拥有一个巨大而广泛的标准库。它的语言结构以及面向对象的方法旨在帮助程序员为小型的和大型的项目编写清晰的、合乎逻辑的代码</p>
</li>
<li><p>相比于 C 或 Java，Python 让开发者能够用更少的代码表达想法。Python 解释器本身几乎可以在所有的操作系统中运行。Python 的官方解释器 CPython 是用 C 语言编写的</p>
</li>
<li><p>Python 是多泛型编程语言。它完全支持结构化编程和面向对象编程，还有很多特征支持函数式编程和元编程比如元对象协议（元类和魔术方法）。通过扩展还可以支持很多范型，包括面向切面编程、契约式设计和逻辑编程。</p>
</li>
<li><p>Python 使用动态类型，在内存管理上采用引用计数和环检测相结合的垃圾收集器。它的特征还有动态名字解析（后期绑定（英语：late binding）），即在程序执行期间绑定方法和变量的名字。</p>
</li>
<li><p>Python 对遵循 LISP 传统的函数式编程提供了有限的支持，它提供了 map、filter 和 reduce 函数；列表推导式、字典、集合和生成器表达式。标准库中的模块 functools 和 itertools，实现了从 Haskell 和 Standard ML 借鉴来的函数式工具</p>
</li>
<li><p><strong>二者的相同之处</strong>:<code>C++</code> 与 <code>Python</code> 均支持面向对象，二者均可用来编写大型应用程序</p>
</li>
<li><p>二者的不同之处：</p>
<ul>
<li>从语言自身来说，Python 为脚本语言，解释执行，不需要经过编译，所有的 python 源代码都是经过 Python 解释器；C++ 是一种需要编译后才能运行的语言，在特定的机器上编译后运行。</li>
<li>Python 变量的作用域不仅局限于（while，for）循环内，在循环外还可以继续访问在循环内定义的变量；C++ 则不允许循环外访问循环内定义的变量。</li>
<li>Python 没有严格限定函数的参数类型和返回值类型；C++ 则严格限定函数参数和返回值的类型。</li>
<li>从运行效率来说，C++ 运行效率高，安全稳定。Python 代码和 C++ 最终都会变成 CPU 指令来跑，但一般情况下，比如反转和合并两个字符串，Python 最终转换出来的 CPU 指令会比 C++ 多很多。首先，Python 中涉及的内容比 C++ 多，经过了更多层，Python 中甚至连数字都是 object；其次，Python 是边解释边执行，和物理机 CPU 之间多了解释器这层，而 C++ 是编译执行的，直接就是机器码，编译的时候编译器又可以进行一些优化。</li>
<li>从开发效率来说，Python 开发效率高。Python 一两句代码就能实现的功能，C++ 往往需要更多的代码才能实现。</li>
<li>书写格式和语法不同，Python 的语法格式不同于其 C++ 定义声明才能使用，而且极其灵活，完全面向更上层的开发者，C++ 是严格静态类型声明语言，编译器在进行编译时必须经过严格的静态类型检查，如果发现类型检查错误，则中止编译；Python 为动态类型语言，我们在编写代码时不用指定变量的类型，只在执行时才会进行变量类型推导，确定变量类型。</li>
<li>C++ 可以直接用来操纵硬件，适合用来作为系统编程；Python 作为一门脚本语言，功能小巧而精湛，非常适合做工具开发和运维开发。</li>
</ul>
</li>
</ul>
<h4 id="C-11-新特性"><a href="#C-11-新特性" class="headerlink" title="C++ 11 新特性"></a>C++ 11 新特性</h4><ul>
<li><p>auto 类型推导:</p>
<ul>
<li><p>auto 关键字：自动类型推导，编译器会在 编译期间 通过初始值或者函数返回值推导出变量的类型，通过 auto 定义的变量必须有初始值。</p>
</li>
<li><p>使用 auto 关键字做类型自动推导时，依次施加以下规则：首先，如果初始化表达式是引用，首先去除引用；上一步后，如果剩下的初始化表达式有顶层的 const 或 volatile 限定符，去除掉。使用 auto 关键字声明变量的类型，不能自动推导出顶层的 const 或者 volatile，也不能自动推导出引用类型，需要程序中显式声明</p>
</li>
<li><p>初始化表达式为数组，<code>auto</code> 关键字推导的类型为指针。数组名在初始化表达式中自动隐式转换为首元素地址的右值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">9</span>]; </span><br><span class="line"><span class="keyword">auto</span> j = a; <span class="comment">// 此时j 为指针为 int* 类型，而不是 int(*)[9] 类型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编译器推导出来的类型和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则</p>
</li>
</ul>
</li>
<li><p>decltype 类型推导:</p>
<ul>
<li><p>decltype 关键字：decltype 是 “declare type” 的缩写，译为“声明类型”。和 auto 的功能一样，都用来在编译时期进行自动类型推导。如果希望从表达式中推断出要定义的变量的类型，但是不想用该表达式的值初始化变量，这时就不能再用 auto。decltype 作用是选择并返回操作数的数据类型</p>
</li>
<li><p>auto 根据 &#x3D; 右边的初始值 val1 + val2 推导出变量的类型，并将该初始值赋值给变量 var；decltype 根据 val1 + val2 表达式推导出变量的类型，变量的初始值和与表达式的值无关。</p>
</li>
<li><p>auto 要求变量必须初始化，因为它是根据初始化的值推导出变量的类型，而 decltype 不要求，定义变量的时候可初始化也可以不初始化。</p>
</li>
<li><p>类似于 sizeof 操作符，decltype 不对其操作数求值。decltype(e) 返回类型前，进行了如下推导:</p>
<ul>
<li><p>若表达式 e 为一个无括号的变量、函数参数、类成员访问，那么返回类型即为该变量或参数或类成员在源程序中的“声明类型”；</p>
</li>
<li><p>否则的话，根据表达式的值分类（value categories），设 T 为 e 的类型：</p>
<p>若 e 是一个左值（lvalue，即“可寻址值”），则 decltype(e) 将返回T&amp;；<br>若 e 是一个临终值（xvalue），则返回值为 T&amp;&amp; ；<br>若 e 是一个纯右值（prvalue），则返回值为 T。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>lambda</code> 表达式，又被称为 <code>lambda</code> 函数或者 <code>lambda</code> 匿名函数。<br><code>lambda</code> 匿名函数的定义: </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[capture list] (parameter list) -&gt; <span class="keyword">return</span> type</span><br><span class="line">&#123;</span><br><span class="line">function body;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>capture list：捕获列表，指 lambda 所在函数中定义的局部变量的列表。定义在与 lambda 函数相同作用域的参数引用也可以被使用，一般被称作 closure（闭包），以下为闭包的常见用法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[]      <span class="comment">// 沒有定义任何变量。使用未定义变量会引发错误。</span></span><br><span class="line">[x, &amp;y] <span class="comment">// x以传值方式传入（默认），y以引用方式传入。</span></span><br><span class="line">[&amp;]     <span class="comment">// 任何被使用到的外部变量都隐式地以引用方式加以引用。</span></span><br><span class="line">[=]     <span class="comment">// 任何被使用到的外部变量都隐式地以传值方式加以引用。</span></span><br><span class="line">[&amp;, x]  <span class="comment">// x显式地以传值方式加以引用。其余变量以引用方式加以引用。</span></span><br><span class="line">[=, &amp;z] <span class="comment">// z显式地以引用方式加以引用。其余变量以传值方式加以引用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>return type</code>、<code>parameter list</code>、<code>function body</code>：分别表示返回值类型、参数列表、函数体，和普通函数一样</p>
</li>
<li><p>需要注意的是 lambda 函数按照值方式捕获的环境中的变量，在 lambda 函数内部是不能修改的。否则，编译器会报错。其值是 lambda 函数定义时捕获的值，不再改变。如果在 lambda 函数定义时加上 mutable 关键字，则该捕获的传值变量在 lambda 函数内部是可以修改的，对同一个 lambda 函数的随后调用也会累加影响该捕获的传值变量，但对外部被捕获的那个变量本身无影响</p>
</li>
</ul>
</li>
<li><p>范围 <code>for</code> 语句：</p>
<ul>
<li><p>语法格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : expression)&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>expression：必须是一个序列，例如用花括号括起来的初始值列表、数组、vector，string 等，这些类型的共同特点是拥有能返回迭代器的 beign、end 成员。</p>
</li>
<li><p>declaration：此处定义一个变量，序列中的每一个元素都能转化成该变量的类型，常用 auto 类型说明符。</p>
</li>
</ul>
</li>
<li><p>右值引用：</p>
<ul>
<li>C++ 表达式中的 “值分类”（value categories）属性为左值或右值。其中左值是对应（refer to）内存中有确定存储地址的对象的表达式的值，而右值是所有不是左值的表达式的值。因而，右值可以是<strong>字面量、临时对象</strong>等表达式。</li>
<li>能否被赋值不是区分 C++ 左值与右值的依据，C++ 的 const 左值是不可赋值的；而作为临时对象的右值可能允许被赋值。左值与右值的根本区别在于是否允许取地址 &amp; 运算符获得对应的内存地址。</li>
<li>C++ 标准定义了在表达式中左值到右值的三类隐式自动转换：<ul>
<li>左值转化为右值；如整数变量 i 在表达式 （i+3）；</li>
<li>数组名是常量左值，在表达式中转化为数组首元素的地址值；</li>
<li>函数名是常量左值，在表达式中转化为函数的地址值；</li>
</ul>
</li>
<li>C++ 03 在用临时对象或函数返回值给左值对象赋值时的深度拷贝（deep copy），因此造成性能低下。考虑到临时对象的生命期仅在表达式中持续，如果把临时对象的内容直接移动（move）给被赋值的左值对象（右值参数所绑定的内部指针复制给新的对象，然后把该指针置为空），效率改善将是显著的。右值引用就是为了实现 move 与 forward 所需要而设计出来的新的数据类型。</li>
<li>右值引用的实例对应于临时对象；右值引用并区别于左值引用，用作形参时能通过函数重载来区别对象是调用拷贝构造函数还是移动拷贝构造函数。实际上无论是左值引用还是右值引用，从编译后的反汇编层面上，都是对象的存储地址的引用。右值引用与左值引用的变量都不能悬空，也即定义时必须初始化从而绑定到一个对象上。</li>
<li>C++ 右值引用即绑定到右值的引用，用 &amp;&amp; 来获得右值引用，<strong>右值引用只能绑定到要销毁的对象</strong>。为了和右值引用区分开，常规的引用称为左值引用。<strong>左值引用是绑定到左值对象上；右值引用是绑定到临时对象上</strong>。左值对象是指可以通过取地址 &amp; 运算符得到该对象的内存地址；而临时对象是不能用取地址 &amp; 运算符获取到对象的内存地址，具体的引用绑定规则如下:<ul>
<li>非常量左值引用（X &amp;）：只能绑定到 X 类型的左值对象；</li>
<li>常量左值引用（const X &amp;）：可以绑定到 X、const X 类型的左值对象，或 X、const X 类型的右值；</li>
<li>非常量右值引用（X &amp;&amp;）：只能绑定到 X 类型的右值；</li>
<li>常量右值引用（const X &amp;&amp;）：可以绑定规定到 X、const X 类型的右值。</li>
</ul>
</li>
</ul>
</li>
<li><p>标准库 move() 函数：通过该函数可获得绑定到左值上的右值引用。通过 move 获取变量的右值引用，从而可以调用对象的移动拷贝构造函数和移动赋值构造函数。</p>
</li>
<li><p>智能指针: <code>auto_ptr</code> 在 <code>C++ 11</code> 中取而代之的是 <code>unique_ptr</code></p>
</li>
<li><p>使用或禁用对象的默认函数:</p>
<ul>
<li>在旧版本的 C++ 中，若用户没有提供，则编译器会自动为对象生成默认构造函数（default constructor)、复制构造函数（copy constructor），赋值运算符（copy assignment operator operator&#x3D;）以及析构函数（destructor）。C++ 也为所有的类定义了数个全局运算符（如operator delete 及 operator new）。当用户有需要时，也可以提供自定义的版本改写上述的函数。</li>
<li>由于无法精确地控制这些默认函数的生成，要让类不能被拷贝，必须将复制构造函数与赋值运算符声明为 private，并不去定义它们，尝试使用这些未定义的函数会导致编译期或链接期的错误。此外，编译器产生的默认构造函数与用户定义的构造函数无法同时存在。若用户定义了任何构造函数，编译器便不会生成默认构造函数； 但有时同时部分场景下需要同时具有两者提供的构造函数。C++ 11 中允许显式地表明采用或拒用编译器提供的内置函数。</li>
<li>允许编译器生成默认的构造函数:<ul>
<li>default 函数：&#x3D; default 表示编译器生成默认的函数，例如：生成默认的构造函数。</li>
</ul>
</li>
<li>禁止编译器使用类或者结构体中的某个函数:<ul>
<li>delete 函数：&#x3D; delete 修改某个函数则表示该函数不能被调用。与 default 不同的是，&#x3D; delete 也能适用于非编译器内置函数，所有的成员函数都可以用 &#x3D;delete 来进行修饰。</li>
</ul>
</li>
</ul>
</li>
<li><p>constexpr：</p>
<ul>
<li>常量表示式对编译器来说是优化的机会，编译器时常在编译期执行它们并且将值存入程序中。同样地，在许多场合下，C++ 标准要求使用常量表示式。例如在数组大小的定义上，以及枚举值（enumerator values）都要求必须是常量表示式。常量表示式不能含有函数调用或是对象构造函数</li>
<li><code>C++ 11</code> 引进关键字 <code>constexpr</code> 允许用户保证函数或是对象构造函数是编译期常量，编译器在编译时将去验证函数返回常量</li>
<li>用 constexpr 修饰函数将限制函数的行为。<ul>
<li>函数的回返值类型不能为void；</li>
<li>函数体不能声明变量或定义新的类型；</li>
<li>函数体只能包含声明、null语句或者一段return语句；</li>
<li>函数的内容必须依照 “return expr” 的形式，在参数替换后，expr 必须是个常量表达式；</li>
<li>这些常量表达式只能够调用其他被定义为 constexpr 的函数，或是其他常量形式的参数。</li>
</ul>
</li>
<li>constexpr 修饰符的函数直到在该编译单元内被定义之前是不能够被调用的。声明为 constexpr 的函数也可以像其他函数一样用于常量表达式以外的调用。</li>
<li>C++ 11 中的常量表达式中的变量都必须是常量，可以使用 constexpr 关键字来定义表达式中的变量</li>
<li>如果创建用户定义类型的常量表达式，则自定义类型的构造函数必须用 constexpr 声明，函数体仅包含声明或 null 语句，不能声明变量或定义类型。构造函数的实参值应该是常量表达式，直接初始化类的数据成员。同时该类型对象的拷贝构造函数应该也定义为 constexpr，以允许 constexpr 函数返回一个该类型的对象</li>
</ul>
</li>
<li><p>初始化列表 initializer list：</p>
<ul>
<li>C++ 11 把初始化列表的定义为标准类型，称作 std::initializer_list。允许构造函数或其他函数像参数般地使用初始化列表，在对象中可以定义初始化列表构造函数。</li>
<li>初始化列表是常量；一旦被创建，其成员均不能被改变，成员中的资料也不能够被变动。</li>
<li>在 C++ 11 中初始化列表是标准类型，除了对象的构造函数之外还能够被用在其他地方，一般的函数能够使用初始化列表作为形参</li>
</ul>
</li>
<li><p>nullptr:</p>
<ul>
<li>在 C 语言中，常量 0 带有常量及空指针的双重身份。C 使用宏定义 NULL 表示空指针，让 NULL 及 0 分别代表空指针及常量 0。 NULL 可被定义为 ((void*)0) 或是 0。这样容易引起语义歧义，比如 char* c &#x3D; NULL，NULL 只能定义为 0，这样可能使得函数重调用错误，比如调用 f(NULL)，NULL 隐式被转换为 0，这样实际编译器可能会调用 f(int)，但实际上可能希望调用 f(char *)</li>
<li>C++ 11 引入了新的关键字来代表空指针常量：nullptr，将空指针和整数 0 的概念拆开。nullptr 的类型为 nullptr_t，能隐式转换为任何指针或是成员指针的类型，也能和它们进行相等或不等的比较</li>
<li>nullptr 不能隐式转换为整数，也不能和整数做比较，因此就避免上述的语义歧义。值得注意的是的 f(nullptr_t) 被隐式转换为 foo(char *) 只会发生在该函数不存在其它的指针类型重载（比如 f(int *), f(double *) 等）时候，否则就会产生歧义错误（可以通过显示声明一个 foo(nullptr_t) 来消除该歧义），如果存在多个指针类型重载，此时需要 f(nullptr) 时，则需要显示声明一个函数来消除歧义</li>
</ul>
</li>
<li><p>可扩展的随机数功能：C++ 11 提供产生伪随机数的新方法。C++ 11 的随机数功能分为两部分：</p>
<ul>
<li>随机数生成引擎，其中包含该生成引擎的状态，用来产生随机数。</li>
<li>随机数分布，这可以用来决定产生随机数的范围，也可以决定以何种分布方式产生随机数。随机数生成对象即是由随机数生成引擎和分布所构成。</li>
<li>针对产生随机数的机制，C++ 11 将会提供三种算法，每一种算法都有其强项和弱项：<br>linear_congruential：可以产生整数，速度较慢，随机数质量较差；<br>subtract_with_carry: 可以产生整数和随机数，速度较快，随机数质量中等；<br>mersenne_twister：可以产生整数，速度较快，随机数质量较好；</li>
<li>C++ 11 将会提供一些标准分布：uniform_int_distribution（离散型均匀分布），bernoulli_distribution（伯努利分布），geometric_distribution（几何分布），poisson_distribution（卜瓦松分布），binomial_distribution（二项分布），uniform_real_distribution（离散型均匀分布)，exponential_distribution（指数分布），normal_distribution（正态分布）和 gamma_distribution（伽玛分布）</li>
</ul>
</li>
</ul>
<h4 id="C-14-C-17-新特性"><a href="#C-14-C-17-新特性" class="headerlink" title="C++ 14, C++ 17 新特性"></a>C++ 14, C++ 17 新特性</h4><ul>
<li><p>函数返回值类型推导:也可以用 <code>auto</code> 类型，编译时会有编译器进行类型推导。</p>
<ul>
<li>函数内如果有多个 return 语句，它们必须返回相同的类型，否则编译失败。</li>
<li>如果 return 语句返回初始化列表，返回值类型推导也会失败。</li>
<li>如果函数是虚函数，不能使用返回值类型推导。</li>
<li>返回类型推导可以用在递归函数中，但是递归调用必须以至少一个返回语句作为先导，以便编译器推导出返回类型。</li>
<li>在 C++ 14 中，lambda 函数的形式参数允许泛型</li>
</ul>
</li>
<li><p><code>Lambda</code> 初始化捕获: 允许在 <code>lambda</code> 捕获列表中对变量进行表达式赋值，并且支持定义新的变量并进行初始化</p>
</li>
<li><p>constexpr 函数限制变动:C++ 11 中 constexpr 函数只含有一个将被返回的表达式，C++ 14 放松了这些限制：</p>
<ul>
<li>除了 static 或 thread_local 变量 以外，可以声明新的变量，且声明的变量必须初始化</li>
<li>可以包含条件分支语句 if 和 switch。</li>
<li>可以包含所有的循环语句，包括基于范围的for循环。</li>
<li>表达式可以改变一个对象的值，只需该对象的生命期在声明为 constexpr 的函数内部开始</li>
</ul>
</li>
<li><p>std::make_unique: C++ 11 中有 std::make_shared，却没有std::make_unique，在 C++ 14 增加 std::make_unique</p>
</li>
<li><p>共享的互斥体和锁: C++ 14 增加了一类共享的互斥体和相应的共享锁，通过使用 std::shared_timed_mutex 和 std::shared_lock 来进行线程同步。</p>
</li>
<li><p>C++ 17 新特性：</p>
<ul>
<li><p>结构化绑定，利用该特性可以把以 <code>C++</code> 中的 <code>pair</code>，<code>tuple</code>，<code>array</code>，<code>struct</code> 的成员赋值给多个变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> [x, y, z] = std::<span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">2.3</span>, <span class="string">&quot;456&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>if-switch</code> 语句初始化:  <code>if</code> 语句可以支持 <code>if (init; condition)</code> 写法，即在判断条件中对变量进行初始化</p>
</li>
<li><p>constexpr lambda 表达式: C++ 17 前 lambda 表达式只能在运行时使用，C++ 17 引入了 constexpr lambda 表达式，可以用于在编译期进行计算</p>
</li>
<li><p><code>namespace</code> 嵌套:<code>C++ 17</code> 支持命名空间嵌套</p>
</li>
<li><p><code>std::any</code>：增加了 <code>any</code> 可以存储任何类型，可以将其转化为任意类型。</p>
</li>
</ul>
</li>
</ul>
<h3 id="C-关键字与关键库函数"><a href="#C-关键字与关键库函数" class="headerlink" title="C++ 关键字与关键库函数"></a>C++ 关键字与关键库函数</h3><h4 id="sizeof-和-strlen-的区别"><a href="#sizeof-和-strlen-的区别" class="headerlink" title="sizeof 和 strlen 的区别"></a>sizeof 和 strlen 的区别</h4><ul>
<li>strlen 是头文件 <cstring> 中的函数，sizeof 是 C++ 中的运算符。strlen 测量的是字符串的实际长度（其源代码如下），以 \0 结束，而 sizeof 测量的是对象或者表达式类型占用的字节大小</li>
<li>若字符数组 <code>arr</code> 作为函数的形参，<code>sizeof(arr)</code> 中 <code>arr</code> 被当作字符指针来处理，<code>strlen(arr)</code> 中 <code>arr</code> 依然是字符数组</li>
<li>二者的不同之处:<ul>
<li>strlen 本身是库函数，因此<strong>在程序运行过程中，计算长度</strong>；而 sizeof 是在<strong>编译时计算长度</strong>；sizeof 的参数可以是类型，也可以是变量，<strong>且必须是完整类型</strong>；strlen 的参数必须是 char * 类型的变量。</li>
<li>sizeof 接受的参数可以是对象也可以是表达式，但是 <strong>sizeof(expression) 在运行时不会对接受的表达式进行计算</strong>，编译器<strong>只会推导表达式的类型</strong>从而计算占用的字节大小；而 strlen 是一个函数，<strong>如果接受表达式则会对表达式进行运算</strong></li>
</ul>
</li>
</ul>
<h4 id="lambda-表达式的应用"><a href="#lambda-表达式的应用" class="headerlink" title="lambda 表达式的应用"></a>lambda 表达式的应用</h4><ul>
<li><p><code>lambda</code> 匿名函数的定义:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[capture list] (parameter list) -&gt; <span class="keyword">return</span> type</span><br><span class="line">&#123;</span><br><span class="line">function body;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>capture list：捕获列表，指 lambda 所在函数中定义的局部变量的列表。定义在与 lambda 函数相同作用域的参数引用也可以被使用，一般被称作 closure（闭包），以下为闭包的常见用法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[]      <span class="comment">// 沒有定义任何变量。使用未定义变量会引发错误。</span></span><br><span class="line">[x, &amp;y] <span class="comment">// x以传值方式传入（默认），y以引用方式传入。</span></span><br><span class="line">[&amp;]     <span class="comment">// 任何被使用到的外部变量都隐式地以引用方式加以引用。</span></span><br><span class="line">[=]     <span class="comment">// 任何被使用到的外部变量都隐式地以传值方式加以引用。</span></span><br><span class="line">[&amp;, x]  <span class="comment">// x显式地以传值方式加以引用。其余变量以引用方式加以引用。</span></span><br><span class="line">[=, &amp;z] <span class="comment">// z显式地以引用方式加以引用。其余变量以传值方式加以引用。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>return type</code>、<code>parameter list</code>、<code>function body</code>：分别表示返回值类型、参数列表、函数体，和普通函数一样</p>
</li>
</ul>
</li>
<li><p>需要注意的是 lambda 函数按照值方式捕获的环境中的变量，在 lambda 函数内部是不能修改的，否则编译器会报错。其值是 lambda 函数定义时捕获的值，不再改变。如果在 lambda 函数定义时加上 mutable 关键字，则该捕获的传值变量在 lambda 函数内部是可以修改的，对同一个 lambda 函数的随后调用也会累加影响该捕获的传值变量，但对外部被捕获的那个变量本身无影响</p>
</li>
<li><p>引用捕获可能带来悬挂引用常见于使用 lambda 表达式使用引用捕获某个局部变量，而调用 lambda 表达式时，局部变量已经被清理导致捕获的引用指向被清理的内存空间，从而产生悬挂引用。</p>
</li>
<li><p>在 <code>C++ 14</code> 以后，<code>lambda</code> 函数的形式参数允许泛型和初始化捕获。返回值和参数均使用泛型，编译器会根据实际进行类型推导。允许在 <code>lambda</code> 捕获列表中对变量进行表达式赋值，并且支持定义新的变量并进行初始化</p>
</li>
<li><p><code>C++ 17</code> 以后，<code>lambda</code> 函数也支持使用用 <code>constexpr</code> 修饰，此时 <code>lambda</code> 函数内部应当满足 <code>constexpr</code> 的要求。</p>
</li>
</ul>
<h4 id="explicit-的作用"><a href="#explicit-的作用" class="headerlink" title="explicit 的作用"></a>explicit 的作用</h4><ul>
<li>用来声明类构造函数是显式调用的，而非隐式调用，可以阻止调用构造函数时进行隐式转换和赋值初始化。只可用于修饰单参构造函数，因为无参构造函数和多参构造函数本身就是显示调用的，再加上 explicit 关键字也没有什么意义</li>
<li>在日常使用时一般情况下建议声明 explicit 的构造函数，从而可以阻止编译器执行非预期 (往往也不被期望) 的类型转换，因为某些非预期的类型转换可能会引起意向不到的错误</li>
</ul>
<h4 id="C-和-C-static-中的作用"><a href="#C-和-C-static-中的作用" class="headerlink" title="C 和 C++ static 中的作用"></a>C 和 C++ static 中的作用</h4><ul>
<li><p>在 C 语言中，使用 static 可以定义局部静态变量、外部静态变量、静态函数。</p>
</li>
<li><p>在 C++ 中，使用 static 可以定义局部静态变量、外部静态变量、静态函数、静态成员变量和静态成员函数。因为 C++ 中有类的概念，静态成员变量、静态成员函数都是与类有关的概念</p>
</li>
<li><p>static 全局静态变量:</p>
<ul>
<li>普通全局变量和 static 全局静态变量都为静态存储方式。普通全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，普通全局变量在各个源文件中都是有效的</li>
<li>静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。静态全局变量只初始化一次，防止在其他文件中使用</li>
<li>实际上全局静态变量存储在内存的静态存储区，生命周期贯穿于整个程序运行期间。静态变量会被放在程序的静态数据存储区，这样可以在下一次调用的时候还可以保持原来的赋值，静态变量用 static 告知编译器，自己仅仅在变量的作用范围内可见，实际是依靠编译器来控制作用域</li>
</ul>
</li>
<li><p>static 局部静态变量:</p>
<ul>
<li>局部静态变量只能被初始化一次。与全局静态变量不同的是静态局部变量的作用域仅限于函数内部，它的作用域与函数内部的局部变量相同。实际上局部静态变量同样也存储在静态存储区，因此它的生命周期贯穿于整个程序运行期间</li>
</ul>
</li>
<li><p><code>static</code> 静态函数:<code>static</code> 函数限制函数的作用域，仅可在定义该函数的文件内部调用 </p>
</li>
<li><p>static 静态成员变量:</p>
<ul>
<li>静态成员变量是在类内进行声明，在类外进行定义和初始化，在类外进行定义和初始化的时候不要出现 static 关键字和 private、public、protected 访问规则。</li>
<li>静态成员变量相当于类域中的全局变量，被类的所有对象所共享，包括派生类的对象，且只能该变量只能被初始化一次，不能在类的构造函数中对静态成员变量进行初始化</li>
<li>静态成员变量可以作为成员函数的参数，而普通成员变量不可以</li>
<li>静态数据成员的类型可以是所属类的类型，而普通数据成员的类型只能是该类类型的指针或引用。</li>
</ul>
</li>
<li><p>static 静态成员函数:</p>
<ul>
<li>静态成员函数不能调用非静态成员变量或者非静态成员函数，因为静态成员函数没有 this 指针。静态成员函数做为类作用域的全局函数。</li>
<li>静态成员函数不能声明成虚函数（virtual）、const 函数和 volatile 函数</li>
</ul>
</li>
<li><p><code>static</code> 对象: 静态对象的生存周期为整个程序的生命周期，而非静态对象的生命周期只存在于某个循环中</p>
</li>
</ul>
<h4 id="const-作用及用法"><a href="#const-作用及用法" class="headerlink" title="const 作用及用法"></a>const 作用及用法</h4><ul>
<li><p>const 修饰普通变量或者成员变量，定义成 const 常量，相较于宏常量可进行类型检查，节省内存空间，提高了效率。</p>
</li>
<li><p>const 修饰函数参数，使得传递过来的函数参数的值不能改变。</p>
</li>
<li><p>const 修饰成员函数，使得成员函数不能修改任何类型的成员变量（mutable 修饰的变量除外），也不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量。</p>
</li>
<li><p><code>const</code> 变量: 定义成 <code>const</code> 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率。被定义为 <code>const</code> 的变量是不可修改的。</p>
</li>
<li><p><code>const</code> 指针:</p>
<ul>
<li><code>const</code> 修饰指针指向的内容，则指针指向的内容不可变，但是指针本身的内容可以改变，指针常量</li>
<li><code>const</code> 修饰指针，则指针为不可变量，指针指向的内容可以变，但指针本身不能变，常量指针</li>
<li><code>const</code> 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量</li>
</ul>
</li>
<li><p>const 引用:</p>
<ul>
<li>const 引用是指向 const 对象的引用，可以读取变量，但不能通过引用修改指向的对象</li>
<li>可以将 const 引用指向非 const 变量，但不能使用非 const 引用指向 const 变量。</li>
<li>const 引用可以初始化为不同类型的对象或者右值（如字面值常量），但非 const 引用不可以</li>
</ul>
</li>
<li><p>const 成员变量：</p>
<ul>
<li>const 成员变量只能在类内声明、定义，在构造函数初始化列表中初始化。</li>
<li>const 成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的，因为类可以创建多个对象，不同类的 const 成员变量的值是不同的。因此不能在类的声明中初始化 const 成员变量。</li>
</ul>
</li>
<li><p>const 函数参数与返回值:</p>
<ul>
<li>用 const 修饰函数参数，表明函数参数为常量，在函数内部不可以修改参数的内容，一般我们使用 const 指针或者 const 引用。函数返回值如果为指针或者引用，我们可以用 const 指针或者引用接受返回值，此时指向的内容则不可以修改。</li>
</ul>
</li>
<li><p>const 成员函数：</p>
<ul>
<li>不能修改成员变量的值，除非有 mutable 修饰；只能访问成员变量。</li>
<li>不能调用非常量成员函数，以防修改成员变量的值。</li>
</ul>
</li>
<li><p>const 对象只能访问 const 成员函数,而非 const 对象可以访问任意的成员函数，包括 const 成员函数。</p>
</li>
<li><p>加上 mutable 修饰符的数据成员,对于任何情况下通过任何手段都可修改,自然此时的 const 成员函数是可以修改它的</p>
</li>
</ul>
<h4 id="define-和-const-的区别"><a href="#define-和-const-的区别" class="headerlink" title="define 和 const 的区别"></a>define 和 const 的区别</h4><ul>
<li>编译阶段：define 是在编译预处理阶段进行替换，const 是在编译阶段确定其值。</li>
<li>安全性：define 定义的宏常量没有数据类型，只是进行简单的代码替换，不会进行类型安全的检查；const 定义的常量是有类型的，是要进行判断的，可以避免一些低级的错误。</li>
<li>存储空间：define 定义的宏定义只是作为代码替换的表达式而已，宏定义本身不占用内存空间，define 定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，实际使用宏定义替换代码时占用的是代码段的空间；const 定义的常量占用静态存储区的只读空间，程序运行过程中常量只有一份。</li>
<li>调试：define 定义的宏常量不能调试，因为在预编译阶段就已经进行替换了；const 定义的常量可以进行调试。</li>
<li>define 可以接受参数构造非常复杂的表达式，const 不能接受参数。</li>
</ul>
<h4 id="define-和-typedef-的区别"><a href="#define-和-typedef-的区别" class="headerlink" title="define 和 typedef 的区别"></a>define 和 typedef 的区别</h4><ul>
<li>#define 作为预处理指令，在编译预处理时进行替换操作，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。typedef 是关键字，在编译时处理，有类型检查功能，用来给一个已经存在的类型一个别名，但不能在一个函数定义里面使用 typedef 。</li>
<li>typedef 用来定义类型的别名，方便使用。#define 不仅可以为类型取别名，还可以定义常量、变量、编译开关等。</li>
<li>#define 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，如果在 .cpp 文件中定义了宏，则在整个文件中都可以使用该宏，如果在 .h 文件中定义了宏，则只要包含该头文件都可以使用；而 typedef 有自己的作用域，如果在函数之外定义了类型，则在整个文件中都可以使用该类型定义，如果在函数内部定义了该类型，则只能在函数内部使用该类型。</li>
<li>指针的操作：typedef 和 #define 在处理指针时不完全一样</li>
</ul>
<h4 id="用宏实现比较大小，以及两个数中的最小值"><a href="#用宏实现比较大小，以及两个数中的最小值" class="headerlink" title="用宏实现比较大小，以及两个数中的最小值"></a>用宏实现比较大小，以及两个数中的最小值</h4><p>实现比较简单，需要注意括号和作用域的问题，由于 #define 只是做简单的替换，而 #define 中替代时可能含有表达式，因此我们需要用括号进行作用域限制</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(X, Y) ((X) &gt; (Y) ? (X) : (Y))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(X, Y) ((X) &lt; (Y) ? (X) : (Y))</span></span><br></pre></td></tr></table></figure>

<p>上述可能存在重复计算的问题，比如表达式 <code>X,Y</code> 均计算了两次，多次计算在某些场景下性能较低或者会产生影响，可以进行简化如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(x, y) (&#123;				\</span></span><br><span class="line"><span class="meta">	typeof(x) _min1 = (x);			\</span></span><br><span class="line"><span class="meta">	typeof(y) _min2 = (y);			\</span></span><br><span class="line"><span class="meta">	(void) (&amp;_min1 == &amp;_min2);		\</span></span><br><span class="line"><span class="meta">	_min1 &lt; _min2 ? _min1 : _min2; &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x, y) (&#123;				\</span></span><br><span class="line"><span class="meta">	typeof(x) _max1 = (x);			\</span></span><br><span class="line"><span class="meta">	typeof(y) _max2 = (y);			\</span></span><br><span class="line"><span class="meta">	(void) (&amp;_max1 == &amp;_max2);		\</span></span><br><span class="line"><span class="meta">	_max1 &gt; _max2 ? _max1 : _max2; &#125;)</span></span><br></pre></td></tr></table></figure>

<h4 id="inline-作用及使用方法"><a href="#inline-作用及使用方法" class="headerlink" title="inline 作用及使用方法"></a>inline 作用及使用方法</h4><ul>
<li>inline 是一个关键字，可以用于定义内联函数。内联函数，像普通函数一样被调用，但是在调用时并不通过函数调用的机制而是直接在调用点处展开，这样可以大大减少由函数调用带来的开销，从而提高程序的运行效率。在内联函数出现之前，在 C&#x2F;C++ 的大型工程中常见用 #define 定义一些“函数”来消除调用这些函数的开销。内联函数设计的目的之一，就是取代 #define 的这项功能。由于使用 #define 定义的“函数”，编译器不会检查其参数的正确性等，而使用 inline 定义的函数，可以指定参数类型，则会被编译器校验）。内联函数可以在头文件中被定义，并被多个 .cpp 文件 include，而不会有重定义错误。这也是设计内联函数的主要目的之一。</li>
<li>使用方法：类内定义成员函数默认是内联函数，除了虚函数以外，因为虚函数是在运行时决定的，在编译时还无法确定虚函数的实际调用。</li>
<li>在类内定义成员函数，可以不用在函数头部加 inline 关键字，因为编译器会自动将类内定义的函数（构造函数、析构函数、普通成员函数等）声明为内联函数</li>
<li>类外定义成员函数，若想定义为内联函数，需用关键字声明;当在类内声明函数，在类外定义函数时，如果想将该函数定义为内联函数，则可以在类内声明时不加 inline 关键字，而在类外定义函数时加上 inline 关键字。关键字 inline 必须与函数定义体放在一起才能使函数成为内联，如果只是 inline 放在函数声明前面不起任何作用</li>
</ul>
<h4 id="inline-函数工作原理"><a href="#inline-函数工作原理" class="headerlink" title="inline 函数工作原理"></a>inline 函数工作原理</h4><ul>
<li><p>内联函数的工作原理：</p>
<ul>
<li>内联函数不是在调用时发生控制转移关系，而是在编译阶段将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现内联函数的调用表达式用内联函数的函数体来替换。函数调用时，需要切换栈帧寄存器，同时栈中压入参数、返回值，然后进行跳转，这些都需要开销，而<strong>内联函数则可以不要这些开销，直接将内联函数中函数体直接插入或者替换到该函数调用点</strong>。</li>
<li>普通函数是将程序执行转移到被调用函数所存放的内存地址，当函数执行完后，返回到执行此函数前的地方。<strong>转移操作需要保护现场，被调函数执行完后，再恢复现场，该过程需要较大的资源开销</strong>。</li>
<li>虽然内联函数在调用时直接进行展开，但<strong>实际在编译后代码中存在内联函数的定义，可以供编译器进行调用</strong>。普通函数可以有指向它的函数指针，内敛函数也可以有指向它的函数指针。</li>
</ul>
</li>
<li><p>内联函数的优缺点:</p>
<ul>
<li>内联函数具有以下优点：<br><strong>不会产生函数调用开销。</strong>节省了调用函数时在堆栈上推送&#x2F;弹出变量的开销。节省了函数返回调用的开销。当你内联一个函数时，你可以让编译器对函数体执行上下文特定的优化，其他优化可以通过考虑调用上下文和被调用上下文的流程来获得，而对于普通函数不会有这种优化。</li>
<li>内联函数的缺点：<ul>
<li>从内联函数中添加的变量会<strong>消耗额外的寄存器</strong>，在内联函数之后，如果要使用寄存器的变量数量增加，则可能<strong>会在寄存器变量资源利用方面产生开销</strong>。在函数调用点替换内联函数体时，<strong>函数使用的变量总数也会增加，用于存储变量的寄存器数量也会增加</strong>。因此，<strong>如果在函数内联变量数量急剧增加之后，它肯定会导致寄存器利用率的开销</strong>。</li>
<li>如果你使用太多的内联函数，那么<strong>二进制可执行文件的大小会很大，因为相同的代码重复</strong>。</li>
<li>过多的内联也会<strong>降低指令缓存命中率</strong>，从而降低从缓存内存到主内存的指令获取速度。</li>
<li>如果有人更改内联函数内的代码，<strong>内联函数可能会增加编译时间开销</strong>，那么所有调用位置都必须重新编译，因为编译器需要再次替换所有代码，否则它将继续使用旧功能.</li>
<li><strong>内联函数可能会导致抖动</strong>，因为内联可能会增加二进制可执行文件的大小。内存抖动会导致计算机性能下降。</li>
</ul>
</li>
</ul>
</li>
<li><p>inline 函数的使用场景：</p>
<p>内联函数一般只适用于比较短小，处理较为简单的函数。内联只是对编译器的请求，而不是命令。编译器可以忽略内联请求。编译器可能不会在以下情况下执行内联：</p>
<ul>
<li>如果函数包含循环（for, while, do-while）；</li>
<li>如果一个函数包含静态变量；</li>
<li>如果一个函数是递归的；</li>
<li>如果函数返回类型不是 void，并且函数体中不存在 return 语句；</li>
<li>如果函数包含 switch 或 goto 语句；</li>
<li>内联可以去除函数只能定义一次的限制：</li>
</ul>
</li>
<li><p>内联函数可以在程序中定义不止一次， 但是 <strong>inline 函数的定义在某个源文件中只能出现一次</strong>，而且在所有源文件中，其定义必须是完全相同的。一般情况下，我们可以在头文件中定义 inline 函数，所有 include 该头文件，如果修改了头文件中的 inline 函数时，使用了该头文件的所有源文件都必须重新编译。比如我们可以在定义以下两个文件包含相同的函数</p>
</li>
</ul>
<h4 id="宏定义（define）和内联函数（inline）的区别"><a href="#宏定义（define）和内联函数（inline）的区别" class="headerlink" title="宏定义（define）和内联函数（inline）的区别"></a>宏定义（define）和内联函数（inline）的区别</h4><ul>
<li><strong>内联函数是在编译时展开，而宏在编译预处理时展开</strong>；在编译的时候，<strong>内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换</strong>。</li>
<li>内联函数是真正的函数，和普通函数调用的方法一样，在调用点处直接展开，<strong>避免了函数的参数压栈操作，减少了调用的开销</strong>，在编译后的代码段中可以看到内联函数的定义。宏定义编写较为复杂，<strong>常需要增加一些括号来避免歧义</strong>。宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查，因此在<strong>实际使用宏时非常容易出错</strong>。而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查。</li>
<li><strong>内联函数可以进行调试，宏定义的“函数”无法调试</strong>。</li>
<li>由于<strong>类的成员函数全部为内联函数，通过内联函数，可以访问类的数据成员，而宏不能访问类的数据成员</strong>。</li>
<li><strong>在 inline 函数传递参数只计算一次，而在使用宏定义的情况下，每次在程序中使用宏时都会计算表达式参数，因此宏会对表达式参数计算多次</strong></li>
</ul>
<h4 id="new-的作用"><a href="#new-的作用" class="headerlink" title="new 的作用"></a>new 的作用</h4><ul>
<li><p>new 的简介：new 是 C++ 中的关键字，尝试分配和初始化指定或占位符类型的对象或对象数组，并返回指向对象 (或数组的初始对象) 的指针。</p>
</li>
<li><p>用 new 创建对象时，<strong>首先从堆中申请相应的内存空间，然后调用对象的构造函数</strong>，最后返回指向对象的指针。<strong>new 操作符从自由存储区（free store）上为对象动态分配内存空间</strong>，而 <strong>malloc 函数从堆上动态分配内存</strong>。<strong>自由存储区是 C++ 基于 new 操作符的一个抽象概念，凡是通过 new 操作符进行内存申请，该内存即为自由存储区</strong>。而<strong>堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配</strong>，C 语言使用 malloc 从堆上分配内存，使用 free 释放已分配的对应内存<strong>。new 可以指定在内存地址空间创建对象</strong>，用法如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new (place_address) type</span><br></pre></td></tr></table></figure>

<p>place_address 为一个指针，代表一块内存的地址。当使用上面这种仅以一个地址调用 new 操作符时，new 操作符调用特殊的 operator new：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="type">size_t</span>, <span class="type">void</span> *)</span> </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于指定的地址的 <code>new</code> 对象，在释放时，不能直接调用 <code>delete</code>, 应该先调用对象的析构函数，然后再对内存进行释放。</p>
</li>
<li><p><code>new</code> 可以用来动态生成对象数组，但此时 <code>new</code> 生成的数组，只能用 <code>delete</code> 来释放</p>
</li>
<li><p>在 cpp 中由于 new 作为操作符可以进行重载，所以可以对 new 进行重载，比如可以指定构造函数对对象进行初始化。对 new 操作符可以进行全局重载和局部重载，全局重载后，所有调用 new 的操作都会被重写；局部重载就是在类中重写 operator new 函数，但只会对该类生效，即该类执行 new 操作时会生效</p>
</li>
</ul>
<h4 id="new-和-malloc-的区别"><a href="#new-和-malloc-的区别" class="headerlink" title="new 和 malloc 的区别"></a>new 和 malloc 的区别</h4><ul>
<li>malloc 的实现原理：malloc 为 C 语言的库函数，主要用来从堆中申请指定大小且连续的内存空间。由于现代操作系统用户程序都是采用虚拟地址空间，理论上对于一个程序来说，在 64 位地址空间下，它可见的地址空间为 0x0000000000000000-0xFFFFFFFFFFFFFFF，而程序中的 heap 段是虚拟地址中的一段连续的空间。程序运行时，操作系统会预先为程序分配 heap 段，虽然程序的运行，使用的 heap 空间不断增大，当操作系统已分配的空间不够使用时，这时会通过 mmap 映射新的物理内存页加入到 heap 空间中，并将新加入的物理页映射到 heap 的末尾，从而形成连续的虚拟内存空间</li>
<li>new 与 malloc 的区别：<ul>
<li>new 在申请内存的同时，会调用对象的构造函数，对象会进行初始化，malloc 仅仅在堆中申请一块指定大小的内存空间，并不会对内存和对象进行初始化。</li>
<li>new 可以指定内存空间初始化对象，而 malloc 只能从堆中申请内存。</li>
<li>new 是 c++ 中的一个操作符，而 malloc 是 C 中的一个函数。</li>
<li>new 的返回值为一个对象的指针类型，而 malloc 统一返回 void * 指针。</li>
<li>new 内存分配成功，返回该对象类型的指针，分配失败，抛出 bad_alloc 异常；而 malloc 成功申请到内存，返回指向该内存的指针；分配失败，返回 NULL 指针。</li>
<li>new 的空间大小由编译器会自动计算，而 malloc 则需要指定空间大小。</li>
<li>new 作为一个运算符可以进行重载，而 malloc 作为一个函数不支持重载。</li>
<li>malloc 可以更改申请过的空间大小，我们可以 realloc 指定空间大小，而 new 一旦申请则无法更改</li>
</ul>
</li>
</ul>
<h4 id="delete-与-free-的区别"><a href="#delete-与-free-的区别" class="headerlink" title="delete 与 free 的区别"></a>delete 与 free 的区别</h4><ul>
<li>free 释放 heap 中申请的动态内存空间，只能释放 malloc，calloc，realloc 申请的内存。<ul>
<li>需要注意的是，free 函数只是将参数指针指向的内存归还给操作系统，并不会把参数指针置 NULL，为了以后访问到被操作系统重新分配后的错误数据，所以在调用 free 之后，通常需要手动将指针置 NULL。</li>
<li>内存资源都是由操作系统来管理的，而不是编译器，编译器只是向操作系统提出申请，所以 free 函数是没有能力去真正的 free 内存的，只是向内存管理模块归还了内存，其他模块还可以继续申请使用这些内存。</li>
<li>free 后指针仍然指向原来的堆地址，实际还可以使用，但操作系统可能将这块内存已经分配给其他模块使用，一般建议在 free 以后将指针置为空。一个指针经过两次 free，也是比较危险的操作，因为可能该段内存已被别的内存使用申请使用了，free 之后会造成严重后果</li>
</ul>
</li>
<li>delete 是 C++ 中的一个操作符，如果对象存在析构函数，它首先执行该对象所属类的析构函数，进而通过调用 operator delete 的标准库函数来释放所占的内存空间。<ul>
<li>delete 用来释放单个对象所占的空间，只会调用一次析构函数；</li>
<li>delete [] 用来释放数组空间，会对数组中的每个元素都调用一次析构函数。</li>
<li>delete 只能用来释放 new 操作返回的指针，否则会产生不可预知的后果。</li>
<li>在单个对象上的删除 使用 delete [] 的数组形式，以及对数组使用非数组形式的删除都会产生不可预知的后果。如果 new 的对象是指定地址，则不能直接调用 delete</li>
</ul>
</li>
<li>delete 与 free 的区别：<ul>
<li>delete 是 C++ 中的一个操作符，可以进行重载；而 free 是 C 中的一个函数，不能进行重载；</li>
<li>free 只会释放指向的内存，不会执行对象的析构函数；delete 则可以执行对象的析构函数；</li>
</ul>
</li>
</ul>
<h4 id="C-和-C-struct-的区别"><a href="#C-和-C-struct-的区别" class="headerlink" title="C 和 C++ struct 的区别"></a>C 和 C++ struct 的区别</h4><ul>
<li>在 C 语言中 struct 是用户自定义数据类型；在 C++ 中 struct 是抽象数据类型，支持成员函数的定义。C++ 中的 class 可以实现 struct 的所有功能，C++ 为了兼容 C 语言保留了 struct 关键字。</li>
<li>C 语言中 struct 没有访问权限的设置，是一些变量的集合体，不能定义成员函数；C++ 中 struct 可以和类一样，有访问权限，并可以定义成员函数。</li>
<li>C 语言中 struct 定义的自定义数据类型，在定义该类型的变量时，需要加上 struct 关键字，例如：struct A var;，定义 A 类型的变量；而 C++ 中，不用加该关键字，例如：A var。</li>
<li>C++ 中 struct 可以继承，也可以实现多态，而 C 语言中不支持继承和多态。</li>
</ul>
<h4 id="struct-和-union-的区别"><a href="#struct-和-union-的区别" class="headerlink" title="struct 和 union 的区别"></a>struct 和 union 的区别</h4><ul>
<li>union 是联合体，struct 是结构体。<strong>union 中的所有成员变量共享同一段内存空间</strong>，struct 中的每个成员变量独占内存空间。</li>
<li>联合体和结构体都是由若干个数据类型不同的数据成员组成。使用时，<strong>联合体只有一个有效的成员；而结构体所有的成员都有效</strong>。</li>
<li><strong>对联合体的不同成员赋值，将会对覆盖其他成员的值，而对于结构体的对不同成员赋值时，相互不影响</strong>。</li>
<li>联合体的大小为其内部所有变量的最大值，<strong>按照最大类型的倍数进行分配大小</strong>；<strong>结构体分配内存的大小遵循内存对齐原则</strong>。</li>
<li>struct 可以定义变长数组成员变量 int a[]，union 中不能包含有这种不确定长度的变量。</li>
</ul>
<h4 id="class-和-struct-的异同"><a href="#class-和-struct-的异同" class="headerlink" title="class 和 struct 的异同"></a>class 和 struct 的异同</h4><ul>
<li>C++ 中为了兼容 C 语言而保留了 C 语言的 struct 关键字，并且加以扩充。在 C 语言中，struct 只能包含成员变量，不能包含成员函数。而在 C++ 中，struct 类似于 class，既可以包含成员变量，又可以包含成员函数。</li>
<li>C++ 中的 struct 和 class 基本是通用的，唯有几个细节不同：<ul>
<li>class 中类中的成员默认都是 private 属性的；而在 struct 中结构体中的成员默认都是 public 属性的。</li>
<li>class 继承默认是 private 继承，而 struct 继承默认是 public 继承。</li>
<li>class 可以用于定义模板参数，struct 不能用于定义模板参数</li>
</ul>
</li>
</ul>
<h4 id="volatile-的作用与使用场景"><a href="#volatile-的作用与使用场景" class="headerlink" title="volatile 的作用与使用场景"></a>volatile 的作用与使用场景</h4><ul>
<li>volatile 的作用：当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为 volatile，告知编译器不应对这样的对象进行优化。volatile 关键字修饰变量后，提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如果没有 volatile 关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。</li>
<li>使用 volatile 关键字试图阻止编译器过度优化，volatile 主要作用如下：<ul>
<li>阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回；（缓存一致性协议、轻量级同步）</li>
<li>阻止编译器调整操作 volatile 变量的指令排序。</li>
<li>写入变量时，阻止编译器对指令顺序的优化: 在某些特定的场景下，比如读写寄存器或者操作某些硬件，需要按照某些特定的指令序列读写寄存器，而不能忽略其中的某些步骤</li>
</ul>
</li>
<li>volatile 的应用场景：<ul>
<li>在实际场景中除了操纵硬件需要用到 volatile 以外，更多的可能是多线程并发访问共享变量时，一个线程改变了变量的值，怎样让改变后的值对其它线程可见，此时我们就需要使用 volatile 进行修饰。</li>
<li>一般说来，volatile 用在如下的几个地方：<ul>
<li>中断服务程序中修改的供其它程序检测的变量需要加 volatile；</li>
<li>多任务环境下各任务间共享的标志应该加 volatile；</li>
<li>存储器映射的硬件寄存器通常也要加 volatile 说明，因为每次对它的读写都可能有不同意义</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="返回函数中静态变量的地址会发生什么"><a href="#返回函数中静态变量的地址会发生什么" class="headerlink" title="返回函数中静态变量的地址会发生什么"></a>返回函数中静态变量的地址会发生什么</h4><ul>
<li>静态局部变量存在静态区，程序初始化时则已经创建了改变量，变量的生存周期为整个程序的生命周期。函数 fun 中定义了静态局部变量 var，使得离开该函数的作用域后，该变量不会销毁，返回到主函数中，该变量依然存在，从而使程序得到正确的运行结果，该静态局部变量直到程序运行结束后才销毁。</li>
<li>需要注意的是，全局静态对象在程序初始化时，则进行了初始化。局部静态对象的初始化在第一次进入函数内部时，才会调用对象的构造函数进行初始化。程序退出时，先释放静态局部变量，再释放全局静态变量</li>
</ul>
<h4 id="extern-C-的作用"><a href="#extern-C-的作用" class="headerlink" title="extern C 的作用"></a>extern C 的作用</h4><ul>
<li>C 和 C++ 对同一个函数经过编译后生成的函数名是不同的，由于 C++ 支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的函数名中，而不仅仅是原始的函数名。比如以下函数，同一个函数 test 在 C++ 编译后符号表中生成的函数名可能为 _Z4testv，而 C 编译后符号表中生成的函数名可能为 test</li>
<li>由于 C 语言并不支持函数重载，在 C 语言中函数不能重名，因此编译 C 语言代码的函数时不会带上函数的参数类型，一般只包括函数名。如果在 C++ 中调用一个使用 C 语言编写的模块中的某个函数 test，C++ 是根据 C++ 的函数名称修饰方式来查找并链接这个函数，去在生成的符号表查找 _Z4testv 这个函数的代码，此时就会发生链接错误。而此时我们用 extern C 声明，那么在链接时，C++ 编译器则按照 C 语言的函数命名规则 test 去符号表中查找对应的函数。因此当 C++ 程序需要调用 C 语言编写的函数，C++ 使用链接指示，即 e<strong>xtern “C” 指出任意非 C++ 函数所用的语言</strong></li>
</ul>
<h4 id="sizeof-1-x3D-x3D-1-在-C-和-C-中的结果"><a href="#sizeof-1-x3D-x3D-1-在-C-和-C-中的结果" class="headerlink" title="sizeof(1&#x3D;&#x3D;1) 在 C 和 C++ 中的结果"></a>sizeof(1&#x3D;&#x3D;1) 在 C 和 C++ 中的结果</h4><ul>
<li>sizeof 接受的参数可以是对象也可以是表达式，但是 sizeof(expression) 在运行时不会对接受的表达式进行计算，编译器只会推导表达式的类型从而计算占用的字节大小</li>
<li>由于 <code>C</code> 语言没有 <code>bool</code> 类型，用整形表示布尔型，因此sizeof(1&#x3D;&#x3D;1)返回 <code>4</code>;</li>
<li>由于 <code>C++</code> 语言有 <code>bool</code> 类型，布尔型占 <code>1</code> 个字节，因此sizeof(1&#x3D;&#x3D;1)返回 <code>1</code>;</li>
</ul>
<h4 id="memmove-函数的底层原理"><a href="#memmove-函数的底层原理" class="headerlink" title="memmove 函数的底层原理"></a>memmove 函数的底层原理</h4><ul>
<li><p>memmove 用于拷贝字节，如果目标区域和源区域有重叠的话，memmove 能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，但复制后源内容会被更改。但是当目标区域与源区域没有重叠则和 memcpy 函数功能相同。</p>
</li>
<li><p>实现 memmove 函数，在实现的时候需要特殊处理地址重叠的情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memmove</span><span class="params">(<span class="type">void</span> *dst, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *psrc;</span><br><span class="line">    <span class="type">char</span> *pdst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == dst || <span class="literal">NULL</span> == src)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((src &lt; dst) &amp;&amp; (<span class="type">char</span> *)src + size &gt; (<span class="type">char</span> *)dst) <span class="comment">// 出现地址重叠的情况，自后向前拷贝</span></span><br><span class="line">    &#123;</span><br><span class="line">        psrc = (<span class="type">char</span> *)src + size - <span class="number">1</span>;</span><br><span class="line">        pdst = (<span class="type">char</span> *)dst + size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (size--)</span><br><span class="line">        &#123;</span><br><span class="line">            *pdst-- = *psrc--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        psrc = (<span class="type">char</span> *)src;</span><br><span class="line">        pdst = (<span class="type">char</span> *)dst;</span><br><span class="line">        <span class="keyword">while</span> (size--)</span><br><span class="line">        &#123;</span><br><span class="line">            *pdst++ = *psrc++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="strcpy-函数的缺陷"><a href="#strcpy-函数的缺陷" class="headerlink" title="strcpy 函数的缺陷"></a>strcpy 函数的缺陷</h4><ul>
<li><p>strcpy 是 C++ 语言的一个标准函数 ，strcpy 把含有 ‘\0’ 结束符的字符串复制到另一个地址空间，返回值的类型为 char*，返回值为拷贝后的字符串的首地址。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">strcpy</span><span class="params">(<span class="type">char</span> * strDest,<span class="type">const</span> <span class="type">char</span> * strSrc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="literal">NULL</span>==strDest) || (<span class="literal">NULL</span>==strSrc)) </span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;Invalid argument(s)&quot;</span>; </span><br><span class="line">    <span class="type">char</span> * strDestCopy = strDest; </span><br><span class="line">    <span class="keyword">while</span> ((*strDest++=*strSrc++)!=<span class="string">&#x27;\0&#x27;</span>); </span><br><span class="line">    <span class="keyword">return</span> strDestCopy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>strcpy 函数的缺陷：strcpy 函数不检查目的缓冲区的大小边界，而是将源字符串逐一的全部赋值给目的字符串地址起始的一块连续的内存空间，同时加上字符串终止符，会导致其他变量被覆盖</p>
</li>
<li><p>由于 strcpy 函数存在一定的安全风险，如果使用不当容易出现安全问题，利用 strcpy 的特性可以编写 shellcode 来进行缓冲区溢出攻击。在大多数工程代码中，为了保证代码的健壮性和安全性，一般会使用 strncpy 代替 strcpy</p>
</li>
</ul>
<h4 id="auto-类型推导的原理"><a href="#auto-类型推导的原理" class="headerlink" title="auto 类型推导的原理"></a>auto 类型推导的原理</h4><ul>
<li><p>auto 是 C++ 语言的关键字。C++11 规定，auto 关键字用于两种情况：</p>
<ul>
<li>声明变量时根据初始化表达式自动推断该变量的类型；</li>
<li>声明函数时函数返回值的占位符；</li>
</ul>
</li>
<li><p>auto 声明变量时，根据初始化的表达式来推导该变量的类型，此时变量必须进行初始化。使用 auto 类型可以使变量定义变得更为简单，程序结构更为清晰一些</p>
</li>
<li><p>使用 auto 关键字做类型自动推导时，依次施加以下规则：</p>
<ul>
<li>首先，如果初始化表达式是引用，首先去除引用，如果 auto 类型关键字带上 &amp; 则不进行去除</li>
<li>其次，去掉剩下的初始化表达式顶层的 const 或 volatile 限定符。</li>
<li>C++ 14 以后如果用 {} 来进行赋值，此时 auto 类型推导出的类型为 std::initializer_list；而模板函数的形参推导时不认为这种值列表是一个类型，此时则不能推导出 std::initializer_list 类型</li>
</ul>
</li>
<li><p>auto 关键字的类型完美转发：</p>
<ul>
<li>C++11 使用 auto 声明变量时，如：auto&amp;&amp; var&#x3D;initValue;，则此时 “auto&amp;&amp;” <strong>并不意味着这一定是右值引用类型的变量，而是类似于模板函数参数的类型推导，既可能是左值引用，也可能是右值引用</strong>。其目的是把初始化表达式的值分类情况，完美转发给由 auto 声明的变量。</li>
<li>如果初始化值是类型 A 的左值，则声明的变量类型为左值引用 A&amp;；</li>
<li>如果初始化值是类型 A 的右值，则声明的变量类型为右值引用 A&amp;&amp;</li>
</ul>
</li>
</ul>
<h3 id="C-面向对象"><a href="#C-面向对象" class="headerlink" title="C++ 面向对象"></a>C++ 面向对象</h3><h4 id="面向对象及其三大特性"><a href="#面向对象及其三大特性" class="headerlink" title="面向对象及其三大特性"></a>面向对象及其三大特性</h4><ul>
<li>面向对象：对象是指具体的某一个事物，这些事物的抽象就是类，类中包含数据（成员变量）和动作（成员方法）。</li>
<li>面向对象的三大特性：<ul>
<li>封装：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。</li>
<li>继承：子类继承父类的特征和行为，子类有父类的非 private 方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被 final 关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。</li>
<li>多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。在 C++ 中多态一般是使用虚函数来实现的，使用基类指针调用函数方法时，如果该指针指向的是一个基类的对象，则调用的是基类的虚函数；如果该指针指向的是一个派生类的对象，则调用的是派生类的虚函数</li>
</ul>
</li>
</ul>
<h4 id="重载、重写、隐藏的区别"><a href="#重载、重写、隐藏的区别" class="headerlink" title="重载、重写、隐藏的区别"></a>重载、重写、隐藏的区别</h4><ul>
<li><p>函数重载: 重载是指同一可访问区内被声明几个具有不同参数列（参数的类型、个数、顺序）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。</p>
</li>
<li><p>函数隐藏：函数隐藏是指派生类的函数屏蔽了与其同名的基类函数，只要是与基类同名的成员函数，不管参数列表是否相同，基类函数都会被隐藏。</p>
</li>
<li><p>函数重写（覆盖）：函数覆盖是指派生类中存在重新定义的函数。函数名、参数列表、返回值类型都必须同基类中被重写的函数一致，只有函数体不同。派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有 virtual 修饰。</p>
</li>
<li><p>重写和重载的区别：</p>
<ul>
<li>范围区别：对于类中函数的重载或者重写而言，重载发生在同一个类的内部，重写发生在不同的类之间（子类和父类之间）。</li>
<li>参数区别：重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要和原函数相同，父类中被重写的函数需要有 virtual 修饰。</li>
<li>virtual 关键字：重写的函数基类中必须有 virtual 关键字的修饰，重载的函数可以有 virtual 关键字的修饰也可以没有。</li>
</ul>
</li>
<li><p>隐藏和重写，重载的区别：</p>
<ul>
<li>范围区别：隐藏与重载范围不同，隐藏发生在不同类中。</li>
<li>参数区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被 virtual 修饰，基类函数都是被隐藏，而不是重写。</li>
<li>利用重写可以实现多态，而隐藏不可以。如果使用基类指针 p 指向派生类对象，利用这个指针调用函数时，对于隐藏的函数，会根据指针的类型去调用函数；对于重写的函数，<strong>会根据指针所指对象的类型去调用函数</strong>。重写必须使用 virtual 关键字，此时会更改派生类虚函数表的表项。</li>
<li><strong>隐藏是发生在编译时，即在编译时由编译器实现隐藏</strong>，而<strong>重写一般发生运行时，即运行时会查找类的虚函数表，决定调用函数接口</strong></li>
</ul>
</li>
</ul>
<h4 id="多态及其实现方法"><a href="#多态及其实现方法" class="headerlink" title="多态及其实现方法"></a>多态及其实现方法</h4><ul>
<li><p>多态的概念：多态就是<strong>不同继承类的对象，对同一消息做出不同的响应</strong>，<strong>基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式</strong>。在基类的函数前加上 virtual 关键字，在派生类中重写该函数，<strong>运行时将会根据对象的实际类型来调用相应的函数</strong>。如果<strong>对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数</strong>。</p>
</li>
<li><p>多态的实现原理:</p>
<ul>
<li>多态是通过虚函数实现的，<strong>虚函数的地址保存在虚函数表中，虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中</strong>。</li>
<li>在类中用 <strong>virtual 关键字声明的函数叫做虚函数</strong>；</li>
<li><strong>存在虚函数的类都有一个虚函数表</strong>，当创建一个该类的对象时，<strong>该对象有一个指向虚函数表的虚表指针</strong>（虚函数表和类对应的，虚表指针是和对象对应）；</li>
<li>当基类指针指向派生类对象，基类指针调用虚函数时，该<strong>基类指针指的虚表指针实际指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数然后调用执行</strong></li>
</ul>
</li>
<li><p>多态的总结:</p>
<ul>
<li>虚函数的调用是在运行时决定，是由本身所指向的对象所决定的。</li>
<li>如果使用虚函数，基类指针指向派生类对象并调用对象方法时，使用的是子类的方法;</li>
<li>如果未使用虚函数，则是普通的隐藏，则基类指针指向派生类对象时，使用的是基类的方法（与指针类型看齐）</li>
<li>基类指针能指向派生类对象，但是派生类指针不能指向基类对象</li>
</ul>
</li>
</ul>
<h4 id="对象创建限制在堆或栈"><a href="#对象创建限制在堆或栈" class="headerlink" title="对象创建限制在堆或栈"></a>对象创建限制在堆或栈</h4><ul>
<li><p>C++ 中的类的对象的建立分为两种：静态建立、动态建立。</p>
</li>
<li><p>静态建立：由编译器为对象在栈空间上分配内存，直接调用类的构造函数创建对象。例如：A a;</p>
</li>
<li><p>动态建立：使用 new 关键字在堆空间上创建对象，底层首先调用 operator new() 函数，在堆空间上寻找合适的内存并分配；然后，调用类的构造函数创建对象。例如：A *p &#x3D; new A();</p>
</li>
<li><p>限制对象只能建立在堆上：</p>
<ul>
<li><p>最直观的思想：避免直接调用类的构造函数，因为对象静态建立时，会调用类的构造函数创建对象。但是直接将类的构造函数设为私有并不可行，因为当构造函数设置为私有后，不能在类的外部调用构造函数来构造对象，只能用 new 来建立对象。但是由于 new 创建对象时，底层也会调用类的构造函数，将构造函数设置为私有后，那就无法在类的外部使用 new 创建对象了。因此，这种方法不可行。</p>
</li>
<li><p>将析构函数设置为私有。原因：静态对象建立在栈上，是由编译器分配和释放内存空间，编译器为对象分配内存空间时，会对类的非静态函数进行检查，即编译器会检查析构函数的访问性。当析构函数设为私有时，编译器创建的对象就无法通过访问析构函数来释放对象的内存空间，因此，编译器不会在栈上为对象分配内存。</p>
<p>该方法存在的问题：用 new 创建的对象，通常会使用 delete 释放该对象的内存空间，但此时类的外部无法调用析构函数，因此类内必须定义一个 destroy() 函数，用来释放 new 创建的对象。无法解决继承问题，因为如果这个类作为基类，析构函数要设置成 virtual，然后在派生类中重写该函数，来实现多态。但此时，析构函数是私有的，派生类中无法访问。</p>
</li>
<li><p>构造函数设置为 protected，并提供一个 public 的静态函数来完成构造，而不是在类的外部使用 new 构造；将析构函数设置为 protected。原因：类似于单例模式，也保证了在派生类中能够访问析构函数。通过调用 create() 函数在堆上创建对象。</p>
</li>
</ul>
</li>
<li><p>限制对象只能建立在栈上：将 operator new() 设置为私有。</p>
<ul>
<li>原因：当对象建立在堆上时，是采用 new 的方式进行建立，其底层会调用 operator new() 函数，因此只要对该函数加以限制，就能够防止对象建立在堆上</li>
</ul>
</li>
</ul>
<h4 id="C-模板编程"><a href="#C-模板编程" class="headerlink" title="C++ 模板编程"></a>C++ 模板编程</h4><ul>
<li><p>模板是 C++ 编程语言的一个特性，它允许函数和类使用泛型类型进行操作。这允许一个函数或类在许多不同的数据类型上工作，而无需为每个类型重写。C++ 模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码，C++ 中使用 template 关键字。模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。共有三种模板：函数模板、类模板以及自 C++ 14 以来的变量模板</p>
</li>
<li><p>函数模板:函数模板的行为类似于函数，只是模板可以有许多不同类型的参数。一个函数模板代表一个函数族。使用类型参数声明函数模板的格式是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">identifier</span>&gt; declaration;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> identifier&gt; declaration;</span><br></pre></td></tr></table></figure>

<p>除了限制对一个函数描述的更改并使代码更易于阅读之外，函数模板的使用减少了源代码的编写，与为特定程序中使用的所有不同数据类型编写单独的函数相比，模板不会产生更小的目标代码，实际编译器在编译时，会为根据不同的类型编译产生不同的函数</p>
</li>
<li><p>类模板：类模板提供了基于参数生成类的规范。类模板通常用于实现容器。类模板通过将一组给定的类型作为模板参数传递给它来实例化。C++ 标准库包含许多类模板，特别是改编自标准模板库的容器，例如 vector，list。</p>
</li>
<li><p>变量模板：在 <code>C++14</code> 以后，变量也可以参数化为特定的类型，这称为变量模板。使用变量模板时，必须显式地指定它的类型</p>
</li>
<li><p>函数重载与模板的区别: 函数重载和模板都是面向对象多态特性的例子。当多个函数执行非常相似（不相同）的操作时使用函数重载，当多个函数执行相同操作时使用模板。当模板类或者模板函数中含有静态变量时，则每个模板的实例类型都含有一个静态成员。</p>
</li>
</ul>
<h4 id="虚函数和纯虚函数详解"><a href="#虚函数和纯虚函数详解" class="headerlink" title="虚函数和纯虚函数详解"></a>虚函数和纯虚函数详解</h4><ul>
<li>虚函数：被 <code>virtual</code> 关键字修饰的成员函数，<code>C++</code> 的虚函数在运行时动态绑定，从而实现多态</li>
<li>纯虚函数：纯虚函数在类中声明时，用 virtual 关键字修饰且加上 &#x3D;0，且没有函数的具体实现；含有纯虚函数的类称为抽象类（只要含有纯虚函数这个类就是抽象类），类中只有接口定义，没有具体的实现方法；继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，不能实例化对象。</li>
<li>对于抽象类需要说明的是:<ul>
<li>抽象类对象不能作为函数的参数，不能创建对象，不能作为函数返回类型；</li>
<li>可以声明抽象类指针，可以声明抽象类的引用；</li>
<li>抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。</li>
</ul>
</li>
<li>纯虚函数的作用：含有纯虚函数的基类要求任何派生类都要定义自己的实现方法，以实现多态性。实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数。定义纯虚函数是为了实现统一的接口属性，用来规范派生类的接口属性，也即强制要求继承这个类的程序员必须实现这个函数。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以要求实现纯虚函数的属性，在面对对象设计中非常有用的一个特性</li>
</ul>
<h4 id="虚函数和纯虚函数的区别"><a href="#虚函数和纯虚函数的区别" class="headerlink" title="虚函数和纯虚函数的区别"></a>虚函数和纯虚函数的区别</h4><ul>
<li>虚函数和纯虚函数可以出现在同一个类中，该类称为抽象基类（含有纯虚函数的类称为抽象基类）</li>
<li>使用方式不同：虚函数可以直接使用，纯虚函数必须在派生类中实现后才能使用；</li>
<li>定义形式不同：虚函数在定义时在普通函数的基础上加上 virtual 关键字，纯虚函数定义时除了加上 virtual 关键字还需要加上 &#x3D;0;</li>
<li>虚函数必须实现，否则编译器会报错；</li>
<li>对于实现纯虚函数的派生类，该纯虚函数在派生类中被称为虚函数，虚函数和纯虚函数都可以在派生类中重写；</li>
<li>析构函数最好定义为虚函数，特别是对于含有继承关系的类；析构函数可以定义为纯虚函数，此时，其所在的类为抽象基类，不能创建实例化对象</li>
</ul>
<h4 id="虚函数的实现机制"><a href="#虚函数的实现机制" class="headerlink" title="虚函数的实现机制"></a>虚函数的实现机制</h4><ul>
<li><p>虚函数的实现原理:</p>
<ul>
<li>实现机制：虚函数通过虚函数表来实现。虚函数的地址保存在虚函数表中，在类的对象所在的内存空间中，保存了指向虚函数表的指针（称为“虚表指针”），通过虚表指针可以找到类对应的虚函数表。虚函数表解决了基类和派生类的继承问题和类中成员函数的覆盖问题，当用基类的指针来操作一个派生类的时候，这张虚函数表就指明了实际应该调用的函数。</li>
<li>每个使用虚函数的类（或者从使用虚函数的类派生）都有自己的虚函数表。该表是编译器在编译时设置的静态数组，一般称为 vtable。虚函数表包含可由该类调用的虚函数，此表中的每个条目是一个函数指针，指向该类可访问的虚函数。</li>
<li>每个对象在创建时，编译器会为对象生成一个指向该类的虚函数表的指针，称为 vptr。vptr 在创建类实例时自动设置，以便指向该类的虚拟表。如果对象（或者父类）中含有虚函数，则编译器一定会为其分配一个 vptr；如果对象不包含（父类也不含有），此时编译器则不会为其分配 vptr。与 this 指针不同，this 指针实际上是编译器用来解析自引用的函数参数，vptr 是一个真正的指针。</li>
</ul>
</li>
<li><p>虚函数表相关知识点：</p>
<ul>
<li>虚函数表存放的内容：类的虚函数的地址。</li>
<li>虚函数表建立的时间：编译阶段，即程序的编译过程中会将虚函数的地址放在虚函数表中。</li>
<li>虚表指针保存的位置：虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量。</li>
<li><strong>虚函数表和类绑定，虚表指针和对象绑定</strong>。即<strong>类的不同的对象的虚函数表是一样的，但是每个对象在创建时都有自己的虚表指针 vptr</strong>，来指向类的虚函数表 vtable</li>
</ul>
</li>
<li><p>虚拟函数表指针 vptr:</p>
<ul>
<li>带有虚函数的类，通过该类所隐含的虚函数表来实现多态机制，该类的每个对象均具有一个指向本类虚函数表的指针，这一点并非 C++ 标准所要求的，而是编译器所采用的内部处理方式。实际应用场景下，不同平台、不同编译器厂商所生成的虚表指针在内存中的布局是不同的，有些将虚表指针置于对象内存中的开头处，有些则置于结尾处。如果涉及多重继承和虚继承，情况还将更加复杂。因此永远不要使用 C 语言的方式调用 memcpy() 之类的函数复制对象，而应该使用初始化（构造和拷构）或赋值的方式来复制对象。</li>
</ul>
</li>
<li><p>虚函数的使用场景:</p>
<ul>
<li>构造函数不能为虚函数：构造函数不能定义为虚函数。构造函数是在实例化对象的时候进行调用，如果此时将构造函数定义成虚函数，需要通过访问该对象所在的内存空间才能进行虚函数的调用（<strong>因为需要通过指向虚函数表的指针调用虚函数表，虽然虚函数表在编译时就有了，但是没有虚函数的指针，虚函数的指针只有在创建了对象才有</strong>），但是此时该对象还未创建，便无法进行虚函数的调用。所以构造函数不能定义成虚函数。</li>
<li>析构函数为虚函数：一般建议析构函数定义成虚函数，这样做可以有效是<strong>防止内存泄漏</strong>，实际应用时当基类的指针或者引用指向或绑定到派生类的对象时，<strong>如果未将基类的析构函数定义成虚函数，当我们对基类指针执行 delete 操作时，此时只会调用基类的析构函数</strong>，将基类的成员所占的空间释放掉，而派生类中特有的资源就会无法释放而导致内存泄漏。</li>
<li>static 函数不能定义为虚函数</li>
</ul>
</li>
</ul>
<h4 id="单继承和多继承的虚函数表结构"><a href="#单继承和多继承的虚函数表结构" class="headerlink" title="单继承和多继承的虚函数表结构"></a>单继承和多继承的虚函数表结构</h4><ul>
<li>编译器将虚函数表的指针放在类的实例对象的内存空间中，该对象调用该类的虚函数时，通过指针找到虚函数表，根据虚函数表中存放的虚函数的地址找到对应的虚函数。</li>
<li>如果派生类没有重新定义基类的虚函数 A，则派生类的虚函数表中保存的是基类的虚函数 A 的地址，也就是说基类和派生类的虚函数 A 的地址是一样的。</li>
<li>如果派生类重写了基类的某个虚函数 B，则派生的虚函数表中保存的是重写后的虚函数 B 的地址，也就是说<strong>虚函数 B 有两个版本，分别存放在基类和派生类的虚函数表中</strong>。</li>
<li>如果派生类重新定义了新的虚函数 C，派生类的虚函数表保存新的虚函数 C 的地址。</li>
</ul>
<h4 id="如何禁止构造函数的使用"><a href="#如何禁止构造函数的使用" class="headerlink" title="如何禁止构造函数的使用"></a>如何禁止构造函数的使用</h4><ul>
<li>为类的构造函数增加 <code>= delete</code> 修饰符，可以达到虽然声明了构造函数但禁止使用的目的。</li>
<li>如果仅仅将构造函数设置为私有，类内部的成员和友元还可以访问，无法完全禁止。而在 C++11 以后，在成员函数声明后加 “&#x3D; delete”则可以禁止该函数的使用，而需要保留的加 “&#x3D; default”。</li>
</ul>
<h4 id="什么是类的默认构造函数"><a href="#什么是类的默认构造函数" class="headerlink" title="什么是类的默认构造函数"></a>什么是类的默认构造函数</h4><ul>
<li>默认构造函数（default constructor）就是在没有显式提供初始化式时调用的构造函数。它由不带参数的构造函数，或者为所有的形参提供默认实参的构造函数定义。如果定义某个类的变量时没有提供初始化时就会使用默认构造函数。</li>
<li>用户定义的默认构造函数：<ul>
<li>用户自定义的不带参数的构造函数，未提供任何实参，程序运行时会调用默认的构造函数。</li>
<li>用户自定义的构造函数，但为所有形参提供默认值的构造函数，程序运行时会调用所有形参提供默认值的构造函数。</li>
</ul>
</li>
<li>编译器自动分配的合成默认构造函数<ul>
<li>如果用户定义的类中没有显式的定义任何构造函数，编译器就会自动为该类型生成默认构造函数，称为合成的默认构造函数。</li>
<li>一般情况下，如果类中包含内置或复合类型的成员，则该类就不应该依赖于合成的默认构造函数，它应该定义自己的构造函数来初始化这些成员。</li>
<li>多数情况下，编译器为类生成一个公有的默认构造函数，只有下面两种情况例外:<ul>
<li>一个类显式地声明了任何构造函数，编译器不生成公有的默认构造函数。在这种情况下，如果程序需要一个默认构造函数，需要由类的设计者提供。</li>
<li>一个类声明了一个非公有的默认构造函数，编译器不会生成公有的默认构造函数。</li>
</ul>
</li>
<li>在大多数情况下，C++ 编译器为未声明构造函数之 class 合成一个默认构造函数：<ul>
<li>如果该类没有任何构造函数，但是包含一个对象类型的成员变量，且该变量有一个显式的默认构造函数；</li>
<li>如果该类没有任何构造函数，但是其父类含有显式的默认构造函数；</li>
<li>如果该类没有任何构造函数，但是含有（或父类含有）虚函数；</li>
<li>如果该类没有任何构造函数，但是带有一个虚基类；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="构造函数、析构函数是否可以定义成虚函数"><a href="#构造函数、析构函数是否可以定义成虚函数" class="headerlink" title="构造函数、析构函数是否可以定义成虚函数"></a>构造函数、析构函数是否可以定义成虚函数</h4><ul>
<li>构造函数一般不定义为虚函数:<ul>
<li>从存储空间的角度考虑：构造函数是在实例化对象的时候进行调用，如果此时将构造函数定义成虚函数，需要通过访问该对象所在的内存空间才能进行虚函数的调用（因为需要通过指向虚函数表的指针调用虚函数表，虽然虚函数表在编译时就有了，但是没有虚函数的指针，虚函数的指针只有在创建了对象才有），但是此时该对象还未创建，便无法进行虚函数的调用。所以构造函数不能定义成虚函数。</li>
<li>从使用的角度考虑：虚函数是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数的调用，构造函数是在创建对象时自动调用的。</li>
<li>从实现上考虑：虚函数表是在创建对象之后才有的，因此不能定义成虚函数。</li>
<li>从类型上考虑：在创建对象时需要明确其类型。</li>
</ul>
</li>
<li>析构函数一般定义成虚函数：<ul>
<li>析构函数定义成虚函数是为了防止内存泄漏，因为当基类的指针或者引用指向或绑定到派生类的对象时，如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏。</li>
</ul>
</li>
</ul>
<h4 id="如何避免拷贝"><a href="#如何避免拷贝" class="headerlink" title="如何避免拷贝"></a>如何避免拷贝</h4><ul>
<li>最直观的想法是：将类的拷贝构造函数和赋值运算符重载声明为私有 private，但对于类的成员函数和友元函数依然可以调用，达不到完全禁止类的对象被拷贝的目的，而且程序会出现错误，因为未对函数进行定义。</li>
<li>声明一个基类，具体做法如下：<ul>
<li>定义一个基类，将其中的拷贝构造函数和赋值运算符重载声明为私有 private。</li>
<li>派生类以私有 private 的方式继承基类。</li>
</ul>
</li>
<li>拷贝构造函数 <code>=delete</code> 修饰:<code>C++ 11</code> 支持 <code>delete</code> 直接禁用类的成员函数调用。</li>
</ul>
<h4 id="如何减少构造函数开销"><a href="#如何减少构造函数开销" class="headerlink" title="如何减少构造函数开销"></a>如何减少构造函数开销</h4><ul>
<li>在构造函数时尽量使用类初始化列表，会减少调用默认的构造函数产生的开销</li>
</ul>
<h4 id="多重继承的常见问题及避免方法"><a href="#多重继承的常见问题及避免方法" class="headerlink" title="多重继承的常见问题及避免方法"></a>多重继承的常见问题及避免方法</h4><ul>
<li><p>多重继承（多继承）：是指从多个直接基类中产生派生类。多重继承容易出现命名冲突和数据冗余问题。</p>
<ul>
<li>对于派生类 Derive 上述代码中存在直接继承关系和间接继承关系。<ul>
<li>直接继承：Base2 、Base3</li>
<li>间接继承：Base1</li>
<li>对于派生类中继承的的成员变量 var1 ，从继承关系来看，实际上保存了两份，一份是来自基类 Base2，一份来自基类 Base3。因此，出现了命名冲突</li>
</ul>
</li>
</ul>
</li>
<li><p>解决方法：</p>
<ul>
<li>显式声明出现冲突的成员变量来源于哪个类。</li>
<li>虚继承</li>
</ul>
</li>
<li><p>由于使用多重继承很容易出现二义性的问题，将使得程序调试和维护工作变得非常复杂，C++ 之后的很多面向对象的编程语言，例如 Java、C#、PHP 等，都不支持多继承</p>
</li>
</ul>
<h4 id="空类字节数及对应生成的成员函数"><a href="#空类字节数及对应生成的成员函数" class="headerlink" title="空类字节数及对应生成的成员函数"></a>空类字节数及对应生成的成员函数</h4><ul>
<li>对于空类，<strong>声明编译器不会生成任何的成员函数</strong>，<strong>只会生成 1 个字节的占位符</strong>。由于在实际程序中，空类同样可以被实例化，而每个实例在内存中都有一个独一无二的地址，为了达到这个目的，编译器往往会给一个空类隐含的加一个字节，这样空类在实例化后在内存得到了独一无二的地址，所以 sizeof(A) 的大小为 1。</li>
<li>空类定义时编译器会生成 6 个成员函数：当空类 A 定义对象时，sizeof(A) 仍是为 1，但<strong>编译器会在需要时生成 6 个成员函数：缺省的构造函数、拷贝构造函数、析构函数、赋值运算符、两个取址运算符</strong>。</li>
</ul>
<h4 id="类的大小"><a href="#类的大小" class="headerlink" title="类的大小"></a>类的大小</h4><ul>
<li>类的大小是指类的实例化对象的大小，用 sizeof 对类型名操作时，结果是该类型的对象的大小。计算原则如下：<ul>
<li>遵循结构体的成员变量对齐原则。</li>
<li>与普通成员变量有关，与成员函数和静态成员无关。即普通成员函数，静态成员函数，静态数据成员，静态常量数据成员均对类的大小无影响。因为静态数据成员被类的对象共享，并不属于哪个具体的对象。</li>
<li>虚函数对类的大小有影响，是因为虚函数表指针的影响；虚函数的个数并不影响所占内存的大小，因为类对象的内存中只保存了指向虚函数表的指针。</li>
<li>不包含虚继承的情况，派生类直接继承了基类的成员变量；虚继承的情况就比较复杂，虚继承需要额外加上一个指向虚基类表的指针。虚继承的基础上如果再加上虚函数，还需要额外加上虚函数表的指针占用的空间</li>
<li>空类的大小是一个特殊情况，空类的大小为 1，空类同样可以被实例化，而每个实例在内存中</li>
<li>都有一个独一无二的地址，为了达到这个目的，编译器往往会给一个空类隐含的加一个字节，这样空类在实例化后在内存得到了独一无二的地址，所以sizeof(A) 的大小为 1。<br>简单情况和空类情况:</li>
</ul>
</li>
</ul>
<h4 id="为什么拷贝构造函数必须声明为引用"><a href="#为什么拷贝构造函数必须声明为引用" class="headerlink" title="为什么拷贝构造函数必须声明为引用"></a>为什么拷贝构造函数必须声明为引用</h4><ul>
<li><p>避免拷贝构造函数无限制的递归而导致栈溢出。</p>
</li>
<li><p>说明 1：ex2 &#x3D; ex1; 和 A ex3 &#x3D; ex1; 为什么调用的函数不一样？</p>
<ul>
<li>对象 ex2 已经实例化了，不需要构造，此时只是将 ex1 赋值给 ex2，只会调用赋值运算符的重载；但是 <strong>ex3 还没有实例化，因此调用的是拷贝构造函数</strong>，构造出 ex3，而不是赋值函数，这里涉及到构造函数的隐式调用。</li>
</ul>
</li>
<li><p>说明 2：如果拷贝构造函数中形参不是引用类型，A ex3 &#x3D; ex1; 会出现什么问题？</p>
<ul>
<li>构造 ex3，实质上是 ex3.A(ex1);，假如拷贝构造函数参数不是引用类型，那么将使得 ex3.A(ex1); 相当于 ex1 作为函数 A(const A tmp) 的实参，在参数传递时相当于 A tmp &#x3D; ex1，因为 tmp 没有被初始化，所以在 A tmp &#x3D; ex1 中继续调用拷贝构造函数，接下来的是构造 tmp，也就是 tmp.A(ex1) ，必然又会有 ex1 作为函数 A(const A tmp); 的实参，在参数传递时相当于即 A tmp &#x3D; ex1，那么又会触发拷贝构造函数，就这下永远的递归下去</li>
</ul>
</li>
<li><p>说明 3：为什么 ex2.fun(ex1); 会调用拷贝构造函数？</p>
<ul>
<li>ex1 作为参数传递给 fun 函数， 即 A tmp &#x3D; ex1;，这个过程会调用拷贝构造函数进行初始化</li>
</ul>
</li>
<li><p>什么情况下会调用拷贝构造函数：</p>
<ul>
<li>直接初始化和拷贝初始化时</li>
<li>将一个对象作为实参传递给一个非引用或非指针类型的形参时</li>
<li>从一个返回类型为非引用或非指针的函数返回一个对象时</li>
<li>用花括号列表初始化一个数组的元素或者一个聚合类（很少使用）中的成员时。</li>
</ul>
</li>
<li><p>何时调用复制构造函数：新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用</p>
</li>
</ul>
<h4 id="C-类对象的初始化顺序"><a href="#C-类对象的初始化顺序" class="headerlink" title="C++ 类对象的初始化顺序"></a>C++ 类对象的初始化顺序</h4><ul>
<li><p>构造函数调用顺序：</p>
<ul>
<li>按照<strong>派生类继承基类的顺序</strong>，即派生列表中声明的继承顺序，依次调用基类的构造函数；</li>
<li>在有虚继承和一般继承存在的情况下，<strong>优先虚继承</strong>。比如虚继承：class C: public B, virtual public A，此时应当先调用 A 的构造函数，再调用 B 的构造函数。</li>
<li>按照派生类中<strong>成员变量的声明顺序，依次调用派生类中成员变量所属类的构造函数</strong>；</li>
<li>执行派生类自身的构造函数。</li>
</ul>
</li>
<li><p>类对象的初始化顺序：</p>
<ul>
<li>按照构造函数的调用顺序，调用基类的构造函数</li>
<li>按照成员变量的声明顺序，调用成员变量的构造函数函数，成员变量的初始化顺序与声明顺序有关；</li>
<li>调用该类自身的构造函数；</li>
<li>析构顺序和类对象的初始化顺序相反</li>
</ul>
</li>
<li><p>类的成员初始化:</p>
<ul>
<li>类中可能含有静态变量和全局变量，由于静态变量和全局变量都被放在静态存储区，他们的<strong>初始化在 main 函数执行之前已被初始化，且 static 变量必须在类外进行初始化</strong>。</li>
<li>成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，<strong>只与定义成员变量的顺序有关。</strong>因为成员变量的初始化次序是根据变量在内存中次序有关，而内存中的排列顺序早在编译期就根据变量的定义次序决定了。</li>
<li>如果类不使用初始化列表初始化，而<strong>在类的构造函数内部进行初始化时，此时成员变量的初始化顺序与构造函数中代码逻辑有关</strong>。</li>
<li>类<strong>成员在定义时，是不能初始化的</strong></li>
<li>类中 <strong>const 成员常量必须在构造函数初始化列表中初始化</strong>。</li>
<li>类中 <strong>static 成员变量，必须在类外初始化</strong></li>
</ul>
</li>
</ul>
<h4 id="如何禁止一个类被实例化"><a href="#如何禁止一个类被实例化" class="headerlink" title="如何禁止一个类被实例化"></a>如何禁止一个类被实例化</h4><ul>
<li>在类中定义一个纯虚函数，使该类成为抽象基类，因为不能创建抽象基类的实例化对象；</li>
<li>将类的所有构造函数声明为私有 <code>private</code>；</li>
<li><code>C++ 11</code> 以后，将类的所有构造函数用 <code>=delete</code> 修饰；</li>
</ul>
<h4 id="成员初始化列表效率高的原因"><a href="#成员初始化列表效率高的原因" class="headerlink" title="成员初始化列表效率高的原因"></a>成员初始化列表效率高的原因</h4><ul>
<li>对象的成员函数数据类型可分为语言内置类型和用户自定义类，对于用户自定义类型，利用成员初始化列表效率高。用户自定义类型如果使用类初始化列表，直接调用该成员变量对应的构造函数即完成初始化；如果在构造函数中初始化，由于 C++ 规定对象的成员变量的初始化动作发生在进入自身的构造函数本体之前，那么在执行构造函数之前首先调用默认的构造函数为成员变量设初值，在进入函数体之后，再显式调用该成员变量对应的构造函数。因此使用列表初始化会减少调用默认的构造函数的过程，效率更高一些。</li>
<li>使用成员列表初始化的方式会省去调用默认的构造函数的过程。如果自定义的类型没有默认构造函数，此时必须使用初始化列表提供初值对这些类型进行初始化。</li>
</ul>
<h4 id="实例化一个对象需要哪几个阶段"><a href="#实例化一个对象需要哪几个阶段" class="headerlink" title="实例化一个对象需要哪几个阶段"></a>实例化一个对象需要哪几个阶段</h4><ul>
<li>分配空间：创建类对象首先要为该对象分配内存空间。不同的对象，为其分配空间的时机未必相同。全局对象、静态对象、分配在栈区域内的对象，在编译阶段进行内存分配；存储在堆空间的对象，是在运行阶段进行内存分配。</li>
<li>初始化：初始化不同于赋值。初始化发生在赋值之前，初始化随对象的创建而进行，而赋值是在对象创建好后，为其赋上相应的值。初始化列表先于构造函数体内的代码执行，初始化列表执行的是数据成员的初始化过程，这个可以从成员对象的构造函数被调用看的出来。</li>
<li>赋值：对象初始化完成后，可以对其进行赋值。对于一个类的对象，其成员变量的赋值过程发生在类的构造函数的函数体中。当执行完该函数体，也就意味着类对象的实例化过程完成了。<ul>
<li>构造函数实现了对象的初始化和赋值两个过程，对象的初始化是通过初始化列表来完成，而对象的赋值则才是通过构造函数的函数体来实现。</li>
<li>对于拥有虚函数的类的对象，还需要给虚表指针赋值。</li>
<li>没有继承关系的类，分配完内存后，首先给虚表指针赋值，然后再列表初始化以及执行构造函数的函数体，即上述中的初始化和赋值操作。</li>
<li>有继承关系的类，分配内存之后，首先进行基类的构造过程，然后给该派生类的虚表指针赋值，最后再列表初始化以及执行构造函数的函数体，即上述中的初始化和赋值操作。</li>
</ul>
</li>
</ul>
<h4 id="友元函数的作用及使用场景"><a href="#友元函数的作用及使用场景" class="headerlink" title="友元函数的作用及使用场景"></a>友元函数的作用及使用场景</h4><ul>
<li>友元函数的作用：友元（friend）提供了不同类的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制。通过友元，一个普通的函数或另一个类中的成员函数可以访问类中的私有成员和保护成员。</li>
<li><strong>使用场景</strong>：<ul>
<li>普通函数定义为类的友元函数，使得普通函数能够访问该类的私有成员和保护成员。</li>
<li>友元类：由于类的 private 和 protected 成员变量只能由类的成员函数访问或者派生类访问，友元类则提供提供一种通用的方法，使得不同类之间可以访问其 private 和 protected 成员变量，用于不同类之间共享数据。</li>
</ul>
</li>
</ul>
<h4 id="静态绑定和动态绑定的实现"><a href="#静态绑定和动态绑定的实现" class="headerlink" title="静态绑定和动态绑定的实现"></a>静态绑定和动态绑定的实现</h4><ul>
<li><p>静态类型和动态类型：</p>
<ul>
<li>静态类型：变量在声明时的类型，是在编译阶段确定的。静态类型不能更改。</li>
<li>动态类型：目前所指对象的类型，是在运行阶段确定的。动态类型可以更改。</li>
</ul>
</li>
<li><p>静态绑定和动态绑定：</p>
<ul>
<li>静态绑定是指程序在编译阶段确定对象的类型（静态类型）。</li>
<li>动态绑定是指程序在运行阶段确定对象的类型（动态类型）。</li>
</ul>
</li>
<li><p>静态绑定和动态绑定的区别：</p>
<ul>
<li>发生的时期不同。</li>
<li>对象的静态类型不能更改，动态类型可以更改。</li>
<li>对于类的成员函数，只有虚函数是动态绑定，其他都是静态绑定。</li>
</ul>
</li>
<li><p>类的内存占用由成员变量和指向虚函数表的指针组成，同时派生类的成员变量是会把基类的成员变量都继承的</p>
</li>
<li><p>同名虚函数在基类和派生类中的虚函数表中，在虚函数表中偏移位置是一致的。同样名称的虚函数，在基类中定义的虚函数与派生类中定义的虚函数，在虚函数表中的偏移量都是一致的，只有这样才能保证动态绑定。</p>
</li>
<li><p>如果派生类中定义了与基类同名的虚函数，那么派生类的虚函数表中响应函数的入口地址会被替换成覆盖后的函数的地址。</p>
</li>
<li><p>一旦有新的虚函数定义，会加入到当前虚函数表的末端。</p>
</li>
<li><p>派生类的成员变量顺序也按照声明的顺序依次在内存中分配。</p>
</li>
<li><p>动态绑定的实现：</p>
<ul>
<li>当我们用虚函数表指针去查找虚函数表中对应的函数的地址时，此时首先会找到函数地址的在虚函数表中的索引，这里 display 索引是 0。</li>
<li>然后编译器会做一个替换，（*(p-&gt;vptr)[0]），找到 p 指针的函数入口地址。</li>
<li>程序运行后会执行这条语句 <code>*(p-&gt;vptr)[0]()</code>，完成函数的调用，实际即完成了动态绑定。</li>
</ul>
</li>
</ul>
<h4 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a>深拷贝和浅拷贝的区别</h4><ul>
<li>如果一个类拥有资源，该类的对象进行复制时，如果资源重新分配，就是深拷贝，否则就是浅拷贝。<ul>
<li>深拷贝：该对象和原对象占用不同的内存空间，既拷贝存储在栈空间中的内容，又拷贝存储在堆空间中的内容。</li>
<li>浅拷贝：该对象和原对象占用同一块内存空间，仅拷贝类中位于栈空间中的内容。</li>
</ul>
</li>
<li>当类的成员变量中有指针变量时，最好使用深拷贝。因为当两个对象指向同一块内存空间，如果使用浅拷贝，当其中一个对象的删除后，该块内存空间就会被释放，另外一个对象指向的就是垃圾内存</li>
<li>编译器生成的默认拷贝函数均大部分都是浅拷贝，所有在特定场景下需要禁止编译器生成默认拷贝构造函数。在遇到需要使用堆内存的构造函数中，我们需要特别注意浅拷贝和深拷贝的使用方式，防止两个不同的对象指向同一块内存区域</li>
</ul>
<h4 id="编译时多态和运行时多态的区别"><a href="#编译时多态和运行时多态的区别" class="headerlink" title="编译时多态和运行时多态的区别"></a>编译时多态和运行时多态的区别</h4><ul>
<li>编译时多态：在程序编译过程中出现，发生在模板和函数重载中（泛型编程）。实际在编译器内部看来不管是重载还是模板，编译器内部都会生成不同的函数，在代码段中分别装有两个函数的不同实现。</li>
<li>运行时多态：运行时多态也称动态绑定，在程序运行过程中出现，发生在继承体系中，是指通过基类的指针或引用访问派生类中的虚函数。</li>
<li>编译时多态和运行时多态的区别：<ul>
<li>时期不同：编译时多态发生在程序编译过程中，运行时多态发生在程序的运行过程中；</li>
<li>实现方式不同：编译时多态运用泛型编程来实现，运行时多态借助虚函数表来实现</li>
</ul>
</li>
</ul>
<h4 id="不允许修改类的成员变量的函数实现方法"><a href="#不允许修改类的成员变量的函数实现方法" class="headerlink" title="不允许修改类的成员变量的函数实现方法"></a>不允许修改类的成员变量的函数实现方法</h4><ul>
<li>如果想达到一个类的成员函数不能修改类的成员变量，只需用 const 关键字来修饰该函数即可。</li>
<li>同时 C++ 还存在与 const 相反的关键字 mutable。被 mutable 修饰的变量，将永远处于可变的状态，即使在一个 const 函数中。如果我们需要在 const 函数中修改类的某些成员变量，这时就需要用到 mutable。</li>
<li>使用 mutable 的注意事项：<ul>
<li>mutable 只能作用于类的非静态和非常量数据成员。</li>
<li>在一个类中，应尽量避免大量使用 mutable，大量使用 mutable 表示程序设计存在缺陷</li>
</ul>
</li>
</ul>
<h4 id="如何让类不能被继承"><a href="#如何让类不能被继承" class="headerlink" title="如何让类不能被继承"></a>如何让类不能被继承</h4><ul>
<li><p>使用 <code>final</code> 关键字: 使用 <code>final</code> 关键字修饰的类不能被继承。</p>
</li>
<li><p>使用友元、虚继承和私有构造函数来实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="keyword">friend</span> T;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Base</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Base</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> Base&lt;B&gt;&#123;   <span class="comment">//一定注意 必须是虚继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:<span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>()&#123;&#125;     <span class="comment">// error: &#x27;Base&lt;T&gt;::Base() [with T = B]&#x27; is private within this context</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>虽然 Base 类构造函数和析构函数被声明为私有 private，在 B 类中，由于 B 是 Base 的友元，因此可以访问 Base 类构造函数，从而正常创建 B 类的对象；</li>
<li>B 类继承 Base 类采用虚继承的方式，创建 C 类的对象时，C 类的构造函数要负责 Base 类的构造，但是 Base 类的构造函数私有化了，C 类没有权限访问。因此，无法创建 C 类的对象， B 类是不能被继承的类。</li>
<li>注意：在继承体系中，友元关系不能被继承，虽然 C 类继承了 B 类，B 类是 Base 类的友元，但是 C 类和 Base 类没有友元关系。</li>
</ul>
</li>
</ul>
<h3 id="C-语言特性相关"><a href="#C-语言特性相关" class="headerlink" title="C++ 语言特性相关"></a>C++ 语言特性相关</h3><h4 id="左值和右值：区别、引用及转化"><a href="#左值和右值：区别、引用及转化" class="headerlink" title="左值和右值：区别、引用及转化"></a>左值和右值：区别、引用及转化</h4><ul>
<li><p>左值与右值:</p>
<ul>
<li>左值：指表达式结束后依然存在的持久对象。可以取地址，可以通过内置（不包含重载） &amp; 来获取地址，我们可以将一个右值赋给左值。</li>
<li>右值：表达式结束就不再存在的临时对象。不可取地址，不可以通过内置（不包含重载） &amp; 来获取地址。由于右值不可取地址，因此我们不能将任何值赋给右值。</li>
<li>使用 &#x3D; 进行赋值时，&#x3D; 的左边必须为左值，右值只能出现在 &#x3D; 的右边。</li>
<li>函数返回值即可以是左值，也可以是右值</li>
</ul>
</li>
<li><p>左值引用和右值引用：</p>
<ul>
<li>左值引用：	<ul>
<li>左值引用可以区分为常量左值引用和非常量左值引用。左值引用的底层实现是指针实现。</li>
<li>非常量左值引用只能绑定到非常量左值，不能绑定到常量左值和右值。如果绑定到非常量右值，就有可能指向一个已经被销毁的对象。</li>
<li>常量左值引用能绑定到非常量左值，常量左值和右值；</li>
<li>如果函数的形参定义为非常量的左值引用，则会出现错误，因为此时我们将一个左值引用绑定到右值上</li>
<li>如果函数的形参定义为常量的左值引用，则可以正常运行，因为此时我们将一个常量左值引用绑定到一个右值上</li>
</ul>
</li>
<li>右值引用：<ul>
<li>右值引用 （Rvalue Referene） 是 C++ 11 中引入的新特性 , 它实现了转移语义 （Move Sementics）和精确传递 （Perfect Forwarding），&amp;&amp; 作为右值引用的声明符。右值引用必须绑定到右值的引用，通过 &amp;&amp; 获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。</li>
<li>从实践角度讲，它能够完美解决 C++ 中长久以来为人所诟病的临时对象效率问题。从语言本身讲，它健全了 C++ 中的引用类型在左值右值方面的缺陷。从库设计者的角度讲，它给库设计者又带来了一把利器。从使用者的角度来看，可以获得效率的提升，避免对象在传递过程中重复创建。</li>
</ul>
</li>
<li>右值引用两个主要功能：<ul>
<li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</li>
<li>能够更简洁明确地定义泛型函数。</li>
</ul>
</li>
</ul>
</li>
<li><p>左值转换为右值：可以通过 <code>std::move</code> 可以将一个左值强制转化为右值，继而可以通过右值引用使用该值，以用于移动语义，从而完成将资源的所有权进行转移。</p>
</li>
<li><p>引用折叠: 通过类型别名或者通过模板参数间接定义，多重引用最终折叠成左值引用或者右值引用。有两种引用（左值和右值），所以就有四种可能的引用+引用的组合（左值 + 左值，左值 + 右值，右值 + 左值，右值 + 右值）。如果引用的引用出现在允许的语境，该双重引用会折叠成单个引用，规则如下：</p>
<ul>
<li>所有的右值引用叠加到右值引用上仍然还是一个右值引用；T&amp;&amp; &amp;&amp; 折叠成 T&amp;&amp;</li>
<li>所有的其他引用类型之间的叠加都将变成左值引用。T&amp; &amp;&amp;,T&amp;&amp; &amp;, T&amp;&amp; 折叠成 T&amp;。</li>
</ul>
</li>
<li><p>万能引用类型:</p>
<ul>
<li><p>在模板中 T&amp;&amp; t 在发生自动类型推断的时候，它是未定的引用类型（universal references），它既可以接受一个左值又可以接受一个右值。如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化。</p>
</li>
<li><p>对于函数 template<typename T>void f(T&amp;&amp; t)，当参数为右值 10 的时候，根据 universal references 的特点，t 被一个右值初始化，那么 t 就是右值；当参数为左值 x 时，t 被一个左值引用初始化，那么 t 就是一个左值</p>
</li>
<li><p>上面的例子中，param 是 universal reference，rhs 是 Test&amp;&amp; 右值引用，因为模版函数 f 发生了类型推断，而 Test&amp;&amp; 并没有发生类型推导，因为 Test&amp;&amp; 是确定的类型了。正是因为右值引用可能是左值也可能是右值，依赖于初始化，我们可以利用这一点来实现移动语义和完美转发</p>
</li>
</ul>
</li>
</ul>
<h4 id="std-move-函数的实现原理"><a href="#std-move-函数的实现原理" class="headerlink" title="std::move() 函数的实现原理"></a>std::move() 函数的实现原理</h4><ul>
<li><p><code>std::move()</code> 函数原型：<code>move</code> 函数是将任意类型的左值转为其类型的右值引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>引用折叠原理:<ul>
<li>右值传递给上述函数的形参 T&amp;&amp; 依然是右值，即 T&amp;&amp; &amp;&amp; 相当于 T&amp;&amp;。</li>
<li>左值传递给上述函数的形参 T&amp;&amp; 依然是左值，即 T&amp;&amp; &amp; 相当于 T&amp;。</li>
<li>通过引用折叠原理可以知道，move() 函数的形参既可以是左值也可以是右值。</li>
</ul>
</li>
<li>move 函数的处理流程:<ul>
<li>首先利用万能模板将传入的参数 t 进行处理，右值经过 T&amp;&amp; 传递类型保持不变还是右值，而左值经过 T&amp;&amp; 变为普通的左值引用，以保证模板可以传递任意实参，且保持类型不变；万能模板既可以接受左值作为实参也可以接受右值作为实参。</li>
<li>通过 remove_refrence 移除引用，得到参数 t 具体的类型 type；</li>
<li>最后通过 static_cast&lt;&gt; 进行强制类型转换，返回 type &amp;&amp; 右值引用。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>remove_reference</code> 具体实现：<code>remove_reference</code> 主要作用是解除类型中引用并返回变量的实际类型。</p>
</li>
<li><p>forward 的实现：forward 保证了在转发时左值右值特性不会被更改，实现完美转发。主要解决引用函数参数为右值时，传进来之后有了变量名就变成了左值。</p>
<ul>
<li>forward 函数的处理流程:<ul>
<li>forward 同样利用引用折叠的特性，对参数 t 做一次右值引用，根据引用折叠规则，右值的右值引用是右值引用，而左值的右值引用是普通的左值引用。forward 的实现有两个函数：</li>
<li>第一个，接受的参数是左值引用，只能接受左值。</li>
<li>第二个，接受的参数是右值引用，只能接受右值。</li>
</ul>
</li>
<li>根据引用折叠的原理：<ul>
<li>如果传递的是左值，_Tp 推断为 T &amp;，则返回变成static_cast&lt;T&amp; &amp;&amp;&gt;，也就是 static_cast&lt;T&amp;&gt;，所以返回的是左值引用。</li>
<li>如果传递的是右值，_Tp 推断为 T&amp;&amp; 或者 T，则返回变成 static_cast&lt;T &amp;&amp; &amp;&amp;&gt;，所以返回的是右值引用。</li>
</ul>
</li>
<li>forward 与 move 最大的区别是，move 在进行类型转换时，利用 remove_reference 将外层的引用全部去掉，这样可以将 t 强制转换为指定类型的右值引用，而 forward 则利用引用折叠的技巧，巧妙的保留了变量原有的属性。</li>
</ul>
</li>
</ul>
<h4 id="指针及其大小、用法"><a href="#指针及其大小、用法" class="headerlink" title="指针及其大小、用法"></a>指针及其大小、用法</h4><ul>
<li><p>指针的定义:</p>
<ul>
<li>指针是一种变量类型，其值为另一个变量的地址，即内存位置的直接地址。就像其他变量或常量一样，必须在使用指针存储其他变量地址之前，对其进行声明。在 64 位计算机中，指针占 8 个字节空间。</li>
<li>使用指针时可以用以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值</li>
</ul>
</li>
<li><p>指针的用法：</p>
<ul>
<li>空指针: C 语言中定义了空指针为 NULL，实际是一个宏，它的值是 0，即 #define NULL 0。C++ 中使用 nullptr 表示空指针，它是 C++ 11 中的关键字，是一种特殊类型的字面值，可以被转换成任意其他类型。</li>
<li>指针的运算:<ul>
<li>两个同类型指针可以比较大小；</li>
<li>两个同类型指针可以相减；</li>
<li>指针变量可以和整数类型变量或常量相加；</li>
<li>指针变量可以减去一个整数类型变量或常量；</li>
<li>指针变量可以自增，自减；</li>
</ul>
</li>
<li>指向普通对象的指针</li>
<li>指向常量对象的指针：常量指针，<code>const</code> 修饰表示指针指向的内容不能更改。</li>
<li>指向函数的指针：函数指针。</li>
<li>指向对象成员的指针，包括指向对象成员函数的指针和指向对象成员变量的指针。<ul>
<li>特别注意：定义指向成员函数的指针时，要标明指针所属的类。</li>
<li>而对于函数类型到函数指针类型的默认转换，只有当函数类型是左值的时候才行。所有对于非静态的成员函数，就不存在这种从函数类型到函数指针类型的默认转换，于是编译器也就不知道这个 p &#x3D; A::add 该怎么确定</li>
<li>由于非静态成员函数指针可以有多态行为，在编译期函数地址可能无法确定。</li>
<li>静态成员函数指针在编译期函数地址则可以确定。</li>
</ul>
</li>
<li>this 指针：指向类的当前对象的指针常量。</li>
</ul>
</li>
</ul>
<h4 id="野指针和悬空指针详解"><a href="#野指针和悬空指针详解" class="headerlink" title="野指针和悬空指针详解"></a>野指针和悬空指针详解</h4><ul>
<li>悬空指针：若指针指向一块内存空间，当这块内存空间被释放后，该指针依然指向这块内存空间，此时，称该指针为“悬空指针”。如果对悬空指针再次释放可能会出现不可预估的错误，比如可能该段内存被别的程序申请使用了，而此时对该段内存进行释放可能会产生不可预估的后果。</li>
<li>野指针：“野指针” 是指不确定其指向的指针，未初始化的指针为“野指针”，未初始化的指针的初始值可能是随机的，如果使用未初始化的指针可能会导致段错误，从而程序会崩溃</li>
<li>如何避免野指针: 指针在定义时即初始化，指针在释放完成后，需要将其置为空。</li>
</ul>
<h4 id="C-11-nullptr-比-NULL-的优势比较"><a href="#C-11-nullptr-比-NULL-的优势比较" class="headerlink" title="C++ 11 nullptr 比 NULL 的优势比较"></a>C++ 11 nullptr 比 NULL 的优势比较</h4><ul>
<li>NULL：预处理变量，是一个宏，它的值是 0，定义在头文件 <cstdlib> 中，即 #define NULL 0。</li>
<li>nullptr：C++ 11 中的关键字，是一种特殊类型的字面值，可以被转换成任意其他类型。</li>
<li>二者相比 nullptr 的优势：<ul>
<li>有类型，类型是 typdef decltype(nullptr) nullptr_t;，使用 nullptr 提高代码的健壮性。</li>
<li>函数重载：因为 NULL 本质上是 0，在函数调用过程中，若出现函数重载并且传递的实参是 NULL，可能会出现不知和哪一个函数匹配的情况；但是传递实参 nullptr 就不会出现这种情况</li>
</ul>
</li>
</ul>
<h4 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h4><ul>
<li>指针：指针是一个变量，它保存另一个变量的内存地址。需要使用 * 运算符指针才能访问它指向的内存位置。</li>
<li>引用：引用变量是别名，即已存在变量的另一个名称。对于编译器来说，引用和指针一样，也是通过存储对象的地址来实现的。实际可以将引用视为具有自动间接寻址的常量指针，编译器自动为引用使用 * 运算符。</li>
<li>二者的区别<ul>
<li>是否可变: 指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦初始化绑定就不能改变。</li>
<li>是否占内存: 指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间（实际底层编译器可能用指针实现的引用），当我们使用 &amp; 对引用取地址时，将会得到绑定对象的地址。</li>
<li>是否可为空：指针可以定义时不用初始化直接悬空，但是引用初始化时必须绑定对象。</li>
<li>是否能为多级：指针可以有多级，但是引用只能一级。我们可以定义指针的指针，但不能定义引用的引用</li>
</ul>
</li>
</ul>
<h4 id="常量指针和指针常量的区别"><a href="#常量指针和指针常量的区别" class="headerlink" title="常量指针和指针常量的区别"></a>常量指针和指针常量的区别</h4><ul>
<li>常量指针：常量指针本质上是个指针，只不过这个指针指向的对象是常量。<ul>
<li>特点：const 的位置在指针声明运算符 * 的左侧。只要 const 位于 * 的左侧，无论它在类型名的左边或右边，都表示指向常量的指针。（可以这样理解：* 左侧表示指针指向的对象，该对象为常量，那么该指针为常量指针。）</li>
<li><code>注意 1</code>：指针指向的对象不能通过这个指针来修改，也就是说常量指针可以被赋值为变量的地址，之所以叫做常量指针，是限制了通过这个指针修改变量的值。</li>
<li><code>注意 2</code>：虽然常量指针指向的对象不能变化，可是因为常量指针本身是一个变量，因此，可以被重新赋值。</li>
</ul>
</li>
<li>指针常量：指针常量的本质上是个常量，只不过这个常量的值是一个指针。<ul>
<li>特点：const 位于指针声明操作符右侧，表明该对象本身是一个常量，* 左侧表示该指针指向的类型，即以 * 为分界线，其左侧表示指针指向的类型，右侧表示指针本身的性质。</li>
<li><code>注意 1</code>：指针常量的值是指针，这个值因为是常量，所以指针本身不能改变。</li>
<li><code>注意 2</code>：指针的内容可以改变。</li>
</ul>
</li>
<li>指向常量的指针常量: 指向常量的指针常量，指针的指向不可修改，指针所指的内存区域中的值也不可修改。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ** <span class="type">const</span> p;  <span class="comment">// p 是一指针常量，它是一个指向指针的指针常量；</span></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> * p; <span class="comment">// p 是一个指针，它是一个指向指针常量的指针；</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> ** p;  <span class="comment">// p 是一个指针，它是一个指向常量的指针的指针；</span></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> * <span class="type">const</span> p; <span class="comment">// p 是一指针常量，它是一个指向指针常量的指针常量；</span></span><br></pre></td></tr></table></figure>

<h4 id="函数指针的定义"><a href="#函数指针的定义" class="headerlink" title="函数指针的定义"></a>函数指针的定义</h4><ul>
<li>函数指针：函数指针本质是一个指针变量，只不过这个指针指向一个函数。函数指针即指向函数的指针。<ul>
<li>所有的函数最终的编译都生成代码段，每个函数的都只是代码段中一部分而已，在每个函数在代码段中都有其调用的起始地址与结束地址，因此可以用指针变量指向函数的在代码段中的起始地址。</li>
</ul>
</li>
<li>需要注意的是，对于 fun1 和 &amp;fun1:<ul>
<li>函数名 fun1 存放的是函数的首地址，它是一个函数类型 void，&amp;fun1 表示一个指向函数对象 fun1 的地址，是一个指针类型。它的类型是 int (*)(int,int)，因此 fun1 和 &amp;fun1 的值是一样的；</li>
<li>&amp;fun1 是一个表达式，函数此时作为一个对象，取对象的地址，该表达式的值是一个指针。</li>
<li>通过打印 sizeof 即可知道 fun1 与 &amp;fun1 的区别；</li>
</ul>
</li>
</ul>
<h4 id="强制类型转换的类型"><a href="#强制类型转换的类型" class="headerlink" title="强制类型转换的类型"></a>强制类型转换的类型</h4><ul>
<li>static_cast：static_cast 是“静态转换”的意思，也即在编译期间转换，转换失败的话会抛出一个编译错误。一般用于如下:<ul>
<li>用于数据的强制类型转换，强制将一种数据类型转换为另一种数据类型。</li>
<li>用于基本数据类型的转换。</li>
<li>用于类层次之间的基类和派生类之间指针或者引用的转换（不要求必须包含虚函数，但必须是有相互联系的类），进行上行转换（派生类的指针或引用转换成基类表示）是安全的；进行下行转换（基类的指针或引用转换成派生类表示）由于没有动态类型检查，所以是不安全的，最好用 dynamic_cast 进行下行转换。</li>
<li>可以将空指针转化成目标类型的空指针。</li>
<li>可以将任何类型的表达式转化成 void 类型。</li>
<li>不能用于在不同类型的指针之间互相转换，也不能用于整型和指针之间的互相转换，当然也不能用于不同类型的引用之间的转换。</li>
</ul>
</li>
<li>const_cast：主要用于 const 与非 const、volatile 与非 volatile 之间的转换。强制去掉常量属性，不能用于去掉变量的常量性，只能用于去除指针或引用的常量性，将常量指针转化为非常量指针或者将常量引用转化为非常量引用（注意：表达式的类型和要转化的类型是相同的）。</li>
<li>reinterpret_cast：改变指针或引用的类型、将指针或引用转换为一个足够长度的整型、将整型转化为指针或引用类型。reinterpret_cast 转换时，执行的过程是逐个比特复制的操作。</li>
<li>dynamic_cast：其他三种都是编译时完成的，动态类型转换是在程序运行时处理的，运行时会进行类型检查。<ul>
<li>只能用于带有虚函数的基类或派生类的指针或者引用对象的转换，转换成功返回指向类型的指针或引用，转换失败返回 NULL；不能用于基本数据类型的转换。</li>
<li>在向上进行转换时，即派生类的指针转换成基类的指针和 static_cast 效果是一样的，（注意：这里只是改变了指针的类型，指针指向的对象的类型并未发生改变）</li>
<li>在下行转换时，基类的指针类型转化为派生类的指针类型，只有当要转换的指针指向的对象类型和转化以后的对象类型相同时，才会转化成功。</li>
</ul>
</li>
</ul>
<h4 id="结构体相等的判断方式及-memcmp-函数的使用"><a href="#结构体相等的判断方式及-memcmp-函数的使用" class="headerlink" title="结构体相等的判断方式及 memcmp 函数的使用"></a>结构体相等的判断方式及 memcmp 函数的使用</h4><ul>
<li>符号重载：需要重载操作符 &#x3D;&#x3D; 判断两个结构体是否相等，不能用函数 memcmp 来判断两个结构体是否相等，因为 memcmp 函数是逐个字节进行比较的，而结构体存在内存空间中保存时存在字节对齐，字节对齐时补的字节内容是随机的，会产生垃圾值，所以无法比较。</li>
</ul>
<h4 id="参数传递中：值传递、引用传递、指针传递的区别"><a href="#参数传递中：值传递、引用传递、指针传递的区别" class="headerlink" title="参数传递中：值传递、引用传递、指针传递的区别"></a>参数传递中：值传递、引用传递、指针传递的区别</h4><ul>
<li>值传递：形参是实参的拷贝，函数对形参的所有操作不会影响实参。形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参-&gt;形参），参数的值只能传入。当函数内部可能需要改变参数具体的内容时，我们则采用形参，在组成原理上来说，对于值传递的方式我们采用直接寻址。</li>
<li>指针传递：本质上是值传递，只不过拷贝的是指针的值，拷贝之后实参和形参是不同的指针，但指向的地址都相同。通过指针可以间接的访问指针所指向的对象，从而可以修改它所指对象的值。在组成原理上来说，对于指针传递的方式一般采用间接寻址。</li>
<li>引用传递：当形参是引用类型时，我们说它对应的实参被引用传递。当然不同的编译器对于引用有不同的实现，部分编译器在底层也是使用指针来实现引用传递。</li>
<li>函数调用的方式，大部分的编译器按照函数形参定义的逆序，依次将参数压入栈内，上述提到参数的形式，如果是值传递，则压入栈中的是一个临时变量，该变量与传入的值内容相同；如果是指针传递或者引用传递，则压入栈的可能是一个临时的指针变量，该指针指向与传入的指针指向的内容相同。从函数调用机制来开，不管何种调用所有实参的传入时都在栈中开辟了空间</li>
</ul>
<h4 id="模板及其实现"><a href="#模板及其实现" class="headerlink" title="模板及其实现"></a>模板及其实现</h4><ul>
<li>模板：创建类或者函数的蓝图或者公式，分为函数模板和类模板。<ul>
<li>实现方式：模板定义以关键字 template 开始，后跟一个模板参数列表。</li>
<li>模板参数列表不能为空；</li>
<li>模板类型参数前必须使用关键字 class 或者 typename，在模板参数列表中这两个关键字含义相同，可互换使用。</li>
</ul>
</li>
<li>函数模板：通过定义一个函数模板，可以避免为每一种类型定义一个新函数。<ul>
<li>对于函数模板而言，模板类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。</li>
<li>函数模板实例化：当调用一个模板时，编译器用函数实参来推断模板实参，从而使用实参的类型来确定绑定到模板参数的类型。</li>
</ul>
</li>
<li>类模板：类似函数模板，类模板以关键字 template 开始，后跟模板参数列表。但是，编译器不能为类模板推断模板参数类型，需要在使用该类模板时，在模板名后面的尖括号中指明类型。</li>
<li>变量模板：在 <code>C++14</code> 以后，变量也可以参数化为特定的类型，这称为变量模板。</li>
<li>函数重载与模板的区别: 函数重载和模板都是面向对象多态特性的例子。当多个函数执行非常相似（不相同）的操作时使用函数重载，当多个函数执行相同操作时使用模板，函数模板也可以重载。当模板类或者模板函数中含有静态变量时，则每个模板的实例类型都含有一个静态成员</li>
</ul>
<h4 id="函数模板和类模板的区别"><a href="#函数模板和类模板的区别" class="headerlink" title="函数模板和类模板的区别"></a>函数模板和类模板的区别</h4><ul>
<li>实例化方式不同：函数模板实例化由编译程序在处理函数调用时自动完成，类模板实例化需要在程序中显式指定。</li>
<li>实例化的结果不同：函数模板实例化后是一个函数，类模板实例化后是一个类。</li>
<li>默认参数：函数模板不允许有默认参数，类模板在模板参数列表中可以有默认参数。</li>
<li>特化：函数模板只能全特化；而类模板可以全特化，也可以偏特化。</li>
<li>调用方式不同：函数模板可以进行类型推导，可以隐式调用，也可以显式调用；类模板只能显式调用</li>
</ul>
<h4 id="什么是可变参数模板"><a href="#什么是可变参数模板" class="headerlink" title="什么是可变参数模板"></a>什么是可变参数模板</h4><ul>
<li>可变参数模板：接受可变数目参数的模板函数或模板类。将可变数目的参数被称为参数包，包括模板参数包和函数参数包。<ul>
<li>模板参数包：表示零个或多个模板参数；</li>
<li>函数参数包：表示零个或多个函数参数。</li>
<li>用省略号来指出一个模板参数或函数参数表示一个包，在模板参数列表中，class… 或 typename… 指出接下来的参数表示零个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。当需要知道包中有多少元素时，可以使用 sizeof… 运算符</li>
</ul>
</li>
<li>可变参数函数通常是递归的，第一个版本的 print_fun 负责终止递归并打印初始调用中的最后一个实参。第二个版本的 print_fun 是可变参数版本，打印绑定到 t 的实参，并用来调用自身来打印函数参数包中的剩余值</li>
</ul>
<h4 id="什么是模板特化"><a href="#什么是模板特化" class="headerlink" title="什么是模板特化"></a>什么是模板特化</h4><ul>
<li>模板特化的原因：模板并非对任何模板实参都合适、都能实例化，某些情况下，通用模板的定义对特定类型不合适，可能会编译失败，或者得不到正确的结果。因此，当不希望使用模板版本时，可以定义类或者函数模板的一个特例化版本。</li>
<li>模板特化：模板参数在某种特定类型下的具体实现。分为函数模板特化和类模板特化<ul>
<li>函数模板特化：将函数模板中的全部类型进行特例化，称为函数模板特化。</li>
<li>类模板特化：将类模板中的部分或全部类型进行特例化，称为类模板特化。</li>
</ul>
</li>
<li>特化分为全特化和偏特化：<ul>
<li>全特化：模板中的模板参数全部特例化。</li>
<li>偏特化：模板中的模板参数只确定了一部分，剩余部分需要在编译器编译时确定。</li>
</ul>
</li>
<li>说明：要区分下函数重载与函数模板特化</li>
<li>定义函数模板的特化版本，本质上是接管了编译器的工作，为原函数模板定义了一个特殊实例，而不是函数重载，函数模板特化并不影响函数匹配</li>
</ul>
<h4 id="switch-的-case-里为何不建议定义变量"><a href="#switch-的-case-里为何不建议定义变量" class="headerlink" title="switch 的 case 里为何不建议定义变量"></a>switch 的 case 里为何不建议定义变量</h4><ul>
<li>switch 下面的这个花括号表示一块作用域，而不是每一个 case 表示一块作用域。如果在某一 case 中定义了变量，其作用域在这块花括号内，按理说在另一个 case 内可以使用该变量，但是在实际使用时，每一个 case 之间互不影响，是相对封闭的</li>
<li>比如在符合 <code>A</code> 的条件下定义了变量，当符合 <code>B</code> 或者 <code>C</code> 的条件时，对该变量进行自增操作，但是因为不符合条件 <code>A</code> 未对变量进行定义，该变量无法使用</li>
</ul>
<h4 id="迭代器的作用"><a href="#迭代器的作用" class="headerlink" title="迭代器的作用"></a>迭代器的作用</h4><ul>
<li><p>迭代器：一种抽象的设计概念，在设计模式中有迭代器模式，即提供一种方法，使之<strong>能够依序寻访某个容器所含的各个元素，而无需暴露该容器的内部表述方式</strong>。迭代器<strong>只是一种概念上的抽象，具有迭代器通用功能和方法的对象都可以叫做迭代器</strong>。迭代器有很多不同的能力，可以把抽象容器和通用算法有机的统一起来。迭代器基本分为五种，输入输出迭代器，前向逆向迭代器，双向迭代器和随机迭代器。</p>
<ul>
<li>输入迭代器(Input Iterator)：只能向前单步迭代元素，不允许修改由该迭代器所引用的元素；</li>
<li>输出迭代器(Output Iterator)：只能向前单步迭代元素，对由该迭代器所引用的元素只有写权限；</li>
<li>向前迭代器(Forward Iterator)：该迭代器可以在一个区间中进行读写操作，它拥有输入迭代器的所有特性和输出迭代器的部分特性，以及向前单步迭代元素的能力；</li>
<li>双向迭代器(Bidirectional Iterator)：在向前迭代器的基础上增加了向后单步迭代元素的能力；</li>
<li>随机访问迭代器(Random Access Iterator)：不仅综合以后 4 种迭代器的所有功能，还可以像指针那样进行算术计算；</li>
</ul>
</li>
<li><p>在 C++ STL 中，容器 vector、deque 提供随机访问迭代器，list 提供双向迭代器，set 和 map 提供向前迭代器。</p>
</li>
<li><p>使用迭代器的优点：</p>
<ul>
<li>代码编写方便：迭代器提供了通用接口来遍历元素，不用担心容器的大小，使用迭代器我们可以简单地使用成员函数 end() 来判断容器的结尾，遍历内容方便而简洁；</li>
<li>代码可重用性高：：迭代器提供了一组通用的 api 访问和遍历容器中的元素。迭代器支持代码的可重用性，它们可以被使用访问任何容器的元素。</li>
<li>容器可以动态处理：迭代器能够在需要时方便地从容器中动态添加或删除元素。</li>
</ul>
</li>
</ul>
<h4 id="泛型编程如何实现"><a href="#泛型编程如何实现" class="headerlink" title="泛型编程如何实现"></a>泛型编程如何实现</h4><ul>
<li>泛型编程实现的基础：模板。模板是创建类或者函数的蓝图或者说公式，当时用一个 vector 这样的泛型，或者 find 这样的泛型函数时，编译时会转化为特定的类或者函数。</li>
<li>泛型编程涉及到的知识点较广，例如：容器、迭代器、算法等都是泛型编程的实现实例。<ul>
<li>容器：涉及到 STL 中的容器，例如：vector、list、map 等</li>
<li>迭代器：在无需知道容器底层原理的情况下，遍历容器中的元素。</li>
<li>模板</li>
</ul>
</li>
<li>泛型编程优缺点：<ul>
<li>通用性强：泛型算法是建立在语法一致性上，运用到的类型集是无限的&#x2F;非绑定的。</li>
<li>效率高：编译期能确定静态类型信息，其效率与针对某特定数据类型而设计的算法相同。</li>
<li>类型检查严：静态类型信息被完整的保存在了编译期，在编译时可以发现更多潜在的错误。</li>
<li>二进制复用性差：泛型算法是建立在语法一致性上，语法是代码层面的，语法上的约定无法体现在机器指令中。泛型算法实现的库，其源代码基本上是必须公开的，引用泛型中库都需要重新编译生成新的机器指令。而传统的 C 库全是以二进制目标文件形式发布的，需要使用这些库时直接动态链接加载使用即可，不需要进行再次编译。</li>
</ul>
</li>
</ul>
<h4 id="什么是类型萃取"><a href="#什么是类型萃取" class="headerlink" title="什么是类型萃取"></a>什么是类型萃取</h4><ul>
<li><p>类型萃取（type traits）使用模板技术来萃取类型（包含自定义类型和内置类型）的某些特性，用以判断该类型是否含有某些特性，从而在泛型算法中来对该类型进行特殊的处理用来提高效率或者得到其他优化。简单的来说类型萃取即确定变量去除引用修饰以后的真正的变量类型或者 CV 属性。C++ 关于 type traits 的详细使用技巧可以参考头文件 #include <type_traits>。</p>
</li>
<li><p>为什么需要 type traits：</p>
<ul>
<li>对于普通的变量来说，确定变量的类型比较容易，比如 int a &#x3D; 10; 可以很容易确定变量的实际类型为 int，但在使用模板时确定变量的类型就比较困难，模板传入的类型为不确定性<ul>
<li>为什么需要确定变量的实际类型？因为模板函数针对传入的对不同的类型可能作出不同的处理，这就需要我们在处理函数模板对传入的参数类型和特性进行提取。比如自定义拷贝函数 copy(T *dest, const T *src) ，如果 T 此时为 int 类型，则此时我们只需要 *dest &#x3D; *src 即可，但是如果我们此时传入的 T 为 char * 字符串类型时，则就不能简单进行指针赋值，所以函数在实际处理时则需要对传入的类型进行甄别，从而针对不同的类型给予不同的处理，这样才能使得函数具有通用性。</li>
</ul>
</li>
<li>remove_reference_t 的原理：<ul>
<li>move 函数在进行强制类型转换时，会使用到 remove_reference_t，该函数的作用是确定函数除去 C-V 和引用后的类型。</li>
<li>通过 remove_reference_t<T> 可以把 t 对应的类型上的引用给去掉，然后把 t 对应的类型的右值引用符号 &amp;&amp; 强制绑定在变量 t 上，这样就强制将变量 t 转换为右值引用类型</li>
</ul>
</li>
</ul>
</li>
<li><p>C++ 类型萃取一般用于模板中，当我们定义一个模板函数后，需要知道模板类型形参并加以运用时就奥数可以用类型萃取。通过确定变量的特征我们可以在模板中使用不同的处理方法</p>
</li>
</ul>
<h3 id="C-I-x2F-O-与进程同步"><a href="#C-I-x2F-O-与进程同步" class="headerlink" title="C++ I&#x2F;O 与进程同步"></a>C++ I&#x2F;O 与进程同步</h3><h4 id="C-I-x2F-O-操作"><a href="#C-I-x2F-O-操作" class="headerlink" title="C++ I&#x2F;O 操作"></a>C++ I&#x2F;O 操作</h4><ul>
<li><p>C++ 保持与 C 兼容，因此也保留支持 printf 和 scanf 进行输出和输人的方法。c++ 具有面向对象的特性，引入了新的输入输出。C++ 通过 I&#x2F;O 类库来实现丰富的 I&#x2F;O 功能。在 C++ 中，输入和输出以字节序列或更通常称为 stream 的形式执行。</p>
<ul>
<li>输入流（inputstream）：如果字节流的方向是从设备（例如键盘）到主存，那么这个过程称为输入。</li>
<li>输出流（outputstream）：如果字节流的方向相反，即从主存到设备（显示屏），那么这个过程称为输出。</li>
</ul>
</li>
<li><p>C++ 采用了面向对象的思想对所有涉及 I&#x2F;O 的操作进行了统一的封装，涉及到 I&#x2F;O 操作的主要由 <iostream>,<iomanip>,<fstream> 三个头文件组成，stream 是其行为由类定义的对象</p>
</li>
<li><p>C++ 中的 Streams 对象主要分为三种类型：</p>
<ul>
<li>istream ：这种类型的流对象只能从流中执行输入操作；</li>
<li>ostream ：这些对象只能用于输出操作；</li>
<li>iostream ：可用于输入和输出操作；</li>
</ul>
</li>
<li><p>标准输入输出:</p>
<ul>
<li>标准输出流（cout）：通常标准输出设备是显示器。C++ cout 语句是 ostream 类的实例。它用于在标准输出设备上产生输出。需要在屏幕上显示的数据使用插入运算符（&lt;&lt;） 插入到标准输出流（cout）中。</li>
<li>标准输入流（cin）：通常计算机中的输入设备是键盘。C++ cin 语句是 istream 类的实例，用于从标准输入设备（通常是键盘）读取输入。 提取运算符 （&gt;&gt;） 与对象 cin 一起用于读取输入。提取运算符从使用键盘输入的对象 cin 中提取数据。</li>
</ul>
</li>
<li><p>I&#x2F;O 重定向：</p>
<ul>
<li>所有流对象都有一个关联的数据成员类 streambuf。简单地说，streambuf 对象就是流的缓冲区。当我们从流中读取数据时，我们不会直接从源中读取数据，而是从链接到源的缓冲区中读取数据。同样，输出操作首先在缓冲区上执行，然后在需要时刷新缓冲区（写入物理设备）。</li>
<li>C++ 允许我们为任何流设置流缓冲区，因此重定向流的任务简单地减少为更改与流关联的流缓冲区。因此，要将流 A 重定向到流 B，我们需要执行以下操作：<ul>
<li>获取 A 的流缓冲区并将其存储在某处；</li>
<li>将 A 的流缓冲区设置为 B 的流缓冲区；</li>
<li>如果需要将 A 的流缓冲区重置为其先前的流缓冲区；可以使用函数 ios::rdbuf()</li>
</ul>
</li>
</ul>
</li>
<li><p>在 C&#x2F;C++ 如何中清除输入缓冲区：</p>
<ul>
<li>所有标准输入和输出设备都包含一个输入和输出缓冲区。在标准 C&#x2F;C++ 中，流被缓冲。例如在标准输入的情况下，当我们按下键盘上的键时，它不会发送到程序，而是由操作系统发送到缓冲区，直到进程调度时才将其分配给该程序。</li>
<li>在各种情况下，可能需要清除不需要的缓冲区，以便在所需的程序中立即获取下一个输入，而不是在前一个变量的缓冲区中。比如 C 遇到 scanf() 后，需要输入字符数组或字符，C++ 遇到 cin 语句后，需要输入字符数组或字符。当我们从键盘获取一个字符串时，我们需要清除输入缓冲区，否则所需的输入被前一个变量的缓冲区占用<ul>
<li>使用 <code>cin.ignore(numeric_limits::max(),&#39;\n&#39;);</code> ”，在 <code>cin</code> 语句之后丢弃输入流中的所有内容，包括换行符</li>
<li>在 <code>cin</code> 语句之后输入 <code>cin&gt;&gt;ws</code> 告诉编译器忽略缓冲区并丢弃字符串或字符数组实际内容之前的所有空格</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="线程同步与异步"><a href="#线程同步与异步" class="headerlink" title="线程同步与异步"></a>线程同步与异步</h4><ul>
<li><p>线程同步操作：</p>
<p>C++ 标准库提供了以下几种线程同步的方式:</p>
<ul>
<li>互斥量（支持超时加锁、递归加锁）；</li>
<li>读写锁（共享互斥量，也支持超时加锁）；</li>
<li>互斥量包装器（基于 RAII 的思想）；</li>
<li>条件变量；</li>
<li>信号量（二元信号量、计数信号量）；</li>
<li>barrier；</li>
<li>call_once；</li>
</ul>
</li>
<li><p>互斥量（mutex）：</p>
<ul>
<li>互斥量（mutex）是防止同时访问共享资源的程序对象。为避免线程更新共享变量时所出现问题，必须使用互斥量（mutex 是 mutual exclusion 的缩写）来确保同时仅有一个线程可以访问某项共享资源。 即使用互斥量来实现原子访问操作，防止多个线程对临界区同时操作而产生不一致的问题。</li>
<li>mutex 只有锁定（locked）和未锁定（unlocked）两种状态。任何时候，至多只有一个线程可以锁定互斥量。试图对已经锁定的互斥量再次加锁，将可能阻塞线程或者报错失败，mutex 的底层可能封装的是操作系统 spinlock，不同的操作系统下可能有不同的实现。C++ 中关于 mutex 的头文件为 #include <mutex></li>
<li>C++ 中还定义了 timed_mutex：在 mutex 的基础上增加了超时加锁的功能。<br>recursive_mutex：在 mutex 的基础上增加了递归加锁的功能（此时，lock() 函数可以被同一线程在不释放锁的情况下多次调用）</li>
</ul>
</li>
<li><p>共享互斥量:</p>
<ul>
<li>std::shared_mutex 是 C++ 17 标准中引入的，由 unique_lock 和 shared_lock 两个类模板配合 shared_mutex 使用，主要用于读写共享锁。unique_lock 用于写入时加锁，shared_lock 用于读取时加锁。对象在构造时自动对 std::shared_mutex 加锁，析构时自动对其解锁。头文件主要包含在 #include <shared_mutex>。</li>
<li>shared_mutex 可用于保护共享数据不被多个线程同时访问。与其他便于独占访问的互斥锁类型相比，shared_mutex 具有两个访问级别：<ul>
<li>shared：多个线程可以共享同一个互斥锁的所有权。</li>
<li>exclusive ：只有一个线程可以拥有互斥锁。</li>
</ul>
</li>
<li>共享互斥锁通常用于多个读取操作可以同时访问同一资源而不会导致数据竞争，但只有一个写入操作的场景</li>
<li><code>shared_timed_mutex</code> 是在 <code>shared_mutex</code> 的基础上增加了超时加锁的功能。</li>
</ul>
</li>
<li><p>互斥量包装器</p>
<ul>
<li><code>lock_guard</code>：使用了 <code>RAII</code> 的机制对互斥量进行类模板封装，构造时加锁，析构时解锁</li>
<li>互斥量包装器对比原生的 mutex 来说，创建即加锁，作用域结束自动析构并解锁，无需手动解锁。缺点是不能中途解锁，不支持复制和移动。在需要加锁的地方，只需要任意实例化一个 lock_guard，调用构造函数成功上锁，出作用域时则 lock_guard 对象会被销毁，调用析构函数自动解锁可以有效避免死锁问题，但是提供的功能单一且不够灵活。</li>
<li>unique_lock：unique_lock 类模板也是采用 RAII 的方式对锁进行了封装，并且也是以独占所有权的方式管理 mutex 对象的上锁和解锁操作，即其对象之间不能发生拷贝。在构造（或移动 move 赋值）时，unique_lock 对象需要传递一个 mutex 对象作为它的参数，新创建的 unique_lock 对象负责传入的 mutex 对象的上锁和解锁操作。使用以上类型互斥量实例化 unique_lock 的对象时，自动调用构造函数上锁，unique_lock 对象销毁时自动调用析构函数解锁，可以很方便的防止死锁问题。与 lock_guard 不同的是，unique_lock 更加的灵活，提供了更多的成员函数：<ul>
<li>上锁&#x2F;解锁操作：lock、try_lock、try_lock_for、try_lock_until 和 unlock；</li>
<li>修改操作：支持移动赋值、交换（swap：与另一个 unique_lock 对象互换所管理的互斥量所有权）、释放（release：返回它所管理的互斥量对象的指针，并释放所有权）。</li>
<li>获取属性：owns_lock （返回当前对象是否上了锁）、operator bool() （与 owns_lock() 的功能相同）、mutex（返回当前 unique_lock 所管理的互斥量的指针）</li>
</ul>
</li>
</ul>
</li>
<li><p>条件变量（condition variable）：</p>
<ul>
<li>在 C++ 11 以后，我们可以使用条件变量（condition_variable）实现多个线程间的同步操作；当条件不满足时，相关线程被一直阻塞，直到某种条件出现，这些线程才会被唤醒。C++ 中包含的头文件在 #include <condition_variable> 中。</li>
<li>条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：<ul>
<li>一个线程因等待 条件变量的条件成立 而挂起；</li>
<li>另外一个线程使 条件成立 从而给出唤醒线程的信号，从而唤醒被等待的线程；</li>
</ul>
</li>
<li>为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起；通常情况下这个锁是 std::mutex，并且管理这个锁只能是 std::unique_lock std::mutex 等 RAII 模板类。分别是使用以下两个方法实现：<ul>
<li>等待条件成立使用的是 condition_variable 类成员 wait 、wait_for 或 wait_until</li>
<li>唤醒信号使用的是 condition_variable 类成员 notify_one 或者 notify_all 函数。</li>
</ul>
</li>
</ul>
</li>
<li><p>信号量：</p>
<ul>
<li>C++ 20 中添加了 C++ 中的信号量为二元信号量与计数信号量，二元信号量实际为计数信号量模板的特化。</li>
<li>binary_semaphore：二元信号量类似于互斥量，信号量只有 0 与 1 。</li>
<li>counting_semaphore：计数信号量</li>
<li>所有关于信号量的定义参考头文件 #include <semaphore>，计数信号量是一种轻量级同步原语，可以控制对共享资源的访问。与 std::mutex 不同的是，acounting_semaphore 至少允许 LeastMaxValue 并发访问者对同一资源进行多个并发访问。Acounting_semaphore 包含一个由构造函数初始化的内部计数器。该计数器可以通过 acquire() 获取资源访问权限，并通过调用 release() 来释放资源从而递增计数器。当计数器为零时，调用 acquire() 时就会阻塞直到计数器增加，但是调用 try_acquire( ) 不阻塞；try_acquire_for() 和 try_acquire_until() 阻塞直到计数器增加或达到超时</li>
</ul>
</li>
<li><p>barrier:</p>
<ul>
<li>C++ 20 以后支持 latch 与 barrier，他们同样可以用来线程同步。</li>
<li>latch：类 latch 是 std::ptrdiff_t 类型的向下计数器，可用于同步线程。计数器的值在创建时初始化。线程可能会阻塞在锁存器上，直到计数器减为零。不能增加或重置计数器，这使得锁存器创建后不可重用。其内部维护着一个计数器，当计数不为 0 时，所有参与者（线程）都将阻塞在等待操作处，计数为 0 时，解除阻塞。计数器不可重置或增加，故它是一次性的，不可重用。与 std::barrier 不同，std::latch 参与线程可以多次递减</li>
<li>barrier：类似于 latch，它会阻塞线程直到所有参与者线程都到达一个同步点，直到预期数量的线程到达设定的值则会接触阻塞。与 latch 不同的是，它是可重用的。一个 barrier 的生命周期包含多个阶段，每个阶段都定义了一个同步点。一个 barrier 阶段包含：<ul>
<li>期望计数（设创建时指定的计数为 n），当期望计数不为 0 时，参与者将阻塞于等待操作处；</li>
<li>当期望计数为 0 时，会执行创建 barrier 时指定的阶段完成步骤，然后解除阻塞所有阻塞于同步点的参与者线程。</li>
<li>当阶段完成步骤执行完成后，会重置期望计数为 n - 调用arrive_and_drop() 的次数，然后开始下一个阶段</li>
</ul>
</li>
</ul>
</li>
<li><p><code>call_once</code>:<code>C++ 11</code> 以后支持 <code>call_once</code>。确保某个操作只被执行一次（成功执行才算），即使是多线程环境下也确保只执行一次。如果在 <code>call_once</code> 被调用时，<code>flag</code> 表明 <code>f</code> 已经被调用，则 <code>call_once</code> 立即返回（这种调用 <code>call_once</code> 称为被动）。</p>
</li>
</ul>
<h4 id="C-互斥信号量"><a href="#C-互斥信号量" class="headerlink" title="C++ 互斥信号量"></a>C++ 互斥信号量</h4><ul>
<li><p>std::thread：可以通过 thread 创建一个线程（C++ 11 以后才支持 thread 标准库），thread 在构造相关线程对象完成后立即开始执行（实际需要等待 OS 对于线程的调度延迟）。thread 需要配合与 join 或者 detach 配合使用，不然可能出现不可预料的后果。</p>
<ul>
<li>join 代表阻塞当前主线程，等待当前的 join 的子线程完成后主线程才会继续；</li>
<li>detach 表明当前子线程不阻塞主线程，且与主线程分离，子线程的运行不会影响到主线程</li>
<li>在一个类中间，一个成员函数需要异步调用另一个函数的时候，需要绑定 <code>this</code></li>
</ul>
</li>
<li><p>std::async: </p>
<ul>
<li><p>进行异步编程时，需要得到子进程的计算结果，常见的手段是可以通过共享变量或者消息队列的方式告知另一个线程当前的计算结果，但是操作和实现都比较麻烦，同时还要考虑线程间的互斥问题。</p>
</li>
<li><p>C++11 中提供了一个相对简单的异步接口 std::async，通过这个接口可以简单地创建线程并通过 std::future 中获取结果，极大的方便了 C++ 多线程编程。</p>
</li>
<li><p>std::async 适合与需要取得结果的异步线程。C++11 中的 std::async 是个模板函数。</p>
</li>
<li><p>std::async 异步调用函数，在某个时候以 Args 作为参数（可变长参数）调用函数，无需等待函数执行完成就可返回，返回结果是个 std::future 对象。函数返回的值可通过 std::future 对象的 get 成员函数获取。一旦完成函数的执行，共享状态将包含函数返回的值并 ready</p>
</li>
<li><p><code>async</code> 使用的函数原型和参数说明如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//(C++11 起) (C++17 前)</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">Function</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">std::future&lt;std::<span class="type">result_of_t</span>&lt;std::<span class="built_in">decay_t</span>&lt;Function&gt;(std::<span class="type">decay_t</span>&lt;Args&gt;...)&gt;&gt;</span><br><span class="line">    <span class="built_in">async</span>( Function&amp;&amp; f, Args&amp;&amp;... args );</span><br><span class="line"></span><br><span class="line"><span class="comment">//(C++11 起) (C++17 前)</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">Function</span>, <span class="keyword">class</span>... Args &gt;</span><br><span class="line">std::future&lt;std::<span class="type">result_of_t</span>&lt;std::<span class="built_in">decay_t</span>&lt;Function&gt;(std::<span class="type">decay_t</span>&lt;Args&gt;...)&gt;&gt;</span><br><span class="line">    <span class="built_in">async</span>( std::launch policy, Function&amp;&amp; f, Args&amp;&amp;... args ); </span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数是 std::async 的启动策略类型以下两种方式：async 允许调用者选择特定的启动策略:<ul>
<li>std::launch::async：在调用 async 就开始创建线程，该函数由新线程异步调用，并且将其返回值与共享状态的访问点同步。</li>
<li>std::launch::deferred：延迟启动线程，在访问共享状态时该线程才启动。对函数的调用将推迟到返回的 std::future 的共享状态被访问时（即使用 std::future 的 wait 或 get 函数）。如果 get 或 wait 没有被调用，函数就绝对不会执行。</li>
</ul>
</li>
<li>参数 Function：可以为函数指针、成员指针、任何类型的可移动构造的函数对象，也可以为匿名函数 lambda。Function 的返回值或异常存储在共享状态中以供异步的 std::future 对象检索。std::future 对象可以通过 wait 或 get 函数获取函数的返回值。</li>
<li>参数 Args：传递给函数 Function 调用的参数，它们的类型应是可移动构造的</li>
</ul>
</li>
</ul>
</li>
<li><p>std::future:  std::future 提供了一种访问线程异步操作结果的机制。从字面意思来看，future 表示未来，std::async 返回结果即为一个 future。在实际工程项目中，一个异步操作是不可能马上就获取操作结果的，只能在将来的某个时候获取，但是可以以同步等待的方式来获取结果，可以通过查询 future 的状态（future_status）来获取异步操作的结果。future_status 有三种状态：</p>
<ul>
<li>deferred：异步操作还没开始；</li>
<li>ready：异步操作已经完成；</li>
<li>timeout：异步操作超时；</li>
</ul>
<p>获取 future 结果有三种方式：get、wait、wait_for，其中 get 等待异步操作结束并返回结果，wait 只是等待异步操作完成，没有返回值，wait_for 是超时等待返回结果</p>
</li>
</ul>
<h4 id="C-条件变量"><a href="#C-条件变量" class="headerlink" title="C++ 条件变量"></a>C++ 条件变量</h4><ul>
<li><p>条件变量（condition variable）：在 C 语言中使用 pthread_cond_wait 函数作为条件变量，它是由操作系统实现的条件变量。在 C++ 11 以后，可以使用条件变量（condition_variable）实现多个线程间的同步操作；当条件不满足时，相关线程被一直阻塞，直到某种条件出现，这些线程才会被唤醒。C++ 中包含的头文件在 #include <condition_variable> 中。</p>
<ul>
<li>条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：<ul>
<li>一个线程因等待条件变量的条件成立而挂起；</li>
<li>另外一个线程使条件成立从而给出唤醒线程的信号，从而唤醒被等待的线程；</li>
</ul>
</li>
</ul>
</li>
<li><p>为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起；通常情况下这个锁是 std::mutex，并且管理这个锁只能是 std::unique_lock std::mutex 等 RAII 模板类。分别是使用以下两个方法实现：</p>
<ul>
<li><p>等待条件成立使用的是 condition_variable 类成员 wait、wait_for 或 wait_until。</p>
</li>
<li><p>唤醒信号使用的是 condition_variable 类成员 notify_one 或者 notify_all 函数。<br>condition_variable 支持的函数如下:</p>
<p>构造函数: 它只有默认构造函数，拷贝构造函数和赋值符号重载均被禁止 condition_variable(const condition_variable&amp;) &#x3D; delete;，operator&#x3D; [delete]；</p>
<p>wait：wait 目前支持 wait，wait_for，wait_until 等三种操作，分别对应不同的场景:</p>
<ul>
<li><p><code>wait</code>: 对应的函数原型为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">( std::unique_lock&lt;std::mutex&gt;&amp; lock )</span></span>; </span><br></pre></td></tr></table></figure>

<p>当前线程执行时就被阻塞，直到等到被 notify 唤醒。在阻塞线程的那一刻，该函数自动调用 lck.unlock()，允许其他被 lck 锁定的线程继续运行。阻塞时被一旦某个线程 notify 时，实际可能为虚假唤醒，该函数将解除阻塞并调用 lck.lock()，获取互斥锁</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span> <span class="params">(unique_lock&lt;mutex&gt;&amp; lck, Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure>

<p>调用时检查 pred，如果为 false, 则阻塞线程，并且调用 lock.unlock(), 否则，继续执行。阻塞时被一旦某个线程 notify 时，实际可能为虚假唤醒，该函数将再次检查 pred，如果为 true，则解除阻塞并调用 lck.lock()，获取互斥锁；否则继续阻塞线程</p>
</li>
<li><p><code>wait_for</code>: 对应的函数原型为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Rep, <span class="keyword">class</span> Period, <span class="keyword">class</span> Predicate &gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait_for</span><span class="params">( std::unique_lock&lt;std::mutex&gt;&amp; lock,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time,</span></span></span><br><span class="line"><span class="params"><span class="function">    Predicate stop_waiting)</span></span>;</span><br></pre></td></tr></table></figure>

<p>用时，检查两个条件是否满足: stop_waiting 返回是否为 true，时间是否超时，如果两个条件都不满足，则阻塞线程，并调用 lock.unlock(), 否则，到达一定等待时间或满足条件被唤醒。注意等待超过时间段后自动唤醒，判断条件一般需要使用者自己在合适的时候判断，并通过 notify_one() 或 notify_all() 唤醒，所以在使用时应当通过判断返回值来检测是其由于超时返回还是被正常唤醒，即状态是否为 std::cv_status::timeout</p>
</li>
<li><p>wait_for 是通过 wait_until 实现的，到达指定截止时间或满足条件 conditions 时线程即被唤醒。不同的是，到达时间点是自动唤醒，而条件满足 conditions 时则是通过 notify_one() 或 notify_all() 唤醒，使用的时候注意判断返回值，根据返回值确定该线程是被超时唤醒还是被其他线程 notify 正常唤醒，即状态是否为 std::cv_status::timeout</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>notify：</p>
<ul>
<li>notify_one 唤醒一个阻塞的线程，线程唤醒的顺序可能是随机的，并没有特定的顺序</li>
<li>notify_all 唤醒所有的阻塞在 condition_variable 下的线程。需要特别注意的是，可能唤醒所有阻塞的线程，但是唤醒的多个线程同一时间只能有一个线程可以持有 lck 锁，必须等待其执行 wait 之后的代码，并释放 lck 时，剩余被唤醒的线程才可以执行，我们可以观察到以下程序示例，唤醒的顺序都是随机的</li>
</ul>
</li>
<li><p>虚假唤醒以及如何避免虚假唤醒:</p>
<ul>
<li>当线程从等待已发出信号的条件变量中醒来，却发现它等待的条件未得到满足时，就会发生虚假唤醒。发生虚假唤醒通常是因为在发出条件变量信号和等待线程最终运行之间，另一个线程运行并更改了条件，导致 wait 的线程被唤醒后，实际条件却未满足。比如我们在 notify_all() 时多个线程都被唤醒，但此时实际共享区却只有少数几个线程可以操作，这时就会造成其他线程被虚假唤醒，可以在 wait 唤醒后再次进行检测 condition 解决虚假唤醒。</li>
<li>虚假唤醒导致的后果：之前要等待的某个条件实际上并没有符合，被唤醒的线程将可能会执行一系列非法操作。</li>
<li>通常的解决办法：在条件变量阻塞的代码处增加一个 while 循环，如果被唤醒就要检查一下条件是否符合，如果不符合则要再次进入阻塞等待。这样即避免了忙等待，又避免了虚假唤醒问题</li>
</ul>
</li>
</ul>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="常见设计模式"><a href="#常见设计模式" class="headerlink" title="常见设计模式"></a>常见设计模式</h4><ul>
<li><p>设计模式有 6 大设计原则：</p>
<ul>
<li><strong>单一职责原则</strong>：就一个类而言，应该仅有一个引起它变化的原因。</li>
<li><strong>开放封闭原则</strong>：软件实体可以扩展，但是不可修改。即面对需求，对程序的改动可以通过增加代码来完成，但是不能改动现有的代码。</li>
<li><strong>里氏代换原则</strong>：一个软件实体如果使用的是一个基类，那么一定适用于其派生类。即在软件中，把基类替换成派生类，程序的行为没有变化。</li>
<li><strong>依赖倒转原则</strong>：抽象不应该依赖细节，细节应该依赖抽象。即<strong>针对接口编程，不要针对实现编程</strong>。</li>
<li><strong>迪米特原则</strong>：如果两个类不直接通信，那么这两个类就不应当发生直接的相互作用。如果一个类需要调用另一个类的某个方法的话，可以通过第三个类转发这个调用。</li>
<li><strong>接口隔离原则</strong>：每个接口中不存在派生类用不到却必须实现的方法，如果不然，就要将接口拆分，使用多个隔离的接口。</li>
</ul>
</li>
<li><p>设计模式分为三类：</p>
<ul>
<li><strong>创造型模式：单例模式、工厂模式</strong>、建造者模式、原型模式</li>
<li><strong>结构型模式</strong>：适配器模式、桥接模式、外观模式、组合模式、<strong>装饰模式</strong>、享元模式、代理模式</li>
<li><strong>行为型模式</strong>：责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、<strong>观察者模式</strong>、状态模式、策略模式、模板方法模式、访问者模式</li>
</ul>
</li>
<li><p>常见的几种设计模式：</p>
<ul>
<li>单例模式：保证<strong>一个类仅有一个实例，并提供一个访问它的全局访问点</strong>。</li>
<li>工厂模式：包括简单工厂模式、抽象工厂模式、工厂方法模式<ul>
<li>简单工厂模式：主要用于创建对象。<strong>用一个工厂来根据输入的条件产生不同的类，然后根据不同类的虚函数得到不同的结果</strong>。</li>
<li>工厂方法模式：修正了简单工厂模式中<strong>不遵守开放封闭原则</strong>。把<strong>选择判断移到了客户端去实现</strong>，如果想添加新功能就不用修改原来的类，直接修改客户端即可。</li>
<li>抽象工厂模式：<strong>定义了一个创建一系列相关或相互依赖的接口，而无需指定他们的具体类</strong>。</li>
</ul>
</li>
<li>观察者模式：定义了一种一对多的关系，让多个观察对象同时监听一个主题对象，主题对象发生变化时，会通知所有的观察者，使他们能够更新自己。</li>
<li>装饰模式：动态地给<strong>一个对象添加一些额外的职责</strong>，就增加功能来说，装饰模式比生成派生类更为灵活。</li>
</ul>
</li>
</ul>
<h4 id="单例模式及其实现"><a href="#单例模式及其实现" class="headerlink" title="单例模式及其实现"></a>单例模式及其实现</h4><ul>
<li>单例模式：保证类的实例化对象仅有一个，并且提供一个访问他的全局访问点。</li>
<li>应用场景：<ul>
<li>表示文件系统的类，一个操作系统一定是只有一个文件系统，因此文件系统的类的实例有且仅有一个。</li>
<li>打印机打印程序的实例，一台计算机可以连接好几台打印机，但是计算机上的打印程序只有一个，就可以通过单例模式来避免两个打印作业同时输出到打印机。</li>
</ul>
</li>
<li>实现方式：<ul>
<li>单例模式可以通过全局或者静态变量的形式实现，这样比较简单，但是这样会影响封装性，难以保证别的代码不会对全局变量造成影响。</li>
<li>默认的构造函数、拷贝构造函数、赋值构造函数声明为私有的，这样禁止在类的外部创建该对象；</li>
<li>全局访问点也要定义成 静态类型的成员函数，没有参数，返回该类的指针类型。因为使用实例化对象的时候是通过类直接调用该函数，并不是先创建一个该类的对象，通过对象调用。</li>
</ul>
</li>
<li>不安全的实现方式：<ul>
<li>原因：考虑当两个线程同时调用 getInstance 方法，并且同时检测到 instance 是 NULL，两个线程会同时实例化对象，不符合单例模式的要求。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton * instance;</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; tmp)&#123;&#125;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp; tmp)&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* <span class="built_in">getInstance</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instance = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>分类：</p>
<ul>
<li>懒汉模式：直到第一次用到类的实例时才去实例化，上面是懒汉实现。</li>
<li>饿汉模式：类定义的时候就实例化。</li>
</ul>
</li>
<li><p>线程安全的懒汉模式实现：</p>
<ul>
<li><p>方法：加锁</p>
<ul>
<li>存在的问题：每次判断实例对象是否为空，都要被锁定，如果是多线程的话，就会造成大量线程阻塞</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="type">static</span> Singleton * instence;</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; tmp)&#123;&#125;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp; tmp)&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* <span class="built_in">getInstence</span>()&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span>(instence == <span class="literal">NULL</span>)&#123;            </span><br><span class="line">            instence = <span class="keyword">new</span> <span class="built_in">Singleton</span>();            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">return</span> instence;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instence = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> Singleton::mutex;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法：<strong>内部静态变量</strong>，在全局访问点 <code>getInstance</code> 中定义静态实例。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; temp)&#123;&#125;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp; temp)&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* <span class="built_in">getInstence</span>()&#123; </span><br><span class="line">        <span class="type">static</span> Singleton instence;</span><br><span class="line">        <span class="keyword">return</span> &amp;instence;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">pthread_mutex_t</span> Singleton::mutex; </span><br></pre></td></tr></table></figure>

<ul>
<li>饿汉模式的实现：饿汉模式本身就是线程安全的不用加锁。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instence;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; temp)&#123;&#125;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp; temp)&#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	 <span class="built_in">Singleton</span>()&#123;&#125; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* <span class="built_in">getInstence</span>()&#123; </span><br><span class="line">        <span class="keyword">return</span> instence;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::instence = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="工厂模式及其实现"><a href="#工厂模式及其实现" class="headerlink" title="工厂模式及其实现"></a>工厂模式及其实现</h4><ul>
<li><p>工厂模式：包括简单工厂模式、抽象工厂模式、工厂方法模式。</p>
</li>
<li><p>简单工厂模式：主要用于创建对象。用一个工厂来根据输入的条件产生不同的类，然后根据不同类的虚函数得到不同的结果。</p>
<ul>
<li>应用场景：适用于针对不同情况创建不同类时，只需传入工厂类的参数即可，无需了解具体实现方法。例如：计算器中对于同样的输入，执行不同的操作：加、减、乘、除。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here is the product class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operation</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> var1, var2;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add_Operation</span> : <span class="keyword">public</span> Operation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 + var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub_Operation</span> : <span class="keyword">public</span> Operation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 - var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mul_Operation</span> : <span class="keyword">public</span> Operation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 * var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Div_Operation</span> : <span class="keyword">public</span> Operation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 / var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here is the Factory class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Operation *<span class="title">CreateProduct</span><span class="params">(<span class="type">char</span> op)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (op)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Add_Operation</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Sub_Operation</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Mul_Operation</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Div_Operation</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Add_Operation</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    Operation *p = Factory::<span class="built_in">CreateProduct</span>(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">    p-&gt;var1 = a;</span><br><span class="line">    p-&gt;var2 = b;</span><br><span class="line">    cout &lt;&lt; p-&gt;<span class="built_in">GetResult</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    p = Factory::<span class="built_in">CreateProduct</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    p-&gt;var1 = a;</span><br><span class="line">    p-&gt;var2 = b;</span><br><span class="line">    cout &lt;&lt; p-&gt;<span class="built_in">GetResult</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>工厂方法模式：修正了简单工厂模式中不遵守开放封闭原则。把选择判断移到了客户端去实现，如果想添加新功能就不用修改原来的类，直接修改客户端即可。</p>
<ul>
<li>应用场景：<ul>
<li>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</li>
<li>一个类通过其派生类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其派生类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，派生类对象将覆盖父类对象，从而使得系统更容易扩展。</li>
<li>将创建对象的任务委托给多个工厂派生类中的某一个，客户端在使用时可以无须关心是哪一个工厂派生类创建产品派生类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here is the product class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operation</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> var1, var2;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add_Operation</span> : <span class="keyword">public</span> Operation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 + var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub_Operation</span> : <span class="keyword">public</span> Operation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 - var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mul_Operation</span> : <span class="keyword">public</span> Operation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 * var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Div_Operation</span> : <span class="keyword">public</span> Operation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 / var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Operation *<span class="title">CreateProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add_Factory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Operation *<span class="title">CreateProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Add_Operation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub_Factory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Operation *<span class="title">CreateProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Sub_Operation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mul_Factory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Operation *<span class="title">CreateProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Mul_Operation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Div_Factory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Operation *<span class="title">CreateProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Div_Operation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    Add_Factory *p_fac = <span class="keyword">new</span> <span class="built_in">Add_Factory</span>();</span><br><span class="line">    Operation *p_pro = p_fac-&gt;<span class="built_in">CreateProduct</span>();</span><br><span class="line">    p_pro-&gt;var1 = a;</span><br><span class="line">    p_pro-&gt;var2 = b;</span><br><span class="line">    cout &lt;&lt; p_pro-&gt;<span class="built_in">GetResult</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Mul_Factory *p_fac1 = <span class="keyword">new</span> <span class="built_in">Mul_Factory</span>();</span><br><span class="line">    Operation *p_pro1 = p_fac1-&gt;<span class="built_in">CreateProduct</span>();</span><br><span class="line">    p_pro1-&gt;var1 = a;</span><br><span class="line">    p_pro1-&gt;var2 = b;</span><br><span class="line">    cout &lt;&lt; p_pro1-&gt;<span class="built_in">GetResult</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>抽象工厂模式：定义了一个创建一系列相关或相互依赖的接口，而无需指定他们的具体类。</p>
<ul>
<li>应用场景：<ul>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。</li>
<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。</li>
<li>产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here is the product class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operation_Pos</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> var1, var2;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add_Operation_Pos</span> : <span class="keyword">public</span> Operation_Pos</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 + var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub_Operation_Pos</span> : <span class="keyword">public</span> Operation_Pos</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 - var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mul_Operation_Pos</span> : <span class="keyword">public</span> Operation_Pos</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 * var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Div_Operation_Pos</span> : <span class="keyword">public</span> Operation_Pos</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 / var2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operation_Neg</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> var1, var2;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add_Operation_Neg</span> : <span class="keyword">public</span> Operation_Neg</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -(var1 + var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub_Operation_Neg</span> : <span class="keyword">public</span> Operation_Neg</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -(var1 - var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mul_Operation_Neg</span> : <span class="keyword">public</span> Operation_Neg</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -(var1 * var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Div_Operation_Neg</span> : <span class="keyword">public</span> Operation_Neg</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">GetResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -(var1 / var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Here is the Factory class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Operation_Pos *<span class="title">CreateProduct_Pos</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Operation_Neg *<span class="title">CreateProduct_Neg</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add_Factory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Operation_Pos *<span class="title">CreateProduct_Pos</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Add_Operation_Pos</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Operation_Neg *<span class="title">CreateProduct_Neg</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Add_Operation_Neg</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub_Factory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Operation_Pos *<span class="title">CreateProduct_Pos</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Sub_Operation_Pos</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Operation_Neg *<span class="title">CreateProduct_Neg</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Sub_Operation_Neg</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mul_Factory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Operation_Pos *<span class="title">CreateProduct_Pos</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Mul_Operation_Pos</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Operation_Neg *<span class="title">CreateProduct_Neg</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Mul_Operation_Neg</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Div_Factory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Operation_Pos *<span class="title">CreateProduct_Pos</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Div_Operation_Pos</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Operation_Neg *<span class="title">CreateProduct_Neg</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Div_Operation_Neg</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    Add_Factory *p_fac = <span class="keyword">new</span> <span class="built_in">Add_Factory</span>();</span><br><span class="line">    Operation_Pos *p_pro = p_fac-&gt;<span class="built_in">CreateProduct_Pos</span>();</span><br><span class="line">    p_pro-&gt;var1 = a;</span><br><span class="line">    p_pro-&gt;var2 = b;</span><br><span class="line">    cout &lt;&lt; p_pro-&gt;<span class="built_in">GetResult</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Add_Factory *p_fac1 = <span class="keyword">new</span> <span class="built_in">Add_Factory</span>();</span><br><span class="line">    Operation_Neg *p_pro1 = p_fac1-&gt;<span class="built_in">CreateProduct_Neg</span>();</span><br><span class="line">    p_pro1-&gt;var1 = a;</span><br><span class="line">    p_pro1-&gt;var2 = b;</span><br><span class="line">    cout &lt;&lt; p_pro1-&gt;<span class="built_in">GetResult</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="观察者模式及其实现"><a href="#观察者模式及其实现" class="headerlink" title="观察者模式及其实现"></a>观察者模式及其实现</h4><ul>
<li>观察者模式：定义一种一（被观察类）对多（观察类）的关系，让多个观察对象同时监听一个被观察对象，被观察对象状态发生变化时，会通知所有的观察对象，使他们能够更新自己的状态。</li>
<li>观察者模式中存在两种角色：<ul>
<li>观察者：内部包含被观察者对象，当被观察者对象的状态发生变化时，更新自己的状态。（接收通知更新状态）</li>
<li>被观察者：内部包含了所有观察者对象，当状态发生变化时通知所有的观察者更新自己的状态。（发送通知）</li>
</ul>
</li>
<li>应用场景：<ul>
<li>当一个对象的改变需要同时改变其他对象，且不知道具体有多少对象有待改变时，应该考虑使用观察者模式；</li>
<li>一个抽象模型有两个方面，其中一方面依赖于另一方面，这时可以用观察者模式将这两者封装在独立的对象中使它们各自独立地改变和复用。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span>;</span><br><span class="line"><span class="comment">//观察者 基类 （内部实例化了被观察者的对象sub）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string name;</span><br><span class="line">    Subject *sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Observer</span>(string name, Subject *sub)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;sub = sub;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StockObserver</span> : <span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StockObserver</span>(string name, Subject *sub) : <span class="built_in">Observer</span>(name, sub)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NBAObserver</span> : <span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NBAObserver</span>(string name, Subject *sub) : <span class="built_in">Observer</span>(name, sub)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//被观察者 基类 （内部存放了所有的观察者对象，以便状态发生变化时，给观察者发通知）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    list&lt;Observer *&gt; observers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string action; <span class="comment">//被观察者对象的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">attach</span><span class="params">(Observer *)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">detach</span><span class="params">(Observer *)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">notify</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Secretary</span> : <span class="keyword">public</span> Subject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">attach</span><span class="params">(Observer *observer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        observers.<span class="built_in">push_back</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">detach</span><span class="params">(Observer *observer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        list&lt;Observer *&gt;::iterator iter = observers.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (iter != observers.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*iter) == observer)</span><br><span class="line">            &#123;</span><br><span class="line">                observers.<span class="built_in">erase</span>(iter);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++iter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        list&lt;Observer *&gt;::iterator iter = observers.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (iter != observers.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            (*iter)-&gt;<span class="built_in">update</span>();</span><br><span class="line">            ++iter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StockObserver::update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot; 收到消息：&quot;</span> &lt;&lt; sub-&gt;action &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (sub-&gt;action == <span class="string">&quot;梁所长来了!&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我马上关闭股票，装做很认真工作的样子！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NBAObserver::update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot; 收到消息：&quot;</span> &lt;&lt; sub-&gt;action &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (sub-&gt;action == <span class="string">&quot;梁所长来了!&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我马上关闭NBA，装做很认真工作的样子！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Subject *dwq = <span class="keyword">new</span> <span class="built_in">Secretary</span>();</span><br><span class="line">    Observer *xs = <span class="keyword">new</span> <span class="built_in">NBAObserver</span>(<span class="string">&quot;xiaoshuai&quot;</span>, dwq);</span><br><span class="line">    Observer *zy = <span class="keyword">new</span> <span class="built_in">NBAObserver</span>(<span class="string">&quot;zouyue&quot;</span>, dwq);</span><br><span class="line">    Observer *lm = <span class="keyword">new</span> <span class="built_in">StockObserver</span>(<span class="string">&quot;limin&quot;</span>, dwq);</span><br><span class="line"></span><br><span class="line">    dwq-&gt;<span class="built_in">attach</span>(xs);</span><br><span class="line">    dwq-&gt;<span class="built_in">attach</span>(zy);</span><br><span class="line">    dwq-&gt;<span class="built_in">attach</span>(lm);</span><br><span class="line"></span><br><span class="line">    dwq-&gt;action = <span class="string">&quot;去吃饭了！&quot;</span>;</span><br><span class="line">    dwq-&gt;<span class="built_in">notify</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    dwq-&gt;action = <span class="string">&quot;梁所长来了!&quot;</span>;</span><br><span class="line">    dwq-&gt;<span class="built_in">notify</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/202307192211377.png" target="_blank"><img class="post-qr-code-img" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/202307192211377.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/202307192207910.png" target="_blank"><img class="post-qr-code-img" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/202307192207910.png" alt="alipayautoh"/></a><div class="post-qr-code-desc">alipayautoh</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://acall.love/2023/06/10/3.C++%20%E9%9D%A2%E8%AF%95%E7%AA%81%E7%A0%B4/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=undefined&amp;url=http://acall.love/2023/06/10/3.C++%20%E9%9D%A2%E8%AF%95%E7%AA%81%E7%A0%B4/&amp;pic=undefined" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/C/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>C++<span class="tagsPageCount">23</span></a><a class="post-meta__box__tags" href="/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>后端开发<span class="tagsPageCount">22</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/d6g1gl.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><div class="post-copyright"><i class="anzhiyufont anzhiyu-icon-copyright"></i><div class="post-copyright__author"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://acall.love/2023/06/10/3.C++%20%E9%9D%A2%E8%AF%95%E7%AA%81%E7%A0%B4/">原创</a><a class="post-copyright-title"><span>3.面试突破</span></a></div><div class="post-copyright-info-box"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"></span><a class="link" href="http://acall.love">🎵张小佑♪</a></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a class="link" href="http://acall.love/2023/06/10/3.C++%20%E9%9D%A2%E8%AF%95%E7%AA%81%E7%A0%B4/">http://acall.love/2023/06/10/3.C++%20%E9%9D%A2%E8%AF%95%E7%AA%81%E7%A0%B4/</a></span><span class="copy-button" onclick="rm.copyPageUrl('http://acall.love/2023/06/10/3.C++%20%E9%9D%A2%E8%AF%95%E7%AA%81%E7%A0%B4/')"><i class="anzhiyufont anzhiyu-icon-copy"></i></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://acall.love" target="_blank">♪张小佑</a>！</span></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/06/05/2.C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/gp5k23.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2.C++读书笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/06/01/1.C++%E5%B2%97%E4%BD%8D%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E5%AE%9D%E5%85%B8/" title="1.C++岗位面试真题宝典"><img class="cover" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/iTab-p92mj3%20(2).webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-06-01</div><div class="title">1.C++岗位面试真题宝典</div></div></a></div><div><a href="/2023/05/01/1.%E4%B8%AA%E4%BA%BA%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/" title="1.个人问题"><img class="cover" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/p9918p.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-05-01</div><div class="title">1.个人问题</div></div></a></div><div><a href="/2023/06/05/2.C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="2.C++读书笔记"><img class="cover" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/gp5k23.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-06-05</div><div class="title">2.C++读书笔记</div></div></a></div><div><a href="/2023/05/05/2.%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F%E7%AC%94%E8%AE%B0/" title="2.极客笔记"><img class="cover" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/o5g6r7.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-05-05</div><div class="title">2.极客笔记</div></div></a></div><div><a href="/2023/01/05/day02%E7%AC%94%E8%AE%B0/" title="2.C++入门"><img class="cover" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/001.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-01-05</div><div class="title">2.C++入门</div></div></a></div><div><a href="/2023/01/10/day03%E7%AC%94%E8%AE%B0/" title="3.C++入门"><img class="cover" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/1pqq1w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-01-10</div><div class="title">3.C++入门</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E9%9D%A2%E8%AF%95%E7%AA%81%E7%A0%B4"><span class="toc-number">1.</span> <span class="toc-text">C++ 面试突破</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%BC%96%E8%AF%91%E4%B8%8E%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3"><span class="toc-number">1.1.</span> <span class="toc-text">C++ 编译与内存相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91"><span class="toc-number">1.1.1.</span> <span class="toc-text">C++ 程序编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.2.</span> <span class="toc-text">C++ 内存管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E4%B8%8E%E6%A0%88"><span class="toc-number">1.1.3.</span> <span class="toc-text">堆与栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.4.</span> <span class="toc-text">变量定义与生存周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="toc-number">1.1.5.</span> <span class="toc-text">内存对齐</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%AB%AF"><span class="toc-number">1.1.6.</span> <span class="toc-text">大端与小端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">1.1.7.</span> <span class="toc-text">内存泄漏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%A2%84%E9%98%B2"><span class="toc-number">1.1.8.</span> <span class="toc-text">内存泄漏检测与预防</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AE%80%E4%BB%8B%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.9.</span> <span class="toc-text">智能指针简介与使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.1.10.</span> <span class="toc-text">智能指针的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#include-%E2%80%9C-%E2%80%9C-%E5%92%8C-lt-gt-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.11.</span> <span class="toc-text">include “ “ 和 &lt;&gt; 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E8%AF%AD%E8%A8%80%E5%AF%B9%E6%AF%94"><span class="toc-number">1.2.</span> <span class="toc-text">C++ 语言对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%92%8C-C-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.2.1.</span> <span class="toc-text">C 和 C++ 的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E5%92%8C-C-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.2.2.</span> <span class="toc-text">Java 和 C++ 的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-%E5%92%8C-C-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.2.3.</span> <span class="toc-text">Python 和 C++ 的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-11-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.4.</span> <span class="toc-text">C++ 11 新特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-14-C-17-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.5.</span> <span class="toc-text">C++ 14, C++ 17 新特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">C++ 关键字与关键库函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sizeof-%E5%92%8C-strlen-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.1.</span> <span class="toc-text">sizeof 和 strlen 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">lambda 表达式的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#explicit-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">explicit 的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%92%8C-C-static-%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.4.</span> <span class="toc-text">C 和 C++ static 中的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const-%E4%BD%9C%E7%94%A8%E5%8F%8A%E7%94%A8%E6%B3%95"><span class="toc-number">1.3.5.</span> <span class="toc-text">const 作用及用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#define-%E5%92%8C-const-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.6.</span> <span class="toc-text">define 和 const 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#define-%E5%92%8C-typedef-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.7.</span> <span class="toc-text">define 和 typedef 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E5%AE%8F%E5%AE%9E%E7%8E%B0%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%A4%E4%B8%AA%E6%95%B0%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">1.3.8.</span> <span class="toc-text">用宏实现比较大小，以及两个数中的最小值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#inline-%E4%BD%9C%E7%94%A8%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.9.</span> <span class="toc-text">inline 作用及使用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#inline-%E5%87%BD%E6%95%B0%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.10.</span> <span class="toc-text">inline 函数工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89%EF%BC%88define%EF%BC%89%E5%92%8C%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%EF%BC%88inline%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.11.</span> <span class="toc-text">宏定义（define）和内联函数（inline）的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.12.</span> <span class="toc-text">new 的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-%E5%92%8C-malloc-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.13.</span> <span class="toc-text">new 和 malloc 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#delete-%E4%B8%8E-free-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.14.</span> <span class="toc-text">delete 与 free 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%92%8C-C-struct-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.15.</span> <span class="toc-text">C 和 C++ struct 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-%E5%92%8C-union-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.16.</span> <span class="toc-text">struct 和 union 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#class-%E5%92%8C-struct-%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">1.3.17.</span> <span class="toc-text">class 和 struct 的异同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.3.18.</span> <span class="toc-text">volatile 的作用与使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%87%BD%E6%95%B0%E4%B8%AD%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%9C%B0%E5%9D%80%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-number">1.3.19.</span> <span class="toc-text">返回函数中静态变量的地址会发生什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#extern-C-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.20.</span> <span class="toc-text">extern C 的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sizeof-1-x3D-x3D-1-%E5%9C%A8-C-%E5%92%8C-C-%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="toc-number">1.3.21.</span> <span class="toc-text">sizeof(1&#x3D;&#x3D;1) 在 C 和 C++ 中的结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#memmove-%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.22.</span> <span class="toc-text">memmove 函数的底层原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strcpy-%E5%87%BD%E6%95%B0%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-number">1.3.23.</span> <span class="toc-text">strcpy 函数的缺陷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#auto-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.24.</span> <span class="toc-text">auto 类型推导的原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.4.</span> <span class="toc-text">C++ 面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">1.4.1.</span> <span class="toc-text">面向对象及其三大特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%E3%80%81%E9%9A%90%E8%97%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.2.</span> <span class="toc-text">重载、重写、隐藏的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.3.</span> <span class="toc-text">多态及其实现方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E9%99%90%E5%88%B6%E5%9C%A8%E5%A0%86%E6%88%96%E6%A0%88"><span class="toc-number">1.4.4.</span> <span class="toc-text">对象创建限制在堆或栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B"><span class="toc-number">1.4.5.</span> <span class="toc-text">C++ 模板编程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.4.6.</span> <span class="toc-text">虚函数和纯虚函数详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.7.</span> <span class="toc-text">虚函数和纯虚函数的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.8.</span> <span class="toc-text">虚函数的实现机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.9.</span> <span class="toc-text">单继承和多继承的虚函数表结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.10.</span> <span class="toc-text">如何禁止构造函数的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.11.</span> <span class="toc-text">什么是类的默认构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E6%88%90%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.12.</span> <span class="toc-text">构造函数、析构函数是否可以定义成虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.4.13.</span> <span class="toc-text">如何避免拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BC%80%E9%94%80"><span class="toc-number">1.4.14.</span> <span class="toc-text">如何减少构造函数开销</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E9%81%BF%E5%85%8D%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.15.</span> <span class="toc-text">多重继承的常见问题及避免方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E7%B1%BB%E5%AD%97%E8%8A%82%E6%95%B0%E5%8F%8A%E5%AF%B9%E5%BA%94%E7%94%9F%E6%88%90%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.16.</span> <span class="toc-text">空类字节数及对应生成的成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.4.17.</span> <span class="toc-text">类的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E5%A3%B0%E6%98%8E%E4%B8%BA%E5%BC%95%E7%94%A8"><span class="toc-number">1.4.18.</span> <span class="toc-text">为什么拷贝构造函数必须声明为引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.4.19.</span> <span class="toc-text">C++ 类对象的初始化顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2%E4%B8%80%E4%B8%AA%E7%B1%BB%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">1.4.20.</span> <span class="toc-text">如何禁止一个类被实例化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E6%95%88%E7%8E%87%E9%AB%98%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.4.21.</span> <span class="toc-text">成员初始化列表效率高的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E9%9C%80%E8%A6%81%E5%93%AA%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="toc-number">1.4.22.</span> <span class="toc-text">实例化一个对象需要哪几个阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.4.23.</span> <span class="toc-text">友元函数的作用及使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.24.</span> <span class="toc-text">静态绑定和动态绑定的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.25.</span> <span class="toc-text">深拷贝和浅拷贝的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E5%A4%9A%E6%80%81%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.26.</span> <span class="toc-text">编译时多态和运行时多态的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%85%81%E8%AE%B8%E4%BF%AE%E6%94%B9%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.27.</span> <span class="toc-text">不允许修改类的成员变量的函数实现方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E7%B1%BB%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF"><span class="toc-number">1.4.28.</span> <span class="toc-text">如何让类不能被继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E7%9B%B8%E5%85%B3"><span class="toc-number">1.5.</span> <span class="toc-text">C++ 语言特性相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%EF%BC%9A%E5%8C%BA%E5%88%AB%E3%80%81%E5%BC%95%E7%94%A8%E5%8F%8A%E8%BD%AC%E5%8C%96"><span class="toc-number">1.5.1.</span> <span class="toc-text">左值和右值：区别、引用及转化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#std-move-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.2.</span> <span class="toc-text">std::move() 函数的实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%8F%8A%E5%85%B6%E5%A4%A7%E5%B0%8F%E3%80%81%E7%94%A8%E6%B3%95"><span class="toc-number">1.5.3.</span> <span class="toc-text">指针及其大小、用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8E%E6%8C%87%E9%92%88%E5%92%8C%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.5.4.</span> <span class="toc-text">野指针和悬空指针详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-11-nullptr-%E6%AF%94-NULL-%E7%9A%84%E4%BC%98%E5%8A%BF%E6%AF%94%E8%BE%83"><span class="toc-number">1.5.5.</span> <span class="toc-text">C++ 11 nullptr 比 NULL 的优势比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.6.</span> <span class="toc-text">指针和引用的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.7.</span> <span class="toc-text">常量指针和指针常量的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.5.8.</span> <span class="toc-text">函数指针的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.9.</span> <span class="toc-text">强制类型转换的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9B%B8%E7%AD%89%E7%9A%84%E5%88%A4%E6%96%AD%E6%96%B9%E5%BC%8F%E5%8F%8A-memcmp-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.10.</span> <span class="toc-text">结构体相等的判断方式及 memcmp 函数的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E4%B8%AD%EF%BC%9A%E5%80%BC%E4%BC%A0%E9%80%92%E3%80%81%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E3%80%81%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.11.</span> <span class="toc-text">参数传递中：值传递、引用传递、指针传递的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.12.</span> <span class="toc-text">模板及其实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%92%8C%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.13.</span> <span class="toc-text">函数模板和类模板的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.5.14.</span> <span class="toc-text">什么是可变参数模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96"><span class="toc-number">1.5.15.</span> <span class="toc-text">什么是模板特化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#switch-%E7%9A%84-case-%E9%87%8C%E4%B8%BA%E4%BD%95%E4%B8%8D%E5%BB%BA%E8%AE%AE%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.16.</span> <span class="toc-text">switch 的 case 里为何不建议定义变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.5.17.</span> <span class="toc-text">迭代器的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.18.</span> <span class="toc-text">泛型编程如何实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E8%90%83%E5%8F%96"><span class="toc-number">1.5.19.</span> <span class="toc-text">什么是类型萃取</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-I-x2F-O-%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.6.</span> <span class="toc-text">C++ I&#x2F;O 与进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-I-x2F-O-%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.1.</span> <span class="toc-text">C++ I&#x2F;O 操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5"><span class="toc-number">1.6.2.</span> <span class="toc-text">线程同步与异步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E4%BA%92%E6%96%A5%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.6.3.</span> <span class="toc-text">C++ 互斥信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">1.6.4.</span> <span class="toc-text">C++ 条件变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.1.</span> <span class="toc-text">常见设计模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.2.</span> <span class="toc-text">单例模式及其实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.3.</span> <span class="toc-text">工厂模式及其实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.4.</span> <span class="toc-text">观察者模式及其实现</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 🎵张小佑♪</div></div></footer></div></div></div><div id="sidebar"><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child" style="left:17px;"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li></ul></div></div></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.4.0/source/js/utils.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.4.0/source/js/main.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.4.0/source/js/tw_cn.js"></script><script src="https://npm.elemecdn.com/@fancyapps/ui@4.0.31/dist/fancybox.umd.js"></script><script src="https://npm.elemecdn.com/instant.page@5.1.1/instantpage.js" type="module"></script><script src="https://npm.elemecdn.com/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://npm.elemecdn.com/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("09/01/2022 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2022 By 安知鱼 1.4.0",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 🎵张小佑♪ 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anheyu.com";</script><script>//动态标题
let leaveTitle = '♪张小佑 - 分享思考与科技生活';
let backTitle = '♪张小佑 - 分享思考与科技生活';
let OriginTitile = document.title
let titleTime
document.addEventListener('visibilitychange', function () {
  if (document.hidden) {
    //离开当前页面时标签显示内容
    document.title = leaveTitle
    clearTimeout(titleTime)
  } else {
    //返回当前页面时标签显示内容
    document.title = backTitle + OriginTitile
    //两秒后变回正常标题
    titleTime = setTimeout(function () {
      document.title = OriginTitile
    }, 2000)
  }
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script>// 初始化函数
let rm = {};

//禁止图片与超链接拖拽
let aElements = document.getElementsByTagName("a");
for (let i = 0; i < aElements.length; i++) {
  aElements[i].setAttribute("draggable", "false");
  let imgElements = aElements[i].getElementsByTagName("img");
  for (let j = 0; j < imgElements.length; j++) {
    imgElements[j].setAttribute("draggable", "false");
  }
}

// 显示菜单
rm.showRightMenu = function (isTrue, x = 0, y = 0) {
  console.info(x, y)
  let rightMenu = document.getElementById("rightMenu");
  rightMenu.style.top = x + "px";
  rightMenu.style.left = y + "px";
  if (isTrue) {
    rightMenu.style.display = "block";
    stopMaskScroll();
  } else {
    rightMenu.style.display = "none";
  }
};

// 隐藏菜单
rm.hideRightMenu = function () {
  rm.showRightMenu(false);
  let rightMenuMask = document.querySelector("#rightmenu-mask");
  rightMenuMask.style.display = "none";
};

// 尺寸
let rmWidth = document.getElementById("rightMenu").offsetWidth;
let rmHeight = document.getElementById("rightMenu").offsetHeight;

// 重新定义尺寸
rm.reloadrmSize = function () {
  rightMenu.style.visibility = "hidden";
  rightMenu.style.display = "block";
  // 获取宽度和高度
  rmWidth = document.getElementById("rightMenu").offsetWidth;
  rmHeight = document.getElementById("rightMenu").offsetHeight;
  rightMenu.style.visibility = "visible";
};

// 获取点击的href
let domhref = "";
let domImgSrc = "";
let globalEvent = null;

var oncontextmenuFunction = function (event) {
  if (document.body.clientWidth > 768) {
    let pageX = event.clientX + 10; //加10是为了防止显示时鼠标遮在菜单上
    let pageY = event.clientY;

    //其他额外菜单
    const $rightMenuOther = document.querySelector(".rightMenuOther");
    const $rightMenuPlugin = document.querySelector(".rightMenuPlugin");
    const $rightMenuCopyText = document.querySelector("#menu-copytext");
    const $rightMenuPasteText = document.querySelector("#menu-pastetext");
    const $rightMenuCommentText = document.querySelector("#menu-commenttext");
    const $rightMenuNewWindow = document.querySelector("#menu-newwindow");
    const $rightMenuNewWindowImg = document.querySelector("#menu-newwindowimg");
    const $rightMenuCopyLink = document.querySelector("#menu-copylink");
    const $rightMenuCopyImg = document.querySelector("#menu-copyimg");
    const $rightMenuDownloadImg = document.querySelector("#menu-downloadimg");
    const $rightMenuSearch = document.querySelector("#menu-search");
    const $rightMenuSearchBaidu = document.querySelector("#menu-searchBaidu");
    const $rightMenuMusicToggle = document.querySelector("#menu-music-toggle");
    const $rightMenuMusicBack = document.querySelector("#menu-music-back");
    const $rightMenuMusicForward = document.querySelector("#menu-music-forward");
    const $rightMenuMusicPlaylist = document.querySelector("#menu-music-playlist");
    const $rightMenuMusicCopyMusicName = document.querySelector("#menu-music-copyMusicName");

    let href = event.target.href;
    let imgsrc = event.target.currentSrc;

    // 判断模式 扩展模式为有事件
    let pluginMode = false;
    $rightMenuOther.style.display = "block";
    globalEvent = event;

    // 检查是否需要复制 是否有选中文本
    if (selectTextNow && window.getSelection()) {
      pluginMode = true;
      $rightMenuCopyText.style.display = "block";
      $rightMenuCommentText.style.display = "block";
      $rightMenuSearch.style.display = "block";
      $rightMenuSearchBaidu.style.display = "block";
    } else {
      $rightMenuCopyText.style.display = "none";
      $rightMenuCommentText.style.display = "none";
      $rightMenuSearchBaidu.style.display = "none";
      $rightMenuSearch.style.display = "none";
    }

    //检查是否右键点击了链接a标签
    if (href) {
      pluginMode = true;
      $rightMenuNewWindow.style.display = "block";
      $rightMenuCopyLink.style.display = "block";
      domhref = href;
    } else {
      $rightMenuNewWindow.style.display = "none";
      $rightMenuCopyLink.style.display = "none";
    }

    //检查是否需要复制图片
    if (imgsrc) {
      pluginMode = true;
      $rightMenuCopyImg.style.display = "block";
      $rightMenuDownloadImg.style.display = "block";
      $rightMenuNewWindowImg.style.display = "block";
      document.getElementById("rightMenu").style.width="12rem"
      domImgSrc = imgsrc;
    } else {
      $rightMenuCopyImg.style.display = "none";
      $rightMenuDownloadImg.style.display = "none";
      $rightMenuNewWindowImg.style.display = "none";
    }

    // 判断是否为输入框
    if (event.target.tagName.toLowerCase() === "input" || event.target.tagName.toLowerCase() === "textarea") {
      pluginMode = true;
      $rightMenuPasteText.style.display = "block";
    } else {
      $rightMenuPasteText.style.display = "none";
    }
    const navMusicEl = document.querySelector("#nav-music");
    //判断是否是音乐
    if (navMusicEl && navMusicEl.contains(event.target)) {
      pluginMode = true;
      $rightMenuMusicToggle.style.display = "block";
      $rightMenuMusicBack.style.display = "block";
      $rightMenuMusicForward.style.display = "block";
      $rightMenuMusicPlaylist.style.display = "block";
      $rightMenuMusicCopyMusicName.style.display = "block";
    } else {
      $rightMenuMusicToggle.style.display = "none";
      $rightMenuMusicBack.style.display = "none";
      $rightMenuMusicForward.style.display = "none";
      $rightMenuMusicPlaylist.style.display = "none";
      $rightMenuMusicCopyMusicName.style.display = "none";
    }

    // 如果不是扩展模式则隐藏扩展模块
    if (pluginMode) {
      $rightMenuOther.style.display = "none";
      $rightMenuPlugin.style.display = "block";
    } else {
      $rightMenuPlugin.style.display = "none";
    }

    rm.reloadrmSize();

    // 鼠标默认显示在鼠标右下方，当鼠标靠右或靠下时，将菜单显示在鼠标左方\上方
    if (pageX + rmWidth > window.innerWidth) {
      pageX -= rmWidth + 10;
    }
    if (pageY + rmHeight > window.innerHeight) {
      pageY -= pageY + rmHeight - window.innerHeight;
    }

    rm.showRightMenu(true, pageY, pageX);
    document.getElementById("rightmenu-mask").style.display = "flex";
    return false;
  }
};

// 监听右键初始化
window.oncontextmenu = oncontextmenuFunction

// 下载图片状态
rm.downloadimging = false;

// 复制图片到剪贴板
rm.writeClipImg = function (imgsrc) {
  console.log("按下复制");
  rm.hideRightMenu();
  anzhiyu.snackbarShow("正在下载中，请稍后", false, 10000);
  if (rm.downloadimging == false) {
    rm.downloadimging = true;
    setTimeout(function () {
      copyImage(imgsrc);
      anzhiyu.snackbarShow("复制成功！图片已添加盲水印，请遵守版权协议");
      rm.downloadimging = false;
    }, "10000");
  }
};

function imageToBlob(imageURL) {
  const img = new Image();
  const c = document.createElement("canvas");
  const ctx = c.getContext("2d");
  img.crossOrigin = "";
  img.src = imageURL;
  return new Promise(resolve => {
    img.onload = function () {
      c.width = this.naturalWidth;
      c.height = this.naturalHeight;
      ctx.drawImage(this, 0, 0);
      c.toBlob(
        blob => {
          // here the image is a blob
          resolve(blob);
        },
        "image/png",
        0.75
      );
    };
  });
}

async function copyImage(imageURL) {
  const blob = await imageToBlob(imageURL);
  const item = new ClipboardItem({ "image/png": blob });
  navigator.clipboard.write([item]);
}

rm.copyUrl = function (id) {
  const input = document.createElement("input"); // Create a new <input> element
  input.id = "copyVal"; // Set the id of the new element to "copyVal"
  document.body.appendChild(input); // Append the new element to the end of the <body> element
  
  const text = id;
  input.value = text;
  input.select();
  input.setSelectionRange(0, input.value.length);
  document.execCommand("copy");
  
  input.remove(); // Remove the <input> element from the DOM
};

function stopMaskScroll() {
  if (document.getElementById("rightmenu-mask")) {
    let xscroll = document.getElementById("rightmenu-mask");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      { passive: true }
    );
  }
  if (document.getElementById("rightMenu")) {
    let xscroll = document.getElementById("rightMenu");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      { passive: true }
    );
  }
}

rm.rightmenuCopyText = function (txt) {
  if (navigator.clipboard) {
    navigator.clipboard.writeText(txt);
  }
  rm.hideRightMenu();
};

rm.copyPageUrl = function (url) {
  if (!url) {
    url = window.location.href;
  }
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制本页链接地址成功", false, 2000);
  rm.hideRightMenu();
};

rm.sharePage = function () {
  var content = window.location.href;
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制本页链接地址成功", false, 2000);
  rm.hideRightMenu();
};

// 复制当前选中文本
var selectTextNow = "";
document.onmouseup = document.ondblclick = selceText;

function selceText() {
  var txt;
  if (document.selection) {
    txt = document.selection.createRange().text;
  } else {
    txt = window.getSelection().toString();
  }
  selectTextNow = txt !== "" ? txt : "";
}

// 读取剪切板
rm.readClipboard = function () {
  if (navigator.clipboard) {
    navigator.clipboard.readText().then(clipText => rm.insertAtCaret(globalEvent.target, clipText));
  }
};

// 粘贴文本到焦点
rm.insertAtCaret = function (elemt, value) {
  const startPos = elemt.selectionStart,
    endPos = elemt.selectionEnd;
  if (document.selection) {
    elemt.focus();
    var sel = document.selection.createRange();
    sel.text = value;
    elemt.focus();
  } else {
    if (startPos || startPos == "0") {
      var scrollTop = elemt.scrollTop;
      elemt.value = elemt.value.substring(0, startPos) + value + elemt.value.substring(endPos, elemt.value.length);
      elemt.focus();
      elemt.selectionStart = startPos + value.length;
      elemt.selectionEnd = startPos + value.length;
      elemt.scrollTop = scrollTop;
    } else {
      elemt.value += value;
      elemt.focus();
    }
  }
};

//粘贴文本
rm.pasteText = function () {
  const result = rm.readClipboard() || "";
  rm.hideRightMenu();
};

//引用到评论
rm.rightMenuCommentText = function (txt) {
  rm.hideRightMenu();
  const postCommentDom = document.getElementById("post-comment");
  var domTop = postCommentDom.offsetTop;
  window.scrollTo(0, domTop - 80);
  if (txt == "undefined" || txt == "null") txt = "好棒！";
  function setText() {
    setTimeout(() => {
      var input = document.getElementsByClassName("el-textarea__inner")[0];
      if (!input) setText();
      let evt = document.createEvent("HTMLEvents");
      evt.initEvent("input", true, true);
      let inputValue = replaceAll(txt, "\n", "\n> ");
      input.value = "> " + inputValue + "\n\n";
      input.dispatchEvent(evt);
      input.focus();
      input.setSelectionRange(-1, -1);
      if (document.getElementById("comment-tips")) {
        document.getElementById("comment-tips").classList.add("show");
      }
    }, 100);
  }
  setText();
};

//替换所有内容
function replaceAll(string, search, replace) {
  return string.split(search).join(replace);
}

// 百度搜索
rm.searchBaidu = function () {
  anzhiyu.snackbarShow("即将跳转到百度搜索", false, 2000);
  setTimeout(function () {
    window.open("https://www.baidu.com/s?wd=" + selectTextNow);
  }, "2000");
  rm.hideRightMenu();
};

//分享链接
rm.copyLink = function () {
  rm.rightmenuCopyText(domhref);
  anzhiyu.snackbarShow("已复制链接地址");
};

function addRightMenuClickEvent() {
  // 添加点击事件
  document.getElementById("menu-backward").addEventListener("click", function () {
  window.history.back();
    rm.hideRightMenu();
  });

  document.getElementById("menu-forward").addEventListener("click", function () {
    window.history.forward();
    rm.hideRightMenu();
  });

  document.getElementById("menu-refresh").addEventListener("click", function () {
    window.location.reload();
  });

  document.getElementById("menu-top").addEventListener("click", function () {
    anzhiyu.scrollToDest(0, 500);
    rm.hideRightMenu();
  });

  const menuLinks = document.querySelectorAll(".menu-link");
  menuLinks.forEach(function (link) {
    link.addEventListener("click", rm.hideRightMenu);
  });

  document.getElementById("menu-darkmode").addEventListener("click", anzhiyu.switchDarkMode);

  document.getElementById("menu-home") && document.getElementById("menu-home").addEventListener("click", function () {
    window.location.href = window.location.origin;
  });

  document.getElementById("menu-randomPost").addEventListener("click", function () {
    toRandomPost();
  });

  document.getElementById("menu-commentBarrage").addEventListener("click", anzhiyu.switchCommentBarrage);

  document.getElementById("rightmenu-mask").addEventListener("click", rm.hideRightMenu);

  document.getElementById("rightmenu-mask").addEventListener("contextmenu", function (event) {
    rm.hideRightMenu();
    event.preventDefault(); // Prevent the default context menu from appearing
  });

  document.getElementById("menu-copy").addEventListener("click", rm.copyPageUrl);

  document.getElementById("menu-pastetext").addEventListener("click", rm.pasteText);

  document.getElementById("menu-copytext").addEventListener("click", function () {
    rm.rightmenuCopyText(selectTextNow);
    anzhiyu.snackbarShow("复制成功，复制和转载请标注本文地址");
  });

  document.getElementById("menu-commenttext").addEventListener("click", function () {
    rm.rightMenuCommentText(selectTextNow);
  });

  document.getElementById("menu-newwindow").addEventListener("click", function () {
    window.open(domhref, "_blank");
    rm.hideRightMenu();
  });

  document.getElementById("menu-copylink").addEventListener("click", rm.copyLink);

  document.getElementById("menu-downloadimg").addEventListener("click", function () {
    anzhiyu.downloadImage(domImgSrc, "anzhiyu");
  });

  document.getElementById("menu-newwindowimg").addEventListener("click", function () {
    window.open(domImgSrc, "_blank");
    rm.hideRightMenu();
  });

  document.getElementById("menu-copyimg").addEventListener("click", function () {
    rm.writeClipImg(domImgSrc);
  });

  document.getElementById("menu-searchBaidu").addEventListener("click", rm.searchBaidu);

  //音乐
  document.getElementById("menu-music-toggle").addEventListener("click", anzhiyu.musicToggle);

  document.getElementById("menu-music-back").addEventListener("click", anzhiyu.musicSkipBack);

  document.getElementById("menu-music-forward").addEventListener("click", anzhiyu.musicSkipForward);

  document.getElementById("menu-music-copyMusicName").addEventListener("click", function () {
    rm.rightmenuCopyText(anzhiyu.musicGetName());
    anzhiyu.snackbarShow("复制歌曲名称成功", false, 3000);
  });

}

addRightMenuClickEvent();</script><script data-pjax>var themeColorMeta = document.querySelector('meta[name="theme-color"]');
var pageHeaderEl = document.getElementById("page-header");
var navMusicEl = document.getElementById("nav-music");
var consoleEl = document.getElementById("console");
// 已随机的歌曲
var selectRandomSong = [];
// 音乐默认声音大小
var musicVolume = 0.8;
// 是否切换了周杰伦音乐列表
var changeMusicListFlag = false;
// 当前默认播放列表
var defaultPlayMusicList = [];

document.getElementById("page-name").innerText = document.title.split(" | ♪张小佑")[0];
anzhiyu.initIndexEssay();
anzhiyu.changeTimeInEssay();
anzhiyu.removeBodyPaceClass();
anzhiyu.qrcodeCreate();
anzhiyu.changeTimeInAlbumDetail();
anzhiyu.reflashEssayWaterFall();
anzhiyu.sayhi();
anzhiyu.stopImgRightDrag();
anzhiyu.addNavBackgroundInit();
anzhiyu.setValueToBodyType();
anzhiyu.catalogActive();
anzhiyu.tagsPageActive();
anzhiyu.categoriesBarActive();
anzhiyu.topCategoriesBarScroll();
anzhiyu.switchRightClickMenuHotReview();
anzhiyu.getCustomPlayList();
anzhiyu.addEventListenerConsoleMusicList(false);
setTimeout(() => {
  if (typeof addFriendLinksInFooter === "function") {
    addFriendLinksInFooter();
  }
}, 200)</script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.1.4/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://npm.elemecdn.com/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://npm.elemecdn.com/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://npm.elemecdn.com/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>