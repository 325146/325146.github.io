<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>2.C++读书笔记 | ♪张小佑</title><meta name="keywords" content="C++"><meta name="author" content="🎵张小佑♪"><meta name="copyright" content="🎵张小佑♪"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="2.C++读书笔记"><meta name="application-name" content="2.C++读书笔记"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta name="description" content="积极学习C++吧！">
<meta property="og:type" content="article">
<meta property="og:title" content="2.C++读书笔记">
<meta property="og:url" content="http://acall.love/2023/06/05/2.C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="♪张小佑">
<meta property="og:description" content="积极学习C++吧！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/gp5k23.webp">
<meta property="article:published_time" content="2023-06-04T16:00:00.000Z">
<meta property="article:modified_time" content="2023-06-04T16:00:00.000Z">
<meta property="article:author" content="🎵张小佑♪">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="后端开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/gp5k23.webp"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://acall.love/2023/06/05/2.C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//npm.elemecdn.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://npm.elemecdn.com/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/@fancyapps/ui@4.0.31/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  friends_vue_info: undefined,
  navMusic: true,
  changeMainColorPost: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#3b70fc","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://npm.elemecdn.com/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://npm.elemecdn.com/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '2.C++读书笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-06-05 00:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/1.jpg"/><div class="loading-image-dot"></div><div id="loading-percentage">0%</div></div></div><script>const loadingPercentage = document.getElementById("loading-percentage");
let loadingPercentageTimer = setInterval(function() {
  var progressBar = document.querySelector(".pace-progress");
  if (!progressBar) return
  var currentValue = progressBar.getAttribute("data-progress-text");
  if (currentValue !== loadingPercentage.textContent) {
    loadingPercentage.textContent = currentValue;
    if (currentValue === "100%") {
      clearInterval(loadingPercentageTimer);
    }
  }
}, 100);
const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
    Pace.restart()
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/progress_bar/progress_bar.css"/><script async="async" src="https://npm.elemecdn.com/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div id="web_box"><div id="web_container"><div id="menu-mask"></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://acall.love/" title="博客" target="_blank"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" href="https://image.anheyu.com/" title="安知鱼图床" target="_blank"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">♪张小佑</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child" style="left:17px;"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/202307192211377.png" target="_blank"><img class="post-qr-code-img" alt="wechat" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/202307192211377.png"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/202307192207910.png" target="_blank"><img class="post-qr-code-img" alt="alipayautoh" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/202307192207910.png"/></a><div class="post-qr-code-desc">alipayautoh</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments" onclick="anzhiyu.hideConsole()"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> <span>最新评论</span></span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags" onclick="anzhiyu.hideConsole()"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>23</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" style="font-size: 1.05rem;">后端开发<sup>22</sup></a><a href="/tags/%E9%9D%A2%E7%BB%8F/" style="font-size: 1.05rem;">面经<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>3</sup></a></div></div><hr/></div></div><div class="console-card history" onclick="anzhiyu.hideConsole()"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">五月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">四月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/03/"><span class="card-archive-list-date">三月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/02/"><span class="card-archive-list-date">二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/01/"><span class="card-archive-list-date">一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" onclick="anzhiyu.switchDarkMode()" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div><div class="console-btn-item" id="consoleKeyboard" onclick="anzhiyu.keyboardToggle()" title="快捷键开关"><a class="keyboard-switch"><i class="anzhiyufont anzhiyu-icon-keyboard"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B6%AF/">大学生涯</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/C/" tabindex="-1"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>C++</span></a><a class="article-meta__tags" href="/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" tabindex="-1"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>后端开发</span></a></span></div></div><h1 class="post-title">2.C++读书笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-04T16:00:00.000Z" title="发表于 2023-06-05 00:00:00">2023-06-05</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-04T16:00:00.000Z" title="更新于 2023-06-05 00:00:00">2023-06-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">32.8k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>101分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="2.C++读书笔记"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为郑州"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>郑州</span></div></div></div><article class="post-content" id="article-container"><h1 id="C-读书笔记"><a href="#C-读书笔记" class="headerlink" title="C++ 读书笔记"></a>C++ 读书笔记</h1><h2 id="Effective-C"><a href="#Effective-C" class="headerlink" title="Effective C++"></a>Effective C++</h2><h3 id="习惯C"><a href="#习惯C" class="headerlink" title="习惯C++"></a>习惯C++</h3><h4 id="条款01：视C-为一个语言联邦"><a href="#条款01：视C-为一个语言联邦" class="headerlink" title="条款01：视C++为一个语言联邦"></a>条款01：视C++为一个语言联邦</h4><ul>
<li>一开始C++只是C加上面向对象的特性，如今的C++是一个多重范式的编程语言，一个同时支持过程形式、面向过程形式、函数形式、泛型形式、元编程形式；最简单的方法是将C++视为由一个相关语言组成的联邦而非单一语言</li>
<li>为了理解C++，其主要的次语言有以下几个<ul>
<li>C：说到底C++仍然是以C为基础</li>
<li>Object-Oriented C++：这也就是C with class 所诉求的，包括封装，继承，多态，virtual函数（动态绑定）等等。这一部分面向对象设计之古典守则在C++上最直接实施</li>
<li>Template C++：C++的泛型编程部分，他们的威力强大，可以带来模板元编程</li>
<li>STL：这是一个Template 程序库，他对于容器，迭代器，算法，函数对象的规则有着极佳的紧密配合和协调，然而templates 及程序库也可以其他想法建置出来。STL有着自己特殊的办事方式，你需要遵守它的约定</li>
</ul>
</li>
<li>C++高效编程守则视情况而变化，取决于你用C++的那一部分</li>
</ul>
<h4 id="条款02：尽量以const-enum-inline-替换-define（宁可以编译器替换预处理器）"><a href="#条款02：尽量以const-enum-inline-替换-define（宁可以编译器替换预处理器）" class="headerlink" title="条款02：尽量以const enum inline 替换#define（宁可以编译器替换预处理器）"></a>条款02：尽量以const enum inline 替换#define（宁可以编译器替换预处理器）</h4><ul>
<li><p>define不被视为语言的一部分</p>
<ul>
<li>宏定义是预处理阶段，会把相对应的值进行简单的替换，但是对应的名称可能不会进入记号表</li>
<li>宏定义不会被编译器看见，万一正好bug出现在#define这里，那么后面调试起来可能会很麻烦，尤其是代码量比较大的时候</li>
<li>#define可能导致目标码出现多次</li>
</ul>
</li>
<li><p>使用常量替换#define的时候的两个特殊情景</p>
<ul>
<li>情景1：定义常量指针<ul>
<li>常量表达式通常被放在头文件中，因此有必要将指针声明为const</li>
<li>对于char-based字符串：记得书写const两次：const char* const name&#x3D;”xxx”;</li>
<li>对于std：：string只用写一次：const std::string name&#x3D;”xxx”；一般使用string会好些</li>
</ul>
</li>
<li>情景2：class的专属常量<ul>
<li>为了将常量的作用域限制在class内，你必须让他称为class的一个成员；从而确保此常量至多只有一份实体，你必须让他称为一个static成员</li>
<li>对于class的专属常量又是static且为整数类型，只要不取他们的地址就可以只声明即使用他们而无需定义式</li>
</ul>
</li>
<li>#define并不重视作用域，一旦被定义其在之后的编译过程中都有效，除非遇到了#undef；所以其无法定义class的专属常量也不能提供任何封装性</li>
<li>如果编译器不允许上面的in-class做法，或者不太希望使用者去读取已经设定const的地址：可以采用下面的the enum hack补偿做法<ul>
<li>间接：把一个属于枚举类型的数值当数组用</li>
<li>好处：和#define类似：取地址不合法，和#define一样不会造成非必要的内存分配</li>
<li>其他：enum hack也是模板元编程的基础技术</li>
</ul>
</li>
</ul>
</li>
<li><p>误用#define去写宏(函数)</p>
<ul>
<li>一般情况下，虽然能用#define写类似函数的宏并不会带来额外的开销，但是在调用这个宏的时候可能会因为使用不当带来麻烦（需要注意小括号）</li>
<li>可以通过使用template inline，他不仅能获得宏带来的效率以及一般函数会遵守作用域和访问规则</li>
</ul>
</li>
<li><p>请记住：</p>
<ul>
<li>对于单纯变量，以const对象或enums将#defines替换之</li>
<li>对于形似函数的宏，使用inline函数替换#defines。</li>
</ul>
</li>
</ul>
<h4 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款03：尽可能使用const</h4><ul>
<li><p>const 的一件奇妙的事情是：允许你指定一个语义约束：（也就是一个”不该被改动的对象“，而编译器会强制施行这项约束；关键词const多才多艺，你可以用它来修饰各种你需要的东西</p>
<ul>
<li>const出现在星号左边表示被指物是常量，出现在星号右边表示指针自身是常量，出现在星号两边表示被指物和指针都是常量</li>
</ul>
</li>
<li><p>C++ Primer中const 的使用</p>
<ul>
<li>顶层const：<ul>
<li>在auto等部分语法中，顶层const往往都是可以被忽视的</li>
<li>顶层const往往都是固定了对应对象的本身</li>
<li>比如：<ul>
<li>const int a：顶层const</li>
<li>int*const a：顶层const</li>
</ul>
</li>
</ul>
</li>
<li>底层const<ul>
<li>底层const往往都是不能被忽视的。</li>
<li>比如<ul>
<li>const int *p：底层const</li>
<li>const char *const p：左边的是底层const，右边的是顶层const</li>
</ul>
</li>
</ul>
</li>
<li>对于指针来说，顶层或底层const取决于是否能改变对象（p）本身，能改变p为底层，不能改变p为顶层</li>
</ul>
</li>
<li><p>STL迭代器与const</p>
<ul>
<li>STL迭代器系以指针根据塑膜出来，所以迭代器的作用就像一个T*指针，声明一个const的迭代器也是具有相似的地方的，但是可能和普通指针就有点反直觉</li>
<li>const修饰迭代器的作用像是常量指针，const_iterator则是指针常量</li>
</ul>
</li>
<li><p>const与函数声明时候的应用</p>
<ul>
<li>令函数返回一个常量值，往往可以降低因客户错误而造成的意外，而又不至于放弃安全性和高效性</li>
<li>考虑下列情况<ul>
<li>举例，如果不加const将会导致（a*b）&#x3D;c这样的错误无法被找出</li>
<li>在C++11中，我们可以考虑使用右值。在重载运算符函数后面加上&amp;，&amp;&amp;说明此运算符只能作用于左值&#x2F;右值，防止出错</li>
</ul>
</li>
</ul>
</li>
<li><p>const和成员函数</p>
<ul>
<li>将const实施于成员函数的目的，是为了确认该成员函数可作用于const对象上，基于两个理由<ul>
<li>他们使得class结构比较容易理解。因为它可以得知那个函数可以改动对象内容而那个函数不行</li>
<li>他们使得操作const对象成为可能</li>
</ul>
</li>
<li>改善C++程序效率的一个根本方法是pass by reference to const方式传递对象，而此技术的前提就是有const成员函数可用来处理取得const对象</li>
<li>两个成员函数如果只是常量性不同（即函数有边有没有带const），可以被重载。这是一个重要的C++特性<ul>
<li>在C++11中，我们使用引用限定符也一样能区分函数是否重载，并能和const一起使用</li>
<li>通过增加引用限定符，方法与使用const成员函数相同，&amp;代表只可调用左值，&amp;&amp;代表只可调用右值，引用限定符必须跟在const限定符之后</li>
</ul>
</li>
</ul>
</li>
<li><p>bitwise constness和logical constness</p>
<ul>
<li>bitwise constness：const成员函数不可以更改对象内任何non-static成员变量，我们的编译器就遵循的是bitwise constness</li>
<li>logical constness：一个const成员函数可以修改它所处理对象内的某些bits，但只有客户端侦测不出的情况下的以如此。</li>
<li>虽然我们的编译器是bitwise constness，但是可能会导致logical constness的事情例如下面这个例子<ul>
<li>举例：你创建了一个常量对象并设以某值，而且只对他调用const成员函数，但是你终究还是改变了它的值</li>
<li>一个更改了”指针所指物“的成员函数虽然不能被叫做const，但是如果只有指针而非所指隶属物属于对象，那么此函数为bitwise const不会引发编译器争议，将导致反直观结果</li>
</ul>
</li>
<li>对于需要将传入部分const函数的值进行修改？可以考虑使用mutable，忽略编译器的bitwise constness的特性</li>
</ul>
</li>
<li><p>将const于非const的函数合并实现</p>
<ul>
<li>当我们使用const和非const的时候，函数的语句会有大量的重复，我们需要将他们合并，进行常量性转除</li>
<li>注意进行转型的时候，我们必须让非const版本调用const版本，反过来不行。</li>
</ul>
</li>
<li><p>请记住：</p>
<ul>
<li>将某些东西声明为const 可帮助编译器侦测出来错误的用法，const可以用于被施加于任何作用域内的对象，函数参数，函数返回类型，成员函数本体</li>
<li>编译器使用bitwise constness，但是你编写程序的时候应该使用“概念上的常量性”</li>
<li>当const和non-const成员函数有着实质等价的实现的时候，令non-const版本调用const版本可避免代码重复</li>
</ul>
</li>
</ul>
<h4 id="条款04：确定对象被使用前已先被初始化"><a href="#条款04：确定对象被使用前已先被初始化" class="headerlink" title="条款04：确定对象被使用前已先被初始化"></a>条款04：确定对象被使用前已先被初始化</h4><ul>
<li><p>关于“对象初始化这件事”，C++似乎反复无常，在某些语境下x保证被初始化为0，但是在其他语境中却不保证（array和vector的差别）。所以我们需要处理的办法就是：永远在使用对象之前先下手为强，将其初始化</p>
</li>
<li><p>对于无任何成员的内置类型，手动完成初始化时必要的，方式多变，你可以通过赋值，或者输入，但是一定需要完成</p>
</li>
<li><p>对于内置类型以外的东西，构造函数要确保每一个对象的成员全部都初始化</p>
<ul>
<li>区分常规的赋值与初始化<ul>
<li>赋值：对象中成员使用等于号（a&#x3D;b）一般就是进行赋值</li>
<li>初始化：直接使用括号（a(b)）就是初始化</li>
</ul>
</li>
<li>在构造函数中，我们可以使用成员初始列替换赋值的动作，而且这么做效率高</li>
<li>同样道理，当你想要default构造一个成员变量的时候，你都可以使用成员初始列，只要指定无物作为初始化实参即可；在C++11中，如果需要全部执行默认初始化，可以考虑调用&#x3D;default</li>
<li>请在初始列中列出所有的成员并初始化，哪怕成员变量时内置类型</li>
<li>如果成员变量中是const或references，他们就一定需要初值，不能被赋值</li>
<li>许多classes拥有多个构造函数，每个构造函数拥有自己的成员初始列，多份成员初始列的存在就会导致不受欢迎的重复和无聊的工作这种情况下可以合理的在初始列中遗漏那些”赋值表现一样好的成员变量“改用他们的赋值操作，并将那些赋值操作移往某个函数，供所有构造函数使用</li>
<li>补充：在C++11中我们可以使用委托构造函数，将一个函数的构造委托给另外一个函数并进行初始化</li>
<li>C++有着非常固定的成员初始化次序：次序总是相同<ul>
<li>base class 优先于派生class</li>
<li>class成员总是以声明的次序被初始化，即使他们在成员初始列中以不同顺序出现也是如此</li>
</ul>
</li>
</ul>
</li>
<li><p>不同编译单元内定义之non-local static对象 的 初始化次序</p>
<ul>
<li>static对象<ul>
<li>所谓static对象，其寿命从被构造出来到程序结束为止。这种对象包括global对象，namespace对象，在classes内，在函数内，以及在file作用域内被声明为static对象。函数内static对象称为local static对象，其他static对象称为non-local static对象，程序结束时static会自动销毁，也就是他们的析构函数会在main（）结束时候自动调用</li>
</ul>
</li>
<li>编译单元<ul>
<li>所谓编译单元是指在产出单一目标文件的那些源码，基本上它是单一源码文件加上其所含入的头文件</li>
</ul>
</li>
<li>在编译多文件时候，对于多个static对象，由于C++没有定义于不同编译单元内的non-local static对象的初始化次序并无明确定义，这就可能导致使用时候的灾难：使用未经过定义的对象</li>
<li>解决方法很简单：将这些non-local-static对象搬到给他们的一个自己的专属小函数里面，在函数里面声明static，返回一个引用指向它所指的对象<ul>
<li>保证在”该函数被调用期间“，”首次遇上该对象定义式“初始化</li>
<li>如果没有调用对应的静态函数就不会有构造和析构成本，用哪个调那个</li>
<li>对单线程程序友好，可以先在多线程程序调用之前运行需要的所有小函数，消除多线程的”竞速形势</li>
</ul>
</li>
</ul>
</li>
<li><p>请记住</p>
<ul>
<li>为内置类型对象进行手工初始化，因为C++不保证初始化他们</li>
<li>构造函数最好使用成员初始列，而不要在构造函数本体内使用赋值操作。初值列列出的成员变量，其排列次序应该和他们在class中声明次序相同</li>
<li>为免除”跨编译单元之初始化次序“问题，请以local static对象替换non-local static对象</li>
</ul>
</li>
</ul>
<h3 id="构造-x2F-析构-x2F-赋值运算"><a href="#构造-x2F-析构-x2F-赋值运算" class="headerlink" title="构造&#x2F;析构&#x2F;赋值运算"></a>构造&#x2F;析构&#x2F;赋值运算</h3><h4 id="条款05：了解C-默默编写并调用了那些函数"><a href="#条款05：了解C-默默编写并调用了那些函数" class="headerlink" title="条款05：了解C++默默编写并调用了那些函数"></a>条款05：了解C++默默编写并调用了那些函数</h4><ul>
<li>当C++处理过一个”空“类后，他将不再是一个空类，C++为你默默编写的那些函数<ul>
<li>当你创建一个空类，经过C++编译器为你编译后，会放入一个copy构造函数、一个copy assignment操作符和一个析构函数，所有这些函数都是public和inline的</li>
<li>唯有这些函数被需要调用的时候他们才会被编译器创建出来</li>
<li>注意，编译器产出的析构函数是一个non-virtual函数，除非这个class的base自生声明有virtual析构函数</li>
</ul>
</li>
<li>copy函数的创建与调用<ul>
<li>编译器创建的copy构造函数和copy assignment操作符只是单纯的将源对象的non-static成员变量拷贝到目标对象</li>
<li>对于已经自定义过的函数（如自定义构造函数）那么编译器就不会为他生成</li>
<li>对于stl，class等，编译器会调用已经有的copy函数进行copy</li>
<li>对于内置类型，编译器会拷贝前一个对象的每一个bits来完成赋值</li>
<li>对于某些不符合正常情况下的赋值，编译器会拒绝为其自动生成一个copy函数，而是让作者进行定义；比如一个“内含reference成员”的class或者“内含const成员”的class</li>
</ul>
</li>
<li>三五法则<ul>
<li>所有五个拷贝控制成员应该看作一个整体：一般来说如果一个类定义了任意一个拷贝操作，他就应该定义五个所有操作</li>
</ul>
</li>
<li>请记住<ul>
<li>编译器可以暗自为class创建default构造函数，copy构造函数，assignment操作符，析构函数</li>
</ul>
</li>
</ul>
<h4 id="条款06：若不想使用编译器自动生成的函数，就应该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就应该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就应该明确拒绝"></a>条款06：若不想使用编译器自动生成的函数，就应该明确拒绝</h4><ul>
<li>可以将copy构造函数或copy assignment操作符声明为private组织编译器暗自创建其专属版本；<ul>
<li>但这个方法不是绝对安全，因为member函数和friend函数还是可以调用private函数</li>
<li>针对这一问题可以将其声明为private并且不给定义，那么调用的话会报一个连接错误</li>
<li>将连接错误移至编译期是可能的，在一个专门为了阻止copying动作而设计的base class内定义private的opy构造函数或copy assignment即可；然后去继承该class</li>
</ul>
</li>
<li>请记住<ul>
<li>为驳回编译器自动提供的机能，我们可以将相应的成员函数声明为private并且不与实现；或者使用像uncopyable这样的base class</li>
</ul>
</li>
</ul>
<h4 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明virtual析构函数</h4><ul>
<li><p>对于有派生类的基类，需要声明一个virtual析构函数</p>
<ul>
<li>对于派生类的指针（其指向一个派生类的对象）在将其赋予其基类的指针后，但是那个对象却经过基类的指针去delete，如果你的虚函数不定义为virtual的，那么就会导致删除不干净，资源泄露</li>
<li>virtual函数的目的是允许derived class实现得以客制化。<strong>任何classs只要带有virtual函数都几乎确定应该也有一个virtual析构函数</strong></li>
</ul>
</li>
<li><p>对于不打算用来作为基类的类，声明virtual析构函数是一个坏主意</p>
<ul>
<li>如果class不含有virtual函数，通常表示它并不意图用作一个baseclass，当class不企图作为一个base class，令其析构函数为virtual 往往是个馊主意。原因是，在声明virtual的时候会增加一个vptr的指针，这个与virtual实现有关，使用后会使得C++中对象的体积有一定的增大，导致内存的浪费</li>
<li>因此，只有当class内含至少一个virtual函数，才将它声明为virtual析构函数</li>
<li>C++11中，我们可以使用final 来点名：不允许基类被继承</li>
</ul>
</li>
<li><p>不要考虑去继承STL容器。因为他们的析构函数都不是virtual的，如果继承了他们会出现资源泄漏的问题</p>
</li>
<li><p>纯虚函数与析构函数</p>
<ul>
<li>对于如果想创建一个抽象类，但是手头没有合适的纯虚函数，那么可以考虑把析构函数声明为一个纯虚函数。</li>
<li>这个class有一个纯虚函数，又成功的变成了抽象class，因为他的析构函数为纯虚函数，所以不需要担心析构函数的问题，但是必须为这个纯虚函数定义一下</li>
<li>这样，这个析构函数的运行方式就是<ul>
<li>最深层派生的拉个class其析构函数最先被调用</li>
<li>然后是每一个base class析构函数被调用</li>
<li>编译器会在这个AMOV的deriveclasses的析构函数创建要给对~AWOV的调用动作，如果没有的话编译器就会抱怨</li>
</ul>
</li>
</ul>
</li>
<li><p>请记住</p>
<ul>
<li>带多态性质的base classes应该声明一个virtual析构函数。如果class带有任何virtual 函数，他就应该拥有一个virtual析构函数</li>
<li>Classes的设计目的如果不是作为base classes使用，或不是为了具备多态性，就不该被声明为virtual 析构函数</li>
</ul>
</li>
</ul>
<h4 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h4><ul>
<li><p>C++并不禁止析构函数抛出异常，但是它不鼓励你这么做，这是有道理的</p>
<ul>
<li>比如销毁一个vector内的成员，当假设要析构vector以内的元素的时候，widget连续两次抛出异常，在多个异常的情况下，程序不是结束就是导致不明确行为</li>
</ul>
</li>
<li><p>面对可能抛出异常的析构函数，我们应该怎么办</p>
<ul>
<li>使用try-catch，抛出异常就用abort结束程序</li>
<li>吞下因为调用close而发生的异常</li>
<li>也可以进行“双保险策略”，通过更改接口函数，保证所需要的函数可以正常运行（将异常转移到析构函数以外的某个函数，给他们一个处理异常的机会）</li>
</ul>
</li>
<li><p>请记住</p>
<ul>
<li>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该能够捕捉任何异常，然后吞下他们或结束程序</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常作出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作</li>
</ul>
</li>
</ul>
<h4 id="条款09：绝不要在构造和析构过程中调用virtual函数"><a href="#条款09：绝不要在构造和析构过程中调用virtual函数" class="headerlink" title="条款09：绝不要在构造和析构过程中调用virtual函数"></a>条款09：绝不要在构造和析构过程中调用virtual函数</h4><ul>
<li><p>virtual函数与动态绑定的具体操作</p>
<ul>
<li>在直接基类定义过这种函数，那么在继承类我们可以继续使用它的定义，或者将这个虚函数重新定义一个</li>
<li>在定义的时候我们要注意两个点：<ul>
<li>override：对于首个virtual函数我们不能加override，对于下一个继承类重新定义的函数我们才加override</li>
<li>virtual：virtual这个关键字我们在继承类里面可加可不加那个样子。但是记得加override保证函数不充载</li>
</ul>
</li>
<li>析构函数常常被定义为virtual的，负责进行动态的调用</li>
<li>动态绑定往往发生在有virtual和继承类的时候，并且通过指针调用，这样才能发生动态绑定</li>
<li>动态绑定与静态类型的区分<ul>
<li>静态类型：指还没有开始运行的时候的变量自己本身类型</li>
<li>动态类型：指程序开始运行之后的实际类型</li>
<li>动态绑定：指通过静态指针在开始运行的时候，如果调用的函数是虚函数，会根据静态指针指向的实际类型进行函数的调用</li>
</ul>
</li>
</ul>
</li>
<li><p>如果在构造函数中调用virtual函数，看似合理，但是请注意，在base class构造期间，virtual函数并不是virtual函数。</p>
<ul>
<li>因为base class构造函数执行比derived class 的构造函数执行的早，在base class成员执行期间，derived class成员变量尚未初始化，如果此时调用virtual函数下降到derived classes 的阶层是不可能的，因为那些成员变量也没有初始化</li>
<li>根本原因：在derived class对象和base class构造期间，对象的类型是base classes而不是derived class。对象derived class构造函数开始执行前不会成为一个derived class，而是base class类型</li>
<li>相同的道理也适用于析构函数，一旦derived class析构函数开始执行，对象内derived class变量就会呈现未定义值，所以C++视他们仿佛不再存在，进入base class析构函数后对象就会成为一个base class对象，C++的任何部分也这么看他</li>
</ul>
</li>
<li><p>警惕套娃操作，在构造函数中调用函数，函数中调用virtual函数</p>
<ul>
<li>这种情况下编译器和链接器不会做任何抱怨，成功的蒙骗过去了编译器</li>
<li>但是对于纯虚函数，这种调用就会终止代码，但是如果不是纯虚函数，则编译器会调用基类的virtual而不是你想要的derived版本的virtual函数。</li>
<li>所以需要的保证：不仅仅是确定你的构造函数和析构函数都没有（在对象创建和被销毁期间）调用virtual函数，而且他们调用的所有函数也都应该服从这一个约束</li>
</ul>
</li>
<li><p>对于每个class被创建时有对应版本的函数被调用这个场景，可以用来替代的方案有什么呢</p>
<ul>
<li>令derived classes将必要的构造信息向上传递给base class 构造函数，替换加以弥补</li>
<li>利用辅助函数创建一个值传给base class构造函数往往比较方便</li>
<li>让这个函数为static，也就不可能以外指向初期未初始化的derive对象内尚未初始化的成员变量，利用这样，让base class构造和析构期间调用virtual函数不可以下降值derived classes</li>
</ul>
</li>
<li><p>请记住</p>
<ul>
<li>在构造和析构期间不要调用virtual函数，因为这类调用从不下降到derived class（比起当前执行构造函数和析构函数那层</li>
</ul>
</li>
</ul>
<h4 id="条款10：令operator-x3D-返回一个-reference-to-this"><a href="#条款10：令operator-x3D-返回一个-reference-to-this" class="headerlink" title="条款10：令operator&#x3D;返回一个 reference to *this"></a>条款10：令operator&#x3D;返回一个 reference to *this</h4><ul>
<li>关于赋值，可以把它们写成连锁的形式，为了实现连锁赋值，赋值操作运算符必须返回一个reference指向操作符的左侧实参。在你的class实现的时候也要遵循这个协议</li>
<li>这个协议不仅适用于以上标准赋值形式，也适用于所有赋值相关运算（+&#x3D;，-&#x3D;，*&#x3D;。。。）</li>
<li>常见的重载运算符的使用<ul>
<li>对于operator+，-，*，&#x2F;，对于a+b，a对应this，b对应传入的对象</li>
<li>对于operator+&#x3D;，-&#x3D;，对于a+&#x3D;b，a对应this，b对应传入的对象</li>
</ul>
</li>
<li>请记住：<ul>
<li>令赋值操作符返回一个reference to *this</li>
</ul>
</li>
</ul>
<h4 id="条款11：在operator-x3D-中处理自我赋值"><a href="#条款11：在operator-x3D-中处理自我赋值" class="headerlink" title="条款11：在operator&#x3D;中处理自我赋值"></a>条款11：在operator&#x3D;中处理自我赋值</h4><ul>
<li>自我赋值发生在对象赋值给自己，自我赋值的几种情况<ul>
<li>显示的自我赋值(w &#x3D; w)</li>
<li>潜在的自我赋值（a[i] &#x3D; a[j], *px &#x3D; *py）</li>
</ul>
</li>
<li>对于可能进行自赋值的两个对象，如果调用operator&#x3D;可能会发生不好的事情，对于这种情况，如果出现两个相同的值就会导致赋值失败<ul>
<li>一般情况下，让operator具备“异常安全性”往往自动会获得自我赋值安全的回报</li>
<li>第一种解决的办法：在operator&#x3D;最前面做一个证同测试，达到自我赋值检验的目的（会使得代码“大”一些，可能降低执行速度）</li>
<li>第二种解决的办法：在复制之前，先别删除</li>
<li>第三种解决办法，使用所谓的copy and swap技术（还可以修改operator&#x3D;的传参为传值类型，构建一个副本，可能效率更高，但是比较模糊）</li>
</ul>
</li>
<li>请记住<ul>
<li>确保当对象自我赋值时，operator&#x3D;有良好的行为。其中技术包括比较“来源对象”和“目标对象”的地址，精心周到的语句顺序，以及copy and swap</li>
<li>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确</li>
</ul>
</li>
</ul>
<h4 id="条款12：复制对象时，勿忘其每一个成分"><a href="#条款12：复制对象时，勿忘其每一个成分" class="headerlink" title="条款12：复制对象时，勿忘其每一个成分"></a>条款12：复制对象时，勿忘其每一个成分</h4><ul>
<li><p>对于自己写的copying函数，小心且负责</p>
<ul>
<li>copying函数：copy构造函数，copy assignment 操作符</li>
<li>如果你自己声明copying函数，意思就是告诉编译器你并不喜欢缺省实现中某些行为。编译器仿佛被冒犯，会以一种奇怪的方式回敬：当你实现的代码几乎必然出错时候却不告诉你</li>
<li>如果你为class添加一个成员变量，你必须同时修改copying函数，如果你忘记，编译器是不会提醒你的</li>
</ul>
</li>
<li><p>对于继承的函数，记得在继承类调用基类的copying函数</p>
<ul>
<li>任何时候只要你承担起来为derived class撰写copying函数的重大责任，必须很小心的复制base class部分，而不能将任务直接交给编译器</li>
<li>base class的那些成分往往都是private的，你无法直接访问他们，但是你应该让derived class 的 copying函数调用相应的 base class函数</li>
</ul>
</li>
<li><p>当你编写一个copying函数，请确保</p>
<ul>
<li>复制所有的local成员变量</li>
<li>调用所有base classes 内适当的copying函数</li>
</ul>
</li>
<li><p>令copy assignment 操作符调用copy构造函数，但是这根本不可行，因为你在试图构造一个已经存在的对象；令copy构造函数调用copy assignment操作符——同样毫无意义。如果你发现你的copy构造函数和copy assignment 操作符有相似的代码，消除重复代码的做法是：建立一个新的成员函数给两者调用。这样的函数往往是private的</p>
</li>
<li><p>请记住：</p>
<ul>
<li>copying函数应该确保复制”对象内所有成员变量“以及”所有base class成分“</li>
<li>不要尝试以某个copying函数实现另外一个copying函数，应该将共同机能放进入第三个函数中，并由两个copying函数共同调用</li>
</ul>
</li>
</ul>
<h4 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款13：以对象管理资源</h4><ul>
<li><p>可能被“跳过”的delete</p>
<ul>
<li>在函数运行期间，如果因为异常等原因导致程序终止，那么就无法delete所指的对象，并且会导致资源泄露</li>
<li>为了确保资源总是被释放，需要将资源放进对象里面。当控制流离开函数，该对象的析构函数会自动释放那些资源。把资源放进对象里，我们可以依赖C++的析构函数自动调用机制确保资源释放</li>
</ul>
</li>
<li><p>以对象管理资源的两个关键想法</p>
<ul>
<li>获得资源后立刻放进管理对象内：资源取得时机便是初始化时机（RAII）</li>
<li>管理对象运用析构函数确保资源被释放</li>
</ul>
</li>
<li><p>使用智能ptr删除”组“</p>
<ul>
<li>对于share和uniqueptr，我们在使用指针要求他们删除“组” 的东西的时候，一定要注意使用它的第二个模板参数，自定义释放函数</li>
<li>对于auto_ptr需要注意一定别让多个auto_ptr指向同一对象，否则会被删除一次以上；另外其copy函数会导致被拷贝的对象变为null</li>
<li>auto_ptr和share_ptr都是在析构函数内做delete而不是delete[]，因此在动态分配的array上使用其是个坏主意</li>
</ul>
</li>
<li><p>请记住：</p>
<ul>
<li>为防止资源泄露，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源</li>
<li>我们可以通过使用shared_ptr和auto_ptr来释放资源，前者的copy行为比较直观</li>
</ul>
</li>
</ul>
<h4 id="条款14：在资源管理类小心copying行为"><a href="#条款14：在资源管理类小心copying行为" class="headerlink" title="条款14：在资源管理类小心copying行为"></a>条款14：在资源管理类小心copying行为</h4><ul>
<li>当一个RAII对象被复制会发生什么事？<ul>
<li>禁止复制：大多数的资源管理类不允许复制，复制可能不合理，在C++11中，我们需要做的就是可以使用&#x3D;delete删除复制行为（或者将copy行为声明为private）。unique-ptr就是一个典型的类似，他就不允许复制</li>
<li>引用计数法：有的时候我们希望保持资源，在这种情况下复制会让引用数递增，share-ptr。且其允许指定“删除器”，class的析构函数会自动调用non-static成员变量的析构函数，因此可以不显示写析构</li>
<li>直接复制底层资源：我们在复制资源管理类对象的时候。需要采取深度拷贝。即直接复制资源。</li>
<li>转移底部资源的拥有权，如auto_ptr，某些罕见场合下你可能希望确保永远只有一个RAII对象指向一个未加工资源，即使RAII对象被复制依然如此。此时资源的拥有权从复制物转移到目标物。使用unique-ptr即可</li>
</ul>
</li>
<li>请记住：<ul>
<li>复制RAII对象必须一并复制它所管理的资源。所以资源的copying行为决定RAII对象的copying行为。</li>
<li>普遍而常见的RAII class copying 行为是：抑制copying（使用unique-ptr）使用引用计数法（使用share-ptr）</li>
</ul>
</li>
</ul>
<h4 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款15：在资源管理类中提供对原始资源的访问</h4><ul>
<li>对于指针类的对象，比如shared_ptr对象，很多时候可能需要一个底层的资源去调用然后去编写，这个时候需要去在资源管理类中提供对原始资源的访问，即需要一个函数可将RAII class对象转化为其所内含的原始资源<ul>
<li>对于shareptr和uniqueptr，都有对应返回指针的类型，允许他们转换为底部的指针</li>
<li>很多时候，我们一般采用显式的转换掉用，保证资源管理的合理性。如果采用隐式的调用可能会引发一些其他不想看到的隐式的调用</li>
</ul>
</li>
<li>请记住<ul>
<li>API往往要求访问原始资源，所以每一个RAIIclass 应该提供一个取得其所管理之资源的办法</li>
<li>对原始资源的访问可能经由显式转换或隐式转换。一般而言显式转换比较安全，隐式转换对客户比较方便</li>
</ul>
</li>
</ul>
<h4 id="条款16：成对使用new和delete时候要采取相同形式"><a href="#条款16：成对使用new和delete时候要采取相同形式" class="headerlink" title="条款16：成对使用new和delete时候要采取相同形式"></a>条款16：成对使用new和delete时候要采取相同形式</h4><ul>
<li>使用new时有两件事情发生，分别是分配内存和调用一个或多个构造函数；对应的delete也有两件事情发生，先有一个或多个析构函数调用，再释放内存</li>
<li>指向一个数组的指针和一个普通的指针<ul>
<li>数组所用的内存通常还包括“数组大小”的记录 ，单一对象则没有这个记录</li>
<li>对于这样的指针，我们需要区分：数组调用删除数组的形式delete[]，指针调用删除指针的形式delete</li>
<li>如果你对着指向数组的指针调用了指向普通指针类型的删除模式，那么则只会删除指针指向的变量，剩下的变量将会泄露出去</li>
</ul>
</li>
<li>对于使用typedef等的”别名“充满警惕<ul>
<li>很多时候如果调用了typedef去定义，可能我们会让一个指向数组的指针看起来像是一个指向常量的指针</li>
<li>这个时候我们必须清楚，调用delete需要使用删除数组的指针，尽管它长得像一个普通的变量。为了避免出现这种错误，使用引用是一个不错的方法</li>
</ul>
</li>
<li>请记住：<ul>
<li>如果你在new表达式中使用[]，必须在相应的delete表达式中也是用[]。如果你在new表达式中不使用[]，一定不要在相应的delete表达式中使用[]。</li>
</ul>
</li>
</ul>
<h4 id="条款17：以独立语句将newed对象置入智能指针"><a href="#条款17：以独立语句将newed对象置入智能指针" class="headerlink" title="条款17：以独立语句将newed对象置入智能指针"></a>条款17：以独立语句将newed对象置入智能指针</h4><ul>
<li>在重新获取对象，以对象管理资源的时候，我们必须以单独的语句将对象放置于智能指针里面，如果合并其他语句，可能会导致因为语句的先后问题发生错误或者资源泄露</li>
<li>我们必须将其拆开，保证他没有“重新排列的自由”，让他按照我们所需的语句进行排列</li>
<li>比如将<code>f(shared_ptr&lt;Widget&gt;(new Widget), g())</code>改成<code>shared_ptr&lt;Widget&gt; pw(new Widget); f(pw, g()); </code><ul>
<li>在”资源被创建”和“资源被转换为管理对象”两个时间点之间有可能发生异常干扰</li>
</ul>
</li>
<li>请记住：<ul>
<li>以独立语句将newed对象存储与智能指针内，如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄露</li>
</ul>
</li>
</ul>
<h4 id="条款18：让接口容易被正确使用，而不是被误用"><a href="#条款18：让接口容易被正确使用，而不是被误用" class="headerlink" title="条款18：让接口容易被正确使用，而不是被误用"></a>条款18：让接口容易被正确使用，而不是被误用</h4><ul>
<li><p>很多时候，如果客户使用了某个接口，却没有获得他所预期的行为，那么这个错误设计者也有一份责任；如果客户企图使用某个接口而却没有获得他所预期的行为，这个代码不应该通过编译，如果代码通过了编译，那么他就是客户想要的</p>
</li>
<li><p>使用类型系统进行初始变量的管理</p>
<ul>
<li>可以通过对于将成员变量变为一个新的“类类型”并为他设计合适的外覆类型来设置，然后再使用下，可以有效的避免“接口被误用”</li>
</ul>
</li>
<li><p>对于单一外覆类型的管理</p>
<ul>
<li>不要使用enums，因为这没有类型安全性，取而代之我们应该使用一个函数去返回</li>
<li>需要遵循条款4：使用一个静态函数来返回</li>
<li>使用条款三：可以用const等限定，确保因为用户限定类型而犯错</li>
<li>我们还要遵循一个一般性的原则：让我们定义的运算符等等的行为符合内置类型的行为。</li>
</ul>
</li>
<li><p>如何设计接口？</p>
<ul>
<li>提供行为一致的接口，减少调用者的使用负担<ul>
<li>让我们定义的运算符等等的行为符合内置类型的行为，这个根本的理由就是，提供行为一致的接口，减少调用者的使用负担</li>
<li>这种一致性质更能让接口被方便的使用，STL就是基于这样的原则</li>
</ul>
</li>
<li>先发制人<ul>
<li>为了防止出错，我们很多时候就要先发制人，比如说，对于指针的操作，我们可以尽可能使用shareptr，<br>甚至是就不用普通ptr，将资源管理的责任全部推给share-ptr</li>
<li>或者说，我们可能不能直接对那个普通的指针动刀子。而且不直接使用delete而是使用一个自己定义的函数，这种情况下，一个可以的方法是定义一个null-share-ptr，让其指向它，然后代替他，最后进行合适的操作</li>
<li>使用share-ptr也可以避免所谓的cross DLL problem（在A处创建在B处删除）。share-ptr可以根据<br>习惯自动在A处创建在B处删除</li>
<li>share-ptr的开销本身比裸指针大，但是在大部分场景，对其提供的安全性和方便性远远大于他的开销，特殊的场合，资源极度苛刻的时候，才不是用share-ptr。</li>
</ul>
</li>
</ul>
</li>
<li><p>请记住：</p>
<ul>
<li>好的接口很容易被正确的使用，不容易被误用。你应该在所有的接口中努力达成这些性质</li>
<li>促进正确使用的办法包括接口的一致性，以及与内置类型的行为兼容。</li>
<li>“阻止误用”的方法包括建立新的类型，限制类型上的操作，束缚对象值，以及消除客户的资源管理责任</li>
<li>share-ptr支持定制形态删除器，可防范DLL问题，可以被用来自动解除互斥锁等等</li>
</ul>
</li>
</ul>
<h4 id="条款19：设计class犹如设计type"><a href="#条款19：设计class犹如设计type" class="headerlink" title="条款19：设计class犹如设计type"></a>条款19：设计class犹如设计type</h4><ul>
<li>我们身为C++程序员，在设计class时候，必须注意以下几条<ul>
<li>新type的对象如何创建和销毁？</li>
<li>对象初始化和对象赋值该有什么样的差异？</li>
<li>新type对象如果被pass by value（以值传递），意味着什么？</li>
<li>什么是新type的“合法值”</li>
<li>你的新的type需要配合某一个继承图系嘛？</li>
<li>你的新type需要什么样的转换？</li>
<li>什么样的操作符和函数对此新type而言是合理的？</li>
<li>什么样的标准函数应该驳回？</li>
<li>谁该取用新type的成员</li>
<li>什么是新type的“未声明接口”？</li>
<li>你的新type有多么一般化？</li>
<li>你真的需要一个新type嘛？</li>
</ul>
</li>
<li>请记住：<ul>
<li>Class的设计就是type的设计，在定义一个新的type之前，请确定已经考虑过本条款覆盖的所有讨论主题</li>
</ul>
</li>
</ul>
<h4 id="条款20：宁以pass-by-reference-to-const"><a href="#条款20：宁以pass-by-reference-to-const" class="headerlink" title="条款20：宁以pass by reference to const"></a>条款20：宁以pass by reference to const</h4><ul>
<li><p>传值调用的时候的额外的消耗</p>
<ul>
<li>如果传入一个值，在运行时候需要进行六次构造六次析构(一个class包含2个string的对象和一个base class也包含2个string的对象)，但是传入引用就不会造成任何额外的负担</li>
<li>传入一个带有const的引用往往很多时候是最优的选择，对于是否实际需要传入一个值，需要具体的考虑。</li>
</ul>
</li>
<li><p>利用传入引用避免切割问题</p>
<ul>
<li>当一个derived class对象以by value方式传递并是视为一个base class对象，可能导致切割问题。derived class 的特性全被切割掉了</li>
<li>如果进行传值，通过拷贝构造函数，你传入的w会被切割，但是如果是const引用，就可以确保不被切割，这对调用virtual函数的时候尤其重要</li>
</ul>
</li>
<li><p>对于C++的底层。reference底层是用指针的方式实现的，通过引用传递的其实是指针，传递一个引用会被传递一个值高效很多，还可以帮助他们免受切割的问题</p>
</li>
<li><p>但是也不能说传值是完全错误 的，比如说STL容器很多都是传入的值，这个要按照具体使用那一部分来决定</p>
</li>
<li><p>可以这么说，对于pass by value可行的一般有两个：内置类型,STL，其他的在使用的时候需要好好考虑为什么这么做，尽力用pass by reference to const替换 pass by value</p>
</li>
<li><p>请记住</p>
<ul>
<li>尽量以pass by reference to const替换pass by value。前者通常比较高效，并且可以避免切割问题</li>
<li>以上规则并不适用于内置类型，以及STL的迭代器和函数对象，对他们而言，pass by value往往比较合适</li>
</ul>
</li>
</ul>
<h4 id="条款21：必须返回对象别妄想返回其reference"><a href="#条款21：必须返回对象别妄想返回其reference" class="headerlink" title="条款21：必须返回对象别妄想返回其reference"></a>条款21：必须返回对象别妄想返回其reference</h4><ul>
<li>请不要返回一个local变量的reference<ul>
<li>对于一个返回值，一旦返回一个local变量的reference，都是不可取的，因为在其作用域结束的时候，原来那个变量已经被销毁了</li>
<li>如果你创建一个指针，则你无法对你创建出来的对象进行销毁，会造成资源泄露</li>
<li>就算是使用static也不行，因为static只有一个，很多时候进行比较就会出错。</li>
<li>应该允许函数返回一个新的对象</li>
</ul>
</li>
<li>请记住：绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heapallocated对象，或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。条款 4 已经为“在单线程环境中合理返回 reference指向一个local static对象”提供了一份设计实例。</li>
</ul>
<h4 id="条款22：将成员变量声明为private"><a href="#条款22：将成员变量声明为private" class="headerlink" title="条款22：将成员变量声明为private"></a>条款22：将成员变量声明为private</h4><ul>
<li><p>对于public成员变量，我们应该为他统一形式：全部以函数的形式出现</p>
<ul>
<li>好处1：可以让使用者都带上小括号，不用考虑是否应该带小括号这样的无聊的问题。</li>
<li>好处2：可以实现对于私有变量的针对性控制，就像电脑里面的文件一样，有些需要只读，有些不能访问，又有些需要只写，还有需要读和写一起的</li>
<li>好处3：实现封装。</li>
</ul>
</li>
<li><p>从封装的角度看，其实只有两种访问权限：private（提供封装）和其他（不提供封装），所以protect并不比public更加具有封装性质</p>
</li>
<li><p>对于private和protect 我们要放成员变量</p>
<ul>
<li>public更多的就是充当函数接口的左右。我们一般在private去放置成员变量为所有的可能的实现提供弹性</li>
<li>好处：<ul>
<li>在程序改变时候通知其他对象</li>
<li>验证class的约束条件，以及函数的前提和事后的状态</li>
<li>在多线程环境中执行同步控制</li>
</ul>
</li>
</ul>
</li>
<li><p>请记住:</p>
<ul>
<li>切记将成员变量声明为private，这可赋予客户访问数据的一致性，可细微划分访问控制，允诺约束条件获得保证，并提供class作者以充分的实现弹性</li>
<li>protected并不比public更加具有封装性</li>
</ul>
</li>
</ul>
<h4 id="条款23：宁以non-member-non-friend-替换"><a href="#条款23：宁以non-member-non-friend-替换" class="headerlink" title="条款23：宁以non-member non-friend 替换"></a>条款23：宁以non-member non-friend 替换</h4><ul>
<li>尽可能不要将同时调用类的成员函数的函数放在同一个类中<ul>
<li>从封装的角度看：</li>
<li>如果某些东西被封装，他就不在可见，越多的东西被封装，越少的人可以看到它，越少的人看到他，我们就可以有越大的弹性变化他，因为我们只是改变了直接影响看到改变的那些人和事物。</li>
<li>越多的东西被封装，我们改变那些东西的能力也就愈大。这就是我们首先推崇封装的原因：它使我们能够改变的事物而只影响有限客户</li>
<li>对于封装性，我们可以用“有多少代码能看到一块数据”来测量。越多的函数可以访问它，数据的封装性越低</li>
</ul>
</li>
<li>如果我们需要表明类似的关系，可以把他们放入同一个命名空间里面<ul>
<li>把他们放入同一个命名空间里面，不单单是看起来自然，而且有技术上的原因</li>
<li>首先，他能进行多文件编译，保证不会出错</li>
<li>其次，它可以保证让不使用webbrowser的客户不取得与其有关的函数</li>
<li>将所有便利函数放在多个头文件内但隶属于同一个命名空间，意味着客户可以轻松扩展这一组便利函数</li>
</ul>
</li>
<li>请记住：<ul>
<li>宁可拿non-member non-friend函数替换member，这样可以增加封装性，包裹弹性和机能扩充性</li>
</ul>
</li>
</ul>
<h4 id="条款24：若所有参数都需要类型转换，请为此采用non-member函数"><a href="#条款24：若所有参数都需要类型转换，请为此采用non-member函数" class="headerlink" title="条款24：若所有参数都需要类型转换，请为此采用non-member函数"></a>条款24：若所有参数都需要类型转换，请为此采用non-member函数</h4><ul>
<li><p>令classes支持隐式类型转换通常是一个糟糕的注意，但对于建立数值类型时还是合理的。需要类型转换的函数如何放置，考虑一个表示有理数的类</p>
<ul>
<li>explicit的使用：被声明为explicit的构造函数通常比其 non-explicit 兄弟更受欢迎, 因为它们禁止编译器执行非预期 (往往也不被期望) 的类型转换. 除非有一个好理由允许构造函数被用于隐式类型转换, 否则会把它声明为explicit.</li>
<li>假设我们需要定义一个operator *，如果定义为成员函数内部，则只能满足两个Rational类的相乘，满足不了类与普通数字的混合运算</li>
<li>把operator *拿到外面去，成为一个non-menber函数，允许类的隐式转换；C++规定，只有当参数被列于参数列内，这个参数才是隐式类型转换的合格参与者，this对象不是</li>
</ul>
</li>
<li><p>对于函数，如果他不应该是member函数，那么他应该变成non-member函数，还是friend函数呢？</p>
<ul>
<li>要明确一点，对于member函数的反面并不是friend函数，而是non-member函数</li>
<li>所以对于不能称为member函数还要判断它是否可以成为friend函数。</li>
</ul>
</li>
<li><p>请记住：</p>
<ul>
<li>如果你需要为某个函数的所有参数（包括被this指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是non-member函数</li>
</ul>
</li>
</ul>
<h4 id="条款25：考虑写出一个不抛出异常的swap函数"><a href="#条款25：考虑写出一个不抛出异常的swap函数" class="headerlink" title="条款25：考虑写出一个不抛出异常的swap函数"></a>条款25：考虑写出一个不抛出异常的swap函数</h4><ul>
<li><p>默认的swap在面对pipml手法的class时其copy效率通常很差，此时要求进行一个特化版本</p>
</li>
<li><p>如何交换一个对象private类里面的指针</p>
<ul>
<li>对于这种交换，我们不能直接使用std::swap函数。应该让这个类声明一个swap的public成员函数，做真正的置换工作，然后将std::swap特化，令它调用该成员函数</li>
<li>在任何情况下，要以using声明来代替直接调用std::swap</li>
</ul>
</li>
<li><p>如何交换一个template class private的指针</p>
<ul>
<li>不能在偏特化一个function template，C++只允许对class template偏特化</li>
<li>可以全特化std内的template，但是不能添加新的template，不要添加任何新的东西到std里头。想要让他人调用swap时使用我们特化的高效swap版本，还是需要声明一个non-member swap（class所在的命名空间内）让他调用public，member-swap，同时也要特化std::swap版本</li>
</ul>
</li>
<li><p>成员版swap不应该抛出异常</p>
<ul>
<li>成员版swap函数绝对不应该抛出异常，因为swap的一个最好的应用是帮助classes提供强烈的异常安全性保障。</li>
<li>swap的noexpect版本（一般的swap）不能是普通非成员版本。因为swap缺省版本是以copy构造函数和copy assignment操作符为基础，而这两者都允许抛出异常。</li>
</ul>
</li>
<li><p>对于swap的使用</p>
<ul>
<li>如果std的swap实践有着一般的效率，直接用没有问题</li>
<li>如果效率不足，那么<ul>
<li>提供一个public swap成员函数，让他高效的置换你的类型的两个对象值。</li>
<li>在你的class或template所在的命名空间提供一个 non-member swap（一般为template特例化版本），并让他调用上述swap成员函数</li>
<li>如果你正编写一个class（而非 class template）为你的class转化为std::swap。并令它调用你的swap成员函数。</li>
</ul>
</li>
<li>最后，如果调用swap，就要确定包含using std::swap表达式，以便让std::swap在你的函数内曝光，然后不加任何namespace修饰符，赤裸裸的去调用swap。</li>
</ul>
</li>
<li><p>请记住：</p>
<ul>
<li>当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常。</li>
<li>如果你提供一个member swap，也该提供一个non-member swap用来调用前者。对于classes（而非templates），也请特化std：：swap。</li>
<li>调用swap时应针对std：：swap使用using声明式，然后调用swap并且不带任何“命名空间资格修饰”。</li>
<li>为“用户定义类型”进行std templates全特化是好的，但千万不要尝试在std内加入某些对std而言全新的东西。</li>
</ul>
</li>
</ul>
<h4 id="条款26：尽可能延后变量定义式的出现时间"><a href="#条款26：尽可能延后变量定义式的出现时间" class="headerlink" title="条款26：尽可能延后变量定义式的出现时间"></a>条款26：尽可能延后变量定义式的出现时间</h4><ul>
<li>不应该出现过早的表达式<ul>
<li>很多时候，有些看着可能被使用的表达式，实际上很可能并不会使用到，比如在异常抛出的情况</li>
<li>更好的是在他构造出来的时候就直接初始化它</li>
<li>不只应该延后变量的定义，直到非得使用该变量的前一刻为止，甚至应该尝试延后这份定义直到能够给它初值实参为止。如果这样，不仅能够避免构造（和析构）非必要对象，还可以避免无意义的default构造行为。更深一层说，以“具明显意义之初值”将变量初始化，还可以附带说明变量的目的。</li>
</ul>
</li>
<li>对于循环，我们如何判断变量是否出现的过早呢？<ul>
<li>除非知道赋值比构造加析构的成本低，而且你的代码对于效率高敏感，否则你应该用在循环内定义变量的方法</li>
<li>在循环外定义变量扩大了作用域，可能使得代码维护成本变高</li>
</ul>
</li>
<li>请记住：<ul>
<li>尽可能延后变量定义式的出现，这样做可以增加程序的清晰度并改善程序效率</li>
</ul>
</li>
</ul>
<h4 id="条款27：尽量少做转型动作"><a href="#条款27：尽量少做转型动作" class="headerlink" title="条款27：尽量少做转型动作"></a>条款27：尽量少做转型动作</h4><ul>
<li><p>C++的四种转型</p>
<ul>
<li>const_cast通常被用来将对象的常量性转除。它也是唯一有此能力的C++-style转型操作符。</li>
<li>dynamic_cast主要用来执行“安全向下转型”，也就是用来决定某对象是否归属继承体系中的某个类型。它是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作。</li>
<li>reinterpret_cast意图执行低级转型，实际动作（及结果）可能取决于编译器，这也就表示它不可移植。例如将一个pointer to int转型为一个int。这一类转型在低级代码以外很少见。</li>
<li>static_cast用来强迫隐式转换，例如将non-const对象转为const对象（或将int转为double等等）。它也可以用来执行上述多种转换的反向转换，例如将 void*指针转为 typed 指针，将pointer-to-base转为pointer-to-derived。但它无法将const转为non-const——这个只有const_cast才办得到。</li>
</ul>
</li>
<li><p>显示转型与隐式转型</p>
<ul>
<li>使用转型，一定会让编译器编写出对应的运行期间执行的代码，而不是什么都不做</li>
<li>对于对象，我们很多时候不能直接粗暴的对于指针进行转型的操作，有的时候这两个指针的值并不相同，因为这种情况下会有一个偏移量在运行期被施行于Derived *指针上，用以取得正确的Base *指针值</li>
<li>因此，但以对象可能拥有一个以上的地址（例如上面这个），所以我们绝对不能尝试对一个已经多重继承的类指针进行转型</li>
</ul>
</li>
<li><p>转型返回的是一个新的副本，而不是更改原来的对象</p>
<ul>
<li>*this执行了解引用，这里实际做的操作是把一个SpWin对象cast成了Base对象，cast函数返回一个Base临时对象，然后这个对象执行onResize后就被析构了；而这里的本意是希望把SpWin对象看作一个Win对象</li>
<li>对于这种情况，就是不要使用转型，直接通过作用域调用是最好的</li>
</ul>
</li>
<li><p>解决“基类指针或引用”必须调用继承类的函数的操作</p>
<ul>
<li>动态类型转换主要用在：拿着基类指针当做子类对象操作的时候。一般来说这种动态类型转换不是必须的，可以通过其他方式避免：一种是直接使用对应的子类类型指针去访问而不是基类，另一种是通过虚函数的方式，这个是最常用的通过基类指针访问子类成员函数的方式。</li>
<li>之所以需要dynamic_cast，通常是因为你想在一个你认定为derived class对象身上执行derived class操作函数，但你的手上却只有一个“指向base”的pointer或reference，你只能靠它们来处理对象。有两个一般性做法可以避免这个问题。<ul>
<li>第一个：直接以容器的方式，里面存继承类的指针去管理容器即可，当然这个可能不能让你指向所有的派生类。如果需要建立多个，请使用多个容器去储存指针</li>
<li>第二个：构造一个缺省的相同名字的函数，但是不写东西，利用virtual的性质去调用它</li>
</ul>
</li>
<li>总之我们要尽可能避免使用转型，对于连串的dynamic cast更是要避免</li>
</ul>
</li>
<li><p>请记住：</p>
<ul>
<li>如果可以，尽量避免转型，特别是在注重效率的代码中避免 dynamic_casts。如果有个设计需要转型动作，试着发展无需转型的替代设计。</li>
<li>如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需将转型放进他们自己的代码内。</li>
<li>宁可使用C++-style（新式）转型，不要使用旧式转型。前者很容易辨识出来，而且也比较有着分门别类的职掌。</li>
</ul>
</li>
</ul>
<h4 id="条款28：避免返回handles指向对象内部成分"><a href="#条款28：避免返回handles指向对象内部成分" class="headerlink" title="条款28：避免返回handles指向对象内部成分"></a>条款28：避免返回handles指向对象内部成分</h4><ul>
<li>reference，指针和迭代器都是所谓的handles（用来取得某个对象），返回一个handle带来的风险都是降低封装性的风险，柯登导致虽然调用const函数还是可以修改对象的状态</li>
<li>可能产生dangling handles的问题<ul>
<li>对boundingBox的调用获得一个新的、暂时的Rectangle对象。这个对象没有名称，所以我们权且称它为temp。随后 upperLeft作用于 temp 身上，返回一个reference 指向 temp 的一个内部成分，更具体地说是指向一个用以标示 temp 的Points。于是pUpperLeft指向那个Point对象。目前为止一切还好，但故事尚未结束，因为在那个语句结束之后，boundingBox的返回值，也就是我们所说的temp，将被销毁，而那间接导致temp内的Points析构。最终导致pUpperLeft指向一个不再存在的对象；也就是说一旦产出pUpperLeft的那个语句结束，pUpperLeft也就变成空悬、虚吊</li>
</ul>
</li>
<li>“返回一个handle代表对象内部成分”总是危险的。不论这所谓的 handle 是个指针或迭代器或 reference，也不论这个 handle 是否为const，也不论那个返回handle的成员函数是否为 const。这里的唯一关键是，有个handle被传出去了，一旦如此你就是暴露在“handle比其所指对象更长寿”的风险下。</li>
<li>避免返回handles（包括references、指针、迭代器）指向对象内部。遵守这个条款可增加封装性，帮助const 成员函数的行为像个 const，并将发生“虚吊号码牌”（dangling handles）的可能性降至最低。</li>
<li>请记住：<ul>
<li>避免返回handles（包括references、指针、迭代器）指向对象内部。遵守这个条款可增加封装性，帮助 const 成员函数的行为像个 const，并将发生“虚吊号码牌”的可能性降至最低。</li>
</ul>
</li>
</ul>
<h4 id="条款29：为“异常安全”而努力是值得的"><a href="#条款29：为“异常安全”而努力是值得的" class="headerlink" title="条款29：为“异常安全”而努力是值得的"></a>条款29：为“异常安全”而努力是值得的</h4><ul>
<li><p>异常安全函数的定义与行为</p>
<ul>
<li>异常安全函数提供以下三个保证之一<ul>
<li>基本承诺：若异常被抛出，程序内的任何事物仍然保持在有效状态下</li>
<li>强烈保证：如果异常被抛出，程序状态不改变</li>
<li>不抛掷保证：承诺绝对不抛出异常，因为他们总是能够完成他们原先承诺的功能</li>
</ul>
</li>
<li>当异常被抛出时候，带有异常安全性的函数会：<ul>
<li>不泄露任何资源</li>
<li>不允许数据败坏</li>
</ul>
</li>
</ul>
</li>
<li><p>函数调用noexpect&#x2F;throw（）就不会抛出异常吗？</p>
<ul>
<li>不一定会，如果是noexpect&#x2F;throw的函数抛出异常，那么就会导致意想不到的函数会被调用，他不能为你提供任何异<br>常安全性保证，也不一定是可移植，高效的。</li>
</ul>
</li>
<li><p>一个可能为单一函数带来“异常安全“的做法</p>
<ul>
<li>首要策略：不要为了表示某件事发生而改变对象状态，除非那件事情真的发生了</li>
<li>一个简单的策略：copy and swap：为你打算修改的对象（原件）做出一份副本，然后在那副本身上做一切必要修改。若有任何修改动作抛出异常，原对象仍保持未改变状态。待所有改变都成功后，再将修改过的那个副本和原对象在一个不抛出异常的操作中置换（swap）。<ul>
<li>好处：保证异常安全</li>
<li>坏处：可能拷贝的时间难以接受（性能上说不过去）</li>
</ul>
</li>
<li>这种只能保证”一个函数“有强烈安全的性质，但是对于一个类来说，只有所有函数都是异常安全的，那么才能说这个类是异常安全的</li>
<li>只有当你实在无法提供强烈保证，才能考虑基本保证</li>
</ul>
</li>
<li><p>请记住：</p>
<ul>
<li>异常安全函数即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型。</li>
<li>“强烈保证”往往能够以 copy-and-swap 实现出来，但“强烈保证”并非对所有函数都可实现或具备现实意义。</li>
<li>函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。</li>
</ul>
</li>
</ul>
<h4 id="条款30：透彻了解inlining的里里外外"><a href="#条款30：透彻了解inlining的里里外外" class="headerlink" title="条款30：透彻了解inlining的里里外外"></a>条款30：透彻了解inlining的里里外外</h4><ul>
<li>inline一般被置于头文件内，在编译期优化函数，执行函数</li>
<li>编译器一般会拒绝太过于复杂的函数，以及virtual函数（或者调用）</li>
<li>构造函数和析构函数往往都是inlining的糟糕候选人</li>
<li>程序设计的人必须考虑inlining带来的冲击：如果使用inline，当程序升级的时候需要重新编译，而函数却不一定</li>
<li>不要忘记80-20经验法则：平均而言一个程序往往将80%的执行时间花费在20%的代码上头。这是一个重要的法则，因为它提醒你，作为一个软件开发者，你的目标是找出这可以有效增进程序整体效率的20%代码，然后将它inline或竭尽所能地将它瘦身。但除非你选对目标，否则一切都是虚功。</li>
<li>请记住：<ul>
<li>将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级（binary upgradability）更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。</li>
<li>不要只因为function templates出现在头文件，就将它们声明为inline。</li>
</ul>
</li>
</ul>
<h4 id="条款31：将文件的编译依存关系降至最低"><a href="#条款31：将文件的编译依存关系降至最低" class="headerlink" title="条款31：将文件的编译依存关系降至最低"></a>条款31：将文件的编译依存关系降至最低</h4><ul>
<li>很多时候，如果你对class的某个文件进行修改，就会发现class把它全部都进行编译了。C++并没有将接口从实现中分离这件事做得很好，class内如果存在编译依存关系则将带来连串的编译依存</li>
<li>”前置声明每一件东西“的一个困难在于标准库可能不是一个class，第二个困难在于编译器必须在编译期间知道对象的大小，而编译器获得這项信息的唯一方法就是询问class定义式</li>
<li>使用handle class来分开声明与实现<ul>
<li>将一个class分为两个class，一个只提供接口一个负责实现该接口</li>
<li>main class制焊一个指针成员指向其实现类，称为pimpl idiom，从而实现真正的”将接口从实现中分离“</li>
<li>这个分离的关键在于以”声明的依存性“替换”定义的依存性“，现实中先让头文件尽可能自我满足，做不到则让他与其他文件的声明式相依</li>
<li>如果使用object references或者object pointer可以完成任务，就尽量不要使用object；如果能够，尽量以class声明式替换class定义式；为声明式和定义式提供不同的头文件</li>
<li>让class变成一个Handle class并不会改变他做的事，只会改变他做事的方法</li>
</ul>
</li>
<li>另一个制作Handle class的方法是令class成为一种特殊的abstract base class，使用 Interface classes 实现声明与实现的分开<ul>
<li>这种class的目的是详细一一描述derived classes的接口，因此它通常不带成员变量，也没有构造函数，只有一个virtual析构函数以及一组pure virtual函数，用来叙述整个接口。</li>
<li>通常调用一个特殊函数，扮演真正将被具现化的那个derived class的构造函数的角色，通常称为factory 函数或virtual 构造函数</li>
</ul>
</li>
<li>Handle class 和Interface classes解除了接口和实现之间的耦合关系，降低文件间的编译依存性；当然这么做也会带来一些负担，比如虽然解除了耦合关系，但是因为多了一层间接的访问，他会让你在运行期间丧失很多速度，又为你让每个对象超额付出若干内存</li>
<li>请记住：<ul>
<li>支持“编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是Handle classes和Interface classes。</li>
<li>程序库头文件应该以“完全且仅有声明式”（。h）的形式存在。这种做法不论是否涉及templates都适用。具体的实现应该交给（.cpp)</li>
</ul>
</li>
</ul>
<h4 id="条款32：确定你的public继承塑膜出is-a关系"><a href="#条款32：确定你的public继承塑膜出is-a关系" class="headerlink" title="条款32：确定你的public继承塑膜出is-a关系"></a>条款32：确定你的public继承塑膜出is-a关系</h4><ul>
<li>public inheritance（公开继承）意味 “is-a”（是一种）的关系。</li>
<li>如果你令class D（”Derived”）以public形式继承class B（”Base”），你便是告诉 C++编译器说，每一个类型为 D的对象同时也是一个类型为B的对象，反之不成立。你的意思是B比D表现出更一般化的概念，而D比B表现出更特殊化的概念。你主张“B对象可派上用场的任何地方，D对象一样可以派上用场”，因为每一个D对象都是一种（是一个）B对象。反之如果你需要一个 D对象，B对象无法效劳，因为虽然每个D对象都是一个B对象，反之并不成立。</li>
<li>代码通过编译并不表示就可以正确运作（矩形和正方形，鸟类和企鹅）</li>
<li>请记住：<ul>
<li>“public继承”意味is-a。适用于base classes身上的每一件事情一定也适用于derived classes身上，因为每一个derived class对象也都是一个base class对象。</li>
</ul>
</li>
</ul>
<h4 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款33：避免遮掩继承而来的名称</h4><ul>
<li>作用域的查找，对于一个继承的函数mf2<ul>
<li>编译器的做法是查找各作用域，看看有没有某个名为 mf2的声明式。首先查找local 作用域（也就是mf4覆盖的作用域），在那儿没找到任何东西名为mf2。于是查找其外围作用域，也就是class Derived覆盖的作用域。还是没找到任何东西名为mf2，于是再往外围移动，本例为base class。在那儿编译器找到一个名为mf2的东西了，于是停止查找。如果Base内还是没有mf2，查找动作便继续下去，首先找内含Base的那个namespace（s） 的作用域（如果有的话），最后往global作用域找去。</li>
</ul>
</li>
<li>当继承和重载在一起时候，继承类的同名函数会遮盖掉基类的重载函数，就是像内外作用域一样，这无论是virtual还是不virtual都适用。<ul>
<li>因为以作用域为基础的名字遮盖规则没有改变，但是这么做违反了条款32，is-a是public继承的基石</li>
<li>解决方法：使用using声明式或者转交函数暗自称为inline，让mf1，和mf3继承而来的东西重新可见</li>
</ul>
</li>
<li>请记住：<ul>
<li>derived classes内的名称会遮掩base classes内的名称。在public继承下从来没有人希望如此。</li>
<li>为了让被遮掩的名称再见天日，可使用 using 声明式或者转交函数</li>
</ul>
</li>
</ul>
<h4 id="条款34：区分接口继承和实现继承"><a href="#条款34：区分接口继承和实现继承" class="headerlink" title="条款34：区分接口继承和实现继承"></a>条款34：区分接口继承和实现继承</h4><ul>
<li><p>声明一个纯虚函数的目的是为了让derived classes只是继承函数接口</p>
<ul>
<li>什么是函数接口？单纯的函数接口一般是一个纯虚函数来限定，使用纯虚函数就是在告诉对应的继承类：必须提供接口函数的实现函数，但是我不管你怎么实现他</li>
<li>同时，我们其实可以为纯虚函数提供定义，就是为函数接口实现一份代码，调用的时候需要显式调用，这个可以考虑为非纯的虚函数提供一个更加平常和安全的实现</li>
</ul>
</li>
<li><p>声明非纯虚函数的目的，让derived classes继承该函数接口和缺省实现</p>
<ul>
<li>可以定义一个protect的缺省函数进行调用</li>
<li>可以将函数接口与缺省实现分开，利用纯虚函数允许在对应的抽象基类有一份自己的实现这个特性，只要在使用的时候需要明确的指令</li>
</ul>
</li>
<li><p>声明non-virtual 函数的目的是为了令derived classes 继承函数的接口及一份强制性实现</p>
<ul>
<li>non-virtual代表的意义：不变性凌驾于特异性，即他不应该在derived class中重新被定义</li>
</ul>
</li>
<li><p>只是继承接口，或者继承接口以及其一份实现，或者是继承接口和一份强制实现。由于这些不同类型的声明意味着并不相同的事情，当你声明你的成员函数的时候，必须要谨慎的做选择</p>
</li>
<li><p>请记住</p>
<ul>
<li>接口继承和实现继承不同。在public继承之下，derived classes总是继承base class的接口。</li>
<li>pure virtual函数只具体指定接口继承。</li>
<li>简朴的（非纯）impure virtual函数具体指定接口继承及缺省实现继承。</li>
<li>non-virtual函数具体指定接口继承以及强制性实现继承。</li>
</ul>
</li>
</ul>
<h4 id="条款35：考虑virtual函数以外的其他选择"><a href="#条款35：考虑virtual函数以外的其他选择" class="headerlink" title="条款35：考虑virtual函数以外的其他选择"></a>条款35：考虑virtual函数以外的其他选择</h4><ul>
<li>Template Method模式<ul>
<li>这个方法主张：virtual函数应该几乎总是private，较好的设计是保留一个指定函数（healthValue）为public的成员函数，但是并不是virtual，同时定义一个private virtual函数进行实际工作</li>
<li>这种方法在设计模式中又被叫做模板方法，它基类抽象工作流，工作流的部分逻辑交给字类覆写</li>
<li>这种手法的一个优点在于上述代码注释“做一些事前工作” （非virtual的函数）和“做一些事后工作”（private virtual函数）之中。</li>
<li>虽然这种手法定义的private virtual有限制（子类可以继承并定义私有的虚函数，虽然字类不可以调用从父类继承的私有虚函数，但是可以定义它），但是这并不妨碍对于事情解决的方便</li>
<li>当然在这种方法下面也有非virtual private 函数，比如需要调用base class的对象的时候。</li>
</ul>
</li>
<li>Strategy模式<ul>
<li>实现方法1：将virtual函数替换为“函数指针成员变量”。</li>
<li>实现方法2：以function成员变量替换virtual函数，因而允许任何可调用物搭配一个兼容于需求的签名式（调用形式）</li>
<li>实践方法3：将继承体系内的virtual函数替换为另一个继承体系内的virtual函数。</li>
</ul>
</li>
<li>请记住：<ul>
<li>virtual函数的替代方案包括NVI手法及Strategy设计模式的多种形式。NVI手法自身是一个特殊形式的Template Method设计模式。</li>
<li>将机能从成员函数移到class外部函数，带来的一个缺点是，非成员函数无法访问class的non-public成员。</li>
<li>tr1：：function 对象的行为就像一般函数指针。这样的对象可接纳“与给定之目标签名式（调用形式）兼容”的所有可调用物。</li>
</ul>
</li>
</ul>
<h4 id="条款-36：绝不重新定义继承而来的non-virtual函数"><a href="#条款-36：绝不重新定义继承而来的non-virtual函数" class="headerlink" title="条款 36：绝不重新定义继承而来的non-virtual函数"></a>条款 36：绝不重新定义继承而来的non-virtual函数</h4><ul>
<li>non-virtual 函数是静态绑定的，virtual函数是动态绑定的，如果重新定义了non-virtual函数则其决定元素不在自身，而在”指向该对象的指针“当初的声明类型，引用也会出现和指针一样的问题</li>
<li>重新定义继承而来的non-virtual函数违背了public继承是is-a的关系，同时还违背了non-virtual函数应该建立起一个不变性，凌驾于其特异性的特性；使得设计出现矛盾</li>
</ul>
<h4 id="条款37：绝不重新定义继承而来的缺省参数值"><a href="#条款37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37：绝不重新定义继承而来的缺省参数值"></a>条款37：绝不重新定义继承而来的缺省参数值</h4><ul>
<li>virtual函数是动态绑定而缺省参数值是静态绑定的，因此也会出现调用结果与设计初衷不同的现象</li>
<li>C++坚持静态绑定缺省参数值是因为为了保证运行期的效率，如果缺省参数值是动态绑定，则编译器需要有方法使得在运行期为virtual函数决定合适的参数缺省值，这将会更慢更复杂</li>
<li>而如果提供相同的缺省参数值给base和derive用户，会带来代码重复，从而导致相依性问题，如果一个进行改变，则所有derive classes都需要改变</li>
</ul>
<h4 id="条款38：通过复合塑膜出has-a或“根据某物实现出”"><a href="#条款38：通过复合塑膜出has-a或“根据某物实现出”" class="headerlink" title="条款38：通过复合塑膜出has-a或“根据某物实现出”"></a>条款38：通过复合塑膜出has-a或“根据某物实现出”</h4><ul>
<li>复合(composition)的意义和 public 继承完全不同。</li>
<li>复合意味着has-a（有一个）或者is-implemented-in-terms-of（根据某物实现出），当复合发生于应用域内的对象之间，表现出 has-a 的关系:当它发生于实现域内则是表现is-implemented-in-terms-of的关系。</li>
</ul>
<h4 id="条款39-明智而审慎地使用private-继承"><a href="#条款39-明智而审慎地使用private-继承" class="headerlink" title="条款39:明智而审慎地使用private 继承"></a>条款39:明智而审慎地使用private 继承</h4><ul>
<li><p>private 继承并不意味 is-a 关系，如果classes 之间的继承关系是 private，编译器不会自动将一个 derived class 对象(例如student)转换为一个 base class 对象(例如 Person)，由 private baseclass 继承而来的所有成员，在 derived class 中都会变成 private 属性，纵使它们在base class 中原本是 protected 或 public 属性。</p>
</li>
<li><p>Private 继承意味 implemented-in-terms-of(根据某物实现出)如果你让 class D以 private 形式继承 cass B，你的用意是了采用 class B内已经备妥的某些特性，不是因为 B对象和 D对象存在有任何观念上的关系。private 继承纯粹只是一种实现技术(这就是为什么继承自一个 private baseclass的每样东西在你的class内都是private:因为它们都只是实现枝节而已)。</p>
</li>
<li><p>尽可能使用复合，必要时才使用 private 继承。</p>
<ul>
<li>private 继承并非绝对必要。如果我们决定以复合(composition)取而代之,是可以的。只要在 widget 内声明一个嵌套式 private class，后者以 public 形式继承 Timer 并重新定义 onTick，然后放一个这种类型的对象于 widget 内。这个设计比只使用 private 继承要复杂一些些,因为它同时涉及 public 继承和复合，并导入一个新 class (widgetTimer)。</li>
<li>设计 widget 使它得以拥有 derived classes，但同时想阻止derived classes 重新定义 onTick。如果 widget 继承自 Timer，上面的想法就不可能实现，即使是 private 继承也不可能。如果 widgetTimer是 widget内部的一个 private 成员并继承 Timer，widget 的 derived classes 将无法取用widgetTimer，因此无法继承它或重新定义它的 irtual函数。</li>
<li>将 widget 的编译依存性降至最低。如果 widget 继承Timer，当widget 被编译时 Timer的定义必须可见，所以定义 widget 的那个文件恐怕必须#include Timer.h。但如果widgetTimer 移出widget 之外而widget内含指针指向一个widgetTimer，widget 可以只带着一个简单的widgetTimer 声明式不再需要#include 任何与 Timer 有关的东西。</li>
</ul>
</li>
<li><p>和复合(composition不同，private 继承可以造成empty base 最优化。这对致力于“对象尺寸最小化”的程序库开发者而言，可能很重要。EBO(emptbaseoptimization;空白基类最优化)，EBO一般只在单一继承(而非多重继承)下才可行，统治 C++对象布局的那些规则通常表示EBO无法被施行于“拥有多个 base”的derived classes 身上；大多数 classes 并非 empty，所以 EBO 很少成为private继承的正当理由。</p>
</li>
<li><p>当你面对“并不存在 is-a 关系”的两个 classes，其中一个需要访问另一个的protected 成员，或需要重新定义其一或多个 virtual函数，private 继承极有可能成为正统设计策略；在考虑过所有其他方案之后，如果仍然认为 private 继承是“表现程序内两个 classes 之间的关系”的最佳办法，这才用它</p>
</li>
</ul>
<h4 id="条款40-明智而审慎地使用多重继承"><a href="#条款40-明智而审慎地使用多重继承" class="headerlink" title="条款40:明智而审慎地使用多重继承"></a>条款40:明智而审慎地使用多重继承</h4><ul>
<li><p>当多重继承(multiple inheritance; MI)进入设计景框,序有可能从一个以上的 baseclasses 继承相同名称(如函数、typedef等等)。那会导致较多的歧义 (ambiguity)机会。</p>
<ul>
<li>成员函数的歧义：与C++ 用来解(resolving)重载函调用的规则相符，在看到是否有个函数可取用之前，C++ 首先确认这个函数对此调用之言是最佳匹配找出最佳匹配函数后才检验其可取用性。两个函数签名相同的成员函数有相同的匹配程度，没有所谓最佳匹配。因此调用会产生歧义</li>
<li>菱形继承问题：有一个继承体系而其中某个base class和某个derived class之间有一条以上的相通路线<ul>
<li>缺省做法是执行复制：让 base class内的成员变量经由每一条路径被复制</li>
<li>令那个带有此数据的 class (也就是Eile)成为一个 virtual base class。</li>
</ul>
</li>
</ul>
</li>
<li><p>virtual 继承将带来代价</p>
<ul>
<li>从正确行为的观点看，public 继承应该总是 virtual。如果这是唯一一个观点，规则很简单:任何时候当你使用 public 继承，请改用 virtual public 继承。但是，正确性并不是唯一观点。</li>
<li>为避免继承得来的成员变量重复，编译器必须提供若干幕后戏法，而其后果是:使用 virtual 继承的那些 classes 所产生的对象往往比使用non-virtual继承的兄弟们体积大，访问 virtual base classes 的成员变量时，也比访问non-virtua lbase classes 的成员变量速度慢。种种细节因编译器不同而异</li>
<li>virtual继承的成本还包括其他方面。支配“virtual base classes 初始化”的规则比起non-virtual bases 的情况远为复杂且不直观<ul>
<li>classes 若派生自 virtualbases而需要初始化，必须认知其virtual bases不论那些 bases 距离多远</li>
<li>当一个新的 derived class 加入继承体系中，它必须承担其 virtual bases(不论直接或间接)的初始化责任</li>
</ul>
</li>
</ul>
</li>
<li><p>非必要不使用 virtual bases。平常请使用non-virtual继承。如果必须使用 virtualbase classes，尽可能避免在其中放置数据。这么一来就不需担心这些 classes 身上的初始化(和赋值)所带来的诡异事情</p>
</li>
<li><p>多重继承也有它的合理用途</p>
<ul>
<li>如果你唯一能够提出的设计方案涉及多重继承，你应该更努力想一想一一几乎可以说一定会有某些方案让单一继承行得通。然而多重继承有时候的确是完成任务之最简洁、最易维护、最合理的做法，果真如此就别害怕使用它</li>
</ul>
</li>
<li><p>请记住</p>
<ul>
<li>多重继承比单一继承复杂。它可能导致新的歧义性，以及对 virtua 继承的需要</li>
<li>virtual继承会增加大小速度、初始化(及赋值)复杂度等等成本。如果 virtualbaseclasses 不带任何数据，将是最具实用价值的情况。</li>
<li>多重继承的确有正当用途。其中一个情节涉及“public 继承某个Interface class和“private继承某个协助实现的class”的两相组合</li>
</ul>
</li>
</ul>
<h3 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h3><h4 id="条款-41-了解隐式接口和编译期多态"><a href="#条款-41-了解隐式接口和编译期多态" class="headerlink" title="条款 41:了解隐式接口和编译期多态"></a>条款 41:了解隐式接口和编译期多态</h4><ul>
<li>面向对象编程世界总是以显式接口 (explicit interfaces)和运行期多态(runtime polymorphism)解决问题<ul>
<li>由于 w的类型被声明为 widget，所以 w必须支持 widget 接口。称此为一个显式接口 (explicit interface)，也就是它在源码中明确可见。</li>
<li>由于widget 的某些成员函数是 virtual，w对那些函数的调用将表现出运行期多态(runtime polymorphism)，也就是说将于运行期根据w的动态类型决定究竟调用哪一个函数。</li>
</ul>
</li>
<li>Templates 及泛型编程的世界，与面向对象有根本上的不同。在此世界中显式接口和运行期多态仍然存在，但重要性降低。反倒是隐式接口 (implicit interfaces)和编译期多态(compile-time polymorphism)移到前头了<ul>
<li>w必须支持哪一种接口，系由 template 中执行于w身上的操作来决定</li>
<li>“以不同的template 参数具现化 function templates”会导致调用不同的函数，这使是所谓的编译期多态(compile-time polymorphism)</li>
</ul>
</li>
<li>“运行期多态”和“编译期多态”之间的差异类似于“哪一个重该被用”(发在编期)“哪一个virtual函数该被绑定” (发生在运行期)之间的差异。</li>
<li>显式接口和隐式接口的差异<ul>
<li>通常显式接口由函数的签名式(也就是函数名称、参数类型、返回类型)构成</li>
<li>隐式接口并不基于函数签名式，而是由有效表达式 (valid expressions)组成。</li>
<li>加诸于 template 参数身上的隐式接口，就像加诸于 class 对象身上的显式接口一样真实，而且两者都在编译期完成检查。就像无法以一种“与 class 提供之显式接口矛盾”的方式来使用对象(代码将通不过编译)，也无法在 template 中使用“不支持 template所要求之隐式接口”的对象(代码一样通不过编译)。</li>
</ul>
</li>
<li>请记住<ul>
<li>classes 和 templates 都支持接口 (interfaces)和多态(polymorphism)</li>
<li>对 classes 而言接口是显式的(explicit),以函数签名为中心。多态则是通过 virtual函数发生于运行期。</li>
<li>对 template 参数而言，接口是隐式的(implicit)，奠基于有效表达式。多态则是通过template具现化和函数重载解析(function overloading resolution)发生于编译期。</li>
</ul>
</li>
</ul>
<h4 id="条款42-了解-typename-的双重意义"><a href="#条款42-了解-typename-的双重意义" class="headerlink" title="条款42:了解 typename 的双重意义"></a>条款42:了解 typename 的双重意义</h4><ul>
<li>从C++ 的角度来看，声明 template 参数时，不论使用关键字 class 或typename，意义完全相同。</li>
<li>template 内出现的名称如果相依于某个template 参数，称之为从属名称(dependentnames)。如果从属名称在 class 内呈套状，我们称它为套从属名称(nested dependent name) c::const iterator就是这样一个名称。嵌套从属名称有可能导致解析(parsing)困难。<ul>
<li>C::const iterator* x;看起来好像我们声明x为一个 local 变量，它是个指针，指向一个C::const iterator。但它之所以被那么认为，只因为我们“已经知道”C::const iterator 是个类型。如果 C::const iterator 不是个类型呢? </li>
<li>C++有个规则可以解析(resolve)此一歧义状态如果解析器在 template 中遭遇个嵌套从属名称，它便假设这名称不是个类型，除非你告诉它是。所以缺省情况下嵌套从属名称不是类型。</li>
<li>一般性规则很简单:任何时候当你想要在 template 中指涉一个套从属类型名称，就必须在紧临它的前一个位置放上关键字 typename。typename只被用来验明套从属类型名称其他名称不该有它存在。</li>
<li>typename 必须作为套从属类型名称的前缀词”这一规则的例外是，typename 不可以出现在 base classes list 内的套从属类型名称之前，也不可在member initialization list(成员初值列)中作为 base class 修饰符。</li>
</ul>
</li>
<li>请记住<ul>
<li>声明 temmplate 参数时，前缀关键字 class和 typename 可互换</li>
<li>请使用关键字 typename标识嵌从属类型名称不得在 base class lists(基类列)或member initialization list (成员初值列)内以它作为 base class 修饰符</li>
</ul>
</li>
</ul>
<h4 id="条款43-学习处理模板化基类内的名称"><a href="#条款43-学习处理模板化基类内的名称" class="headerlink" title="条款43:学习处理模板化基类内的名称"></a>条款43:学习处理模板化基类内的名称</h4><ul>
<li>当编译器遭遇class template LoggingMsgSender 定义式时，并不知道它继承什么样的class。当然它继承的是MsqSender<Company>，但其中的Company是个 template 参数，不到后来无法确切知道它是什么。而如果不知道Company是什么，就无法知道class MsgSender<Company>看起来像什么-更明确地说是没办法知道它是否有个 sendclear函数。因此编译器看不到它们</li>
<li>一般性的MsgSender template 对 Companyz并不合适，因为那个template提供了一个 sendclear 函数(其中针对其类型参数 Company 调用了 sendcleartext函数数)，而这对 Companyz对象并不合理。欲矫正这个问题，可以针对 Companyz产生一个 MsgSender特化版template&lt;&gt; class MsgSender<CompanyZ> <ul>
<li>class 定义式最前头的“template&lt;&gt;”语法象征这既不是 template 也不是标准class，而是个特化版的 MsqSender template，在template 实参是 Companyz时被使用。这是所谓的模板全特化(total template specialization)</li>
<li>template MsgSender针对类型 companyz 特化了，而且其特化是全面性的，也就是说一旦类型参数被定义为 Companyz，再没有其他 template 参数可供变化。</li>
<li>当base class 被指定为MsgSender<Companyz>时, 并未提供 sendclear函数，因此代码不合法。那就是为什么C++ 拒绝这个调用的原因:它知道 base class templates 有可能被特化，而那个特化版本可能不提供和-般性template相同的接口。因此它往往拒绝在templatized base classes(模板化基类)内寻找继承而来的名称。</li>
<li>就某种意义而言，从 Object Oriented C++ 跨进 Template C++ ，继承就不像以前那般畅行无阻了</li>
</ul>
</li>
<li>有三个办法令 C++“不进入 templatized base classes观察”的行为失效<ul>
<li>第一是在 base class 函数调用动作之前加上”this-&gt;”</li>
<li>第二是使用 using声明式。<ul>
<li>条款33描述using声明式如何将“被掩盖的 baseclass 名称”带入一个derivedclass 作用域内。</li>
<li>两处解决的问题其实不相同。这里的情况并不是 base class 名称被 derived class 名称遮掩，而是编译器不进入 base class 作用域内查找，于是我们通过using 诉它，请它那么做。</li>
</ul>
</li>
<li>第三个做法是，明白指出被调用的函数位于 base class 内:MsgSender<Company>::sendClear(info);<ul>
<li>这往往是最不让人满意的一个解法，因为如果被调用的是 virtual 函数，上述的明确资格修饰(explicitqualification)会关闭“virtual绑定行为”</li>
</ul>
</li>
<li>从名称可视点(visibility point)的角度出发，上述每一个解法做的事情都相同对编译器承诺“base class template 的任何特化版本都将支持其一般(泛化)版本提供的接口”。</li>
</ul>
</li>
<li>面对“指涉 base class members”之无效references编译器的诊断时间可能发生在早期(当解析 derived class template 的定义式时)也可能发生在晚期(当那些 teplates 被特定之 template 实参具现化时)。C++的政策是宁愿较早诊断，这就是为什么“当base classes 从 templates 中被具现化时它假设它对那些base classes 的内容毫无所悉的缘故。</li>
<li>请记住<ul>
<li>可在 derived class templates 内通过“this-&gt;”指涉 base class templates 内的成员名称，或藉由一个明白写出的“base class 资格修饰符”完成。</li>
</ul>
</li>
</ul>
<h4 id="条款44-将与参数无关的代码抽离-templates"><a href="#条款44-将与参数无关的代码抽离-templates" class="headerlink" title="条款44:将与参数无关的代码抽离 templates"></a>条款44:将与参数无关的代码抽离 templates</h4><ul>
<li><p>Templates 是节省时间和避免代码重复的一个奇方妙法</p>
<ul>
<li>使用 teplates 可能会导致代码膨胀(code bloat):其二进制码带着重复(或几乎重复)的代码、数据，或两者。其结果有可能源码看起来合身而整齐，但目标码 (obiect code) 却不是那么回事。</li>
<li>当你编写某个函数，而你明白其中某些部分的实现码和另一个函数的实现码实质相同，你会很单纯地重复这些码吗?当然不。你会抽出两个函数的共同部分，把它们放进第三个函数中，然后令原先两个函数调用这个新函数。也就是说，你分析了两个函数，找出共同的部分和变化的部分，把共同部分搬到一个新函数去，保留变化的部分在原函数中不动。同样道理，如果你正在编写某个 class，而你明白其中某些部分和另一个 class 的某些部分相同，你也不会重复这共同的部分。取而代之的是你会把共同部分搬移到新 class 去，然后使用继承或复合令原先的 classes 取用这共同特性。而原 classes 的互异部分(变异部分)仍然留在原位置不动。</li>
<li>编写 temmplates 时，也是做相同的分析，以相同的方式避免重复，但其中有个窍门。在non-template 代码中，重复十分明确:你可以“看”到两个函数或两个classes之间有所重复。然而在 template 代码中，重复是隐的:毕竟只存在一份 template源码，所以你必须训练自己去感受当 template 被具现化多次时可能发生的重复</li>
</ul>
</li>
<li><p>请记住</p>
<ul>
<li>Templates 生成多个classes 和多个函数，所以任何 template代码都不该与某个造成膨胀的template 参数产生相依关系。</li>
<li>因非类型模板参数(non-type template parameters)而造成的代码膨胀，往往可消除，做法是以函数参数或class 成员变量替换 template 参数</li>
<li>因类型参数(type parameters)而造成的代码膨胀，往往可降低，做法是让带有完全相同二进制表述(binary representations)的具现类型(instantiation types)共享实现码。</li>
</ul>
</li>
</ul>
<h4 id="条款45-运用成员函数模板接受所有兼容类型"><a href="#条款45-运用成员函数模板接受所有兼容类型" class="headerlink" title="条款45:运用成员函数模板接受所有兼容类型"></a>条款45:运用成员函数模板接受所有兼容类型</h4><ul>
<li><p>真实指针做得很好的一件事是，支持隐式转换 (implicit conversions)。Derivedclass指针可以隐式转换为 base class 指针，“指non-const对象”的指针可以转换为“指向 const 对象”······等等。STL容器的选代器几乎总是智能指针;但如果想在用户自定的智能指针中模拟上述转换，稍稍有点麻烦</p>
<ul>
<li>同一个 temmplate 的不同具现体(instantiations)之间并不存在什么与生俱来的固有关系，如以带有 base-derived 关系的 BD两类型分别具现化某个 template，产生出来的两个具现体并不带有 base-derived 关系，为了获得SmartPtr classes 之间的转换能力，必须将它们明确地编写出来</li>
</ul>
</li>
<li><p>Templates 和泛型编程(Generic Programming）</p>
<ul>
<li><p>需要的不是为 SmartPtr写一个构造函数,而是为它写一个构造模板。这样的模板(templates)是所谓member function templates(常简称为 member templates)，其作用是为 class 生成函数</p>
</li>
<li><p>对任何类型T和任何类型u这里可以根据SmartPtr<u>生成一个SmartPtr<T>–因为SmartPtr<T>有个构造函数接受一个SmartPtr<U>参数。这一类构造函数根据对象 u 创建对(例如根据 SmartPtr<u> 创建一个SmartPtr<T>)，而u和v的类型是同一个template 的不同具现体，有时我们称之为泛化(generalized)copy构造函数。</p>
</li>
<li><p>上面的泛化 copy构造函数并未被声明为 explicit。那是蓄意的，因为原始指针类型之间的转换(例如从 derived class 指针转为 base class 指针)是隐式转换，无需明白写出转型动作(cast)，所以让智能指针仿效这种行径也属合理</p>
</li>
<li><p>完成声明之后，这个为 Smartptr而写的“泛化 copy构造函数”提供的东西比我们需要的更多。必须从某方面对这一member template所创建的成员函数群进行拣选或筛除</p>
<ul>
<li><p>假设 SmartPtr遵循 auto ptr 和 trl::shared ptr 所提供的榜样，也提供个 get 成员函数，返回智能指针对象所持有的那个原始指针的副本，那么我们可以在“构造模板”实现代码中约束转换行为</p>
<p>SmartPtr(const SmartPtr<U>&amp; other): heldPtr(other,get()) { … }</p>
</li>
<li><p>使用成员初值列(member initialization list)来初始化SmartPtr<T>之内类型为T*的成员变量，并以类型为 U* 的指针(由Smartptr<u> 持有)作为初值。这个行为只有当“存在某个隐式转换可将一个 U*指针转为一个 T指针”时才能通过编译，而那正是我们想要的。最终效益是 SmartPtr<T>现在有了一个泛化 cop)构造函数，这个构造函数只在其所获得的实参隶属适当(兼容)类型时才通过编译</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>member functiontemplates(成员函数模板)的效用不限于构造函数，它们常扮演的另一个角色是支持赋值操作</p>
<ul>
<li>例如TRI的 shared ptr 支持所有“来自兼容之内置指针、trl::shared ptrs、auto ptrs 和trl::weak ptrs”的构造行为，以及所有来自上述各物的赋值操作</li>
<li>上述所有构造函数都是 explicit，惟有“泛化 copy构造函数”除外。那意味从某个 shared ptr类型隐式转换至另一个 shared ptr类型是被允许的，但从某个内置指针或从其他智能指针类型进行隐式转换则不被认可</li>
<li>trl::shared ptr 造函数和assignment 操作符的 auto ptrs 并被声明为 const，与之形成对比的则是trl::shared ptrs  trl::weak ptrs 都以 const 传递。这是因为当你复制一个 auto ptrs，它们其实被改动了</li>
</ul>
</li>
<li><p>member templates 并不改变语言规则，而语言规则说，如果程序需要一个 copy构造函数，你却没有声明它，编译器会为你暗自生成一个。在 class内声明泛化 copy构造函数(是个member template)并不会阻止编译器生成它们自己的copy构造函数(一个non-teplate)，所以如果你想要控制 copy构造的方方面面，你必须同时声明泛化 copy 构造函数和“正常的”copy 构造函数。相同规则也适用于赋值 (assignment)操作。</p>
</li>
<li><p>请记住</p>
<ul>
<li>请使用member function templates(成员函数模板)生成“可接受所有容类型的函数。<br>如果你声明 member templates 用于“泛化copy构造或“泛化assignment操作”你还是需要声明正常的copy构造函数和copyassignment操作符。</li>
</ul>
</li>
</ul>
<h4 id="条款46-需要类型转换时请为模板定义非成员函数"><a href="#条款46-需要类型转换时请为模板定义非成员函数" class="headerlink" title="条款46:需要类型转换时请为模板定义非成员函数"></a>条款46:需要类型转换时请为模板定义非成员函数</h4><ul>
<li><p>惟有 non-member 函数才有能力“在所有实参身上实施隐式类型转换”，但是化的类型转化规则和其non-template 版本不同。在non-template 版本中，编译器知道尝试调用什么函数，但这里编译器不知道模板想要调用哪个函数。为完成这一具现化行动，必须先算出T是什么</p>
<ul>
<li>template 实参推导过程中从不将隐式类型转换函数纳入考虑。这样的转换在函数调用过程中的确被使用，但在能够调用一个函数之前，首先必须知道那个函数存在。而为了知道它，必须先为相关的function template 推导出参数类型(然后才可将适当的函数具现化出来)。然而 template 实参推导过程中并不考虑采纳“通过构造函数而发生的”隐式类型转换。</li>
</ul>
</li>
<li><p>template class内的 friend 声明式可以指涉某个特定函数</p>
<ul>
<li>classRational<T>可以声明 operator* 是它的一个 fiend 函数。Class templates 并不倚赖template 实参推导，所以编译器总是能够在 class Rational<T>具现化时得知T。</li>
<li>因为当对象 oneHalf 被声明为一个Rational<int>，class Rational<int>于是被具现化出来，而作为过程的一部分，fiend 函数operator*(接受 Rational<int>参数)也就被自动声明出来后者身为一个函数而非函数模板 (function template)，因此编译器可在调用它时使用隐式转换函数(例如Rational的non-explicit 构造函数)，而这便是混合式调用之所以成功的原因</li>
<li>虽然使用 friend，却与 friend 的传统用途“访问class的non-public 成分”毫不相干。为了让类型转换可能发生于所有实参身上我们需要一个 non-member 函数;为了令这个函数被自动具现化，需要将它声明在class内部:而在class 内部声明non-member 函数的唯一办法就是令它成为一个 friend。</li>
</ul>
</li>
<li><p>请记住</p>
<ul>
<li>当我们编写一个class template，而它所提供之“与此 template 相关的”函数支持“所有参数之隐式类型转换”时，请将那些函数定义为“class template 内部的 friend函数”</li>
</ul>
</li>
</ul>
<h4 id="条款47-请使用-traits-classes-表现类型信息"><a href="#条款47-请使用-traits-classes-表现类型信息" class="headerlink" title="条款47:请使用 traits classes 表现类型信息"></a>条款47:请使用 traits classes 表现类型信息</h4><ul>
<li>STL 选代器分类(categories)</li>
<li>Input 选代器只能向前移动，一次一步，客户只可读取(不能涂写)它们所指的东西，而且只能读取一次。它们模仿指向输入文件的阅读指针 (read pointer);C++ 程库中的istream iterators 是这一分类的代表。</li>
<li>Output选代器情况类似，但一切只为输出它们只向前移动，一次一步，客户只可涂写它们所指的东西，而且只能涂写一次它们模仿指向输出文件的涂写指针 (write pointer);ostream iterators 是这一类的代表。这是威力最小的两个迭代器分类。由于这两类都只能向前移动，而且只能读或写其所指物最多一次，所以它们只适合“一次性操作算法” (one-pass algorithms)</li>
<li>另一个威力比较强大的分类是 forward选代器。这种迭代器可以做前述两种分类所能做的每一件事，而且可以读或写其所指物一次以上。这使得它们可施行于多次性操作算法(multi-pass algorithms)。STL并未提供单向 linked list，但某些程库有(通常名为 slist)，而指入这种容器的选代器就是属于 forward选代器</li>
<li>Bidirectional迭代器比上一个分类威力更大:它除了可以向前移动，还可以向后移动。STL的list迭代器就属于这一分类，set,multiset,map和multimap的选代器也都是这一分类。</li>
<li>最有威力的选代器当属 random access选代器。这种选代器比上一个分类威力更大的地方在于它可以执行“迭代器算术”，也就是它可以在常量时间内向前或向后跳跃任意距离。这样的算术很类似指针算术那并不令人惊讶因为 randomaccess选代器正是以内置(原始)指针为榜样，而内置指针也可被当做 random access代器使用。vector,deque和 string提供的选代器都是这一分类。</li>
<li>这些structs 之间的继承关系是有效的 is-a关系，所有 forward迭代器都是 input迭代器，依此类推</li>
<li>advance函数<ul>
<li>advance的策略之一是采用“最低但最及”的迭代器能力，以循环反复递增或递减选代器。然而这种做法耗费线性时间。我们知道 random access选代器支持迭代器算术运算，只耗费常量时间，因此如果面对这种迭代器，我们希望运用其优势。</li>
<li>这种做法首先必须判断 iter是否为 random access选代器也就是说需要知道类型IterT是否为random access选代器分类。换话说我们需要取得类型的某些信息。那就是 traits 让你得以进行的事:它们允许你在编译期间取得某些类型信息</li>
<li>Traits 并不是 C++ 关键字或一个预先定义好的构件它们是一种技术，也是一个 C++ 程序员共同遵守的协议。这个技术的要求之一是，它对内置 (built-in)类型和用户自定义(user-defined)类型的表现必须一样好举</li>
<li>类型的 traits 信息必须位于类型自身之外。标准技术是把它放进一个 template 及其一或多个特化版本中。这样的 templates 在标准程序库中有若干个，其中针对迭代器者被命名为 iterator traits<ul>
<li>iterator traits的运作方式是，针对每一个类型 IterT，在struct iteratortraits<IterT>内一定声明某个 typedef 名为iterator category。这个 typedef用来确认 IterT的代器分类。</li>
<li>iterator traits 以两个部分实现上述所言。首先它要求每一个“用户自定义的迭代器类型”必须套一个typedef，名为 iterator category，用来确认适当的卷标结构 (tag struct)</li>
<li>为了支持指针迭代器，iterator traits 特别针对指针类型提供一个偏特化版本(partialtemplate specialization)。</li>
</ul>
</li>
</ul>
</li>
<li>如何设计并实现一个 traits class<ul>
<li>确认若干你希望将来可取得的类型相关信息。例如对迭代器而言，我们希望将来可取得其分类(category)。</li>
<li>为该信息选择一个名称 (例如 iterator category)。</li>
<li>提供一个 template 和一组特化版本(例如稍早说的 iterator traits)，内含你希望支持的类型相关信息。</li>
</ul>
</li>
<li>IterT类型在编译期间获知所以iterator traits<IterT>;:iterator_category也可在编译期间确定。但if语句却是在运行期才会核定。为什么将可在编译期完成的事延到运行期才做呢?这不仅浪费时间，也造成可执行文件膨胀。<ul>
<li>真正想要的是一个条件式(也就是一个 if…else 语)“编译期核定成功”之类型。恰巧C++ 有一个取得这种行为的办法那就是重载(overloading)</li>
<li>当你重载某个函数 f，你必须详细叙述各个重载的参数类型。当你用 f编译器便根据传来的实参选择最适当的重载件。编译器的态度是“如果这个重载件最匹配传递过来的实参，就调用这个 f:如果那个重载件最匹配，就调用那个 f</li>
<li>有了doAdvance重载版本，advance需要做的只是调用它们并额外传递一个对象，后者必须带有适当的迭代器分类。于是编译器运用重载解析机制(overloading resolution)调用适当的实现代码</li>
</ul>
</li>
<li>如何使用一个 traits class<ul>
<li>建立一组重载函数(身份像劳工)或函数模板(例如 doAdvance)，彼此间的差异只在于各自的traits 参数令每个函数实现码与其接受之 traits 信息相应和</li>
<li>建立一个控制函数(身份像工头)或函数模板(例如 advance)，它调用上述那些“劳工函数”并传递traits class 所提供的信息。</li>
</ul>
</li>
<li>请记住<ul>
<li>Traits classes 使得“类型相关信息”在编译期可用。它们以templates 和“templates特化”完成实现。<br>整合重载技术(overloading)后，traits classes 有可能在编译期对类型执行if…else测试。</li>
</ul>
</li>
</ul>
<h4 id="条款48-认识-template元编程"><a href="#条款48-认识-template元编程" class="headerlink" title="条款48:认识 template元编程"></a>条款48:认识 template元编程</h4><ul>
<li>Template metaprogramming(TMP，模板元编程)是编写template-based C++程序并执行于编译期的过程。所谓template metaprogram(模板元程序)是以 C++ 写成、执行于 C++ 编译器内的程序。一旦TMP 结束执行其输出，也就是从 templates 具现出来的若干 C++ 源码，便会一如往常地被编译</li>
<li>TMP 有两个伟大的效力<ul>
<li>第一，它让某些事情更容易。如果没有它，那些事情将是困难的，甚至不可能的。</li>
<li>第二，由于 template metaprograms 执行于C++ 编译期，因此可将工作从运行期转移到编译期。这导致的一个结果是，某些错误原本通常在运行期才能侦测到，现在可在编译期找出来。另一个结果是，使用 TMP的C++程序可能在每一方面都更高效:较小的可执行文件、较短的运行期、较少的内存需求。然而将工作从运行期移转至编译期的另一个结果是，编译时间变长了。程序如果使用 TMP，其编译时间可能远长于不使用TMP 的对应版本</li>
</ul>
</li>
<li>编译器必须确保所有源码都有效，纵使是不会执行起来的代码；而当iter不是 random access迭代器时“iter +&#x3D; d”无效。与此对比的是 traits-based TMP 解法，其针对不同类型而进行的代码，被拆分为不同的函数，每个函数所使用的操作(操作符)都可施行于该函数所对付的类型。</li>
<li>TMP并没有真正的循环构件，所以循环效果系由递归 (recursion)完成；TMP 主要是个“函数式语言” (functional language)，TMP的递归甚至不是正常种类，因为 TMP 循环并不涉及递归数调用，而是涉及“递归模板具现化” (recursive template instantiation)</li>
<li>请记住<ul>
<li>Template metaprogramming(TMP，模板元编程)可将工作由运行期移往编译期因而得以实现早期错误侦测和更高的执行效率。</li>
<li>TMP可被用来生成“基于政策选择组合” (based on combinations of policychoices)的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码</li>
</ul>
</li>
</ul>
<h2 id="现代C-实战30讲"><a href="#现代C-实战30讲" class="headerlink" title="现代C++实战30讲"></a>现代C++实战30讲</h2><h4 id="课前必读-2讲"><a href="#课前必读-2讲" class="headerlink" title="课前必读 (2讲)"></a>课前必读 (2讲)</h4><h4 id="00丨开篇词丨C-这么难，为什么我们还要用C-？"><a href="#00丨开篇词丨C-这么难，为什么我们还要用C-？" class="headerlink" title="00丨开篇词丨C++这么难，为什么我们还要用C++？"></a>00丨开篇词丨C++这么难，为什么我们还要用C++？</h4><ul>
<li><p>C++ 是一门多范式的通用编程语言。</p>
<ul>
<li>多范式，是因为 C++ 支持面向过程编程，也支持面向对象编程，也支持泛型编程，新版本还可以说是支持了函数式编程。同时，上面这些不同的范式，都可以在同一项目中组合使用，这就大大增加了开发的灵活性。因此，C++ 适用的领域非常广泛，小到嵌入式，大到分布式服务器，到处可以见到 C++ 的身影。</li>
</ul>
</li>
<li><p>C++ 的核心竞争力</p>
<ul>
<li>抽象能力：意味着较高的开发效率，同时，更重要的是，不会因抽象而降低性能。</li>
<li>性能：这不用多说了，就是快并且占用资源少。</li>
<li>功耗：这是近年来我们越来越关注的问题，跟性能直接相关，性能好了功耗自然就低</li>
</ul>
</li>
<li><p>C++ 既然性能又好，又支持抽象，为什么没有更流行呢？</p>
<ul>
<li>代价更高。C++ 是一种复杂的语言，难以上手和熟练掌握，因此也是一种比较容易出错、被误用的语言。C++ 一直与 C 基本保持了向后兼容性，这种兼容性，也一直是 C++的安全性和易用性方面的负担。C++ 比起 C 来，要更安全，更不容易出现缓冲区溢出这类漏洞，但跟没有指针概念的语言比起来，它仍然是一种“不安全”的语言</li>
<li>你在开发上额外付出的时间，能从性能上省回来吗？<ul>
<li>取决于你开发软件的用途和开发时间。</li>
<li>当你的软件属于运算密集或者内存密集型，你需要性能、且愿意为性能付出额外代价的时候，应该考虑用 C++，特别在你的代码需要部署在多台服务器或者移动设备的场合。</li>
<li>反之，如果性能不会成为你开发的软件的瓶颈，那 C++ 可能就不是一个最合适的工具。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="基础篇-9讲"><a href="#基础篇-9讲" class="headerlink" title="基础篇 (9讲)"></a>基础篇 (9讲)</h3><h4 id="01丨堆、栈、RAII：C-里该如何管理资源？"><a href="#01丨堆、栈、RAII：C-里该如何管理资源？" class="headerlink" title="01丨堆、栈、RAII：C++里该如何管理资源？"></a>01丨堆、栈、RAII：C++里该如何管理资源？</h4><ul>
<li><p>基本概念</p>
<ul>
<li><p>堆，英文是 heap，在内存管理的语境下，指的是动态分配内存的区域。这个堆跟数据结构里的堆不是一回事。这里的内存，被分配之后需要手工释放，否则，就会造成内存泄漏。</p>
</li>
<li><p>C++ 标准里一个相关概念是自由存储区，英文是 free store，特指使用 new 和 delete 来分配和释放内存的区域。一般而言，这是堆的一个子集：</p>
<ul>
<li>new 和 delete 操作的区域是 free store</li>
<li>malloc 和 free 操作的区域是 heap</li>
</ul>
<p>new 和 delete 通常底层使用 malloc 和 free 来实现，所以 free store 也是 heap。对其区分的实际意义并不大</p>
</li>
<li><p>栈，英文是 stack，在内存管理的语境下，指的是函数调用过程中产生的本地变量和调用数据的区域。这个栈和数据结构里的栈高度相似，都满足“后进先出”（last-in-first-out 或LIFO）。</p>
</li>
<li><p>RAII，完整的英文是 Resource Acquisition Is Initialization，是 C++ 所特有的资源管理方式；RAII 依托栈和析构函数，来对所有的资源——包括堆内存在内——进行管理。对 RAII 的使用，使得 C++ 不需要类似于 Java 那样的垃圾收集方法，也能有效地对内存进行管理</p>
</li>
</ul>
</li>
<li><p>堆</p>
<ul>
<li><p>在堆上分配内存，有些语言可能使用 new 这样的关键字，有些语言则是在对象的构造时隐式分配，不需要特殊关键字。不管哪种情况，程序通常需要牵涉到三个可能的内存管理器的操作</p>
<ul>
<li>让内存管理器分配一个某个大小的内存块</li>
<li>让内存管理器释放一个之前分配的内存块</li>
<li>让内存管理器进行垃圾收集操作，寻找不再使用的内存块并予以释放</li>
</ul>
</li>
<li><p>上面的三个操作都不简单，并且彼此之间是相关的。</p>
<ul>
<li>分配内存要考虑程序当前已经有多少未分配的内存。内存不足时要从操作系统申请新的内存。内存充足时，要从可用的内存里取出一块合适大小的内存，做簿记工作将其标记为已用，然后将其返回给要求内存的代码。</li>
<li>释放内存不只是简单地把内存标记为未使用。对于连续未使用的内存块，通常内存管理器需要将其合并成一块，以便可以满足后续的较大内存分配要求</li>
</ul>
</li>
<li><p>漏掉 delete 是一种常见的情况，这叫“内存泄漏”</p>
<ul>
<li>中间省略的代码部分也许会抛出异常，导致最后的 delete ptr 得不到执行。</li>
<li>代码不符合 C++ 的惯用法。在 C++ 里，这种情况下有 99% 的可能性不应该使用堆内存分配，而应使用栈内存分配</li>
<li>分配和释放不在一个函数里</li>
</ul>
</li>
</ul>
</li>
<li><p>栈</p>
<ul>
<li>栈是向上增长的。在包括 x86 在内的大部分计算机体系架构中，栈的增长方向是低地址，因而上方意味着低地址。任何一个函数，根据架构的约定，只能使用进入函数时栈指针向上部分的栈空间。当函数调用另外一个函数时，会把参数也压入栈里（我们此处忽略使用寄存器传递参数的情况），然后把下一行汇编指令的地址压入栈，并跳转到新的函数。新的函数进入后，首先做一些必须的保存工作，然后会调整栈指针，分配出本地变量所需的空间，随后执行函数中的代码，并在执行完毕之后，根据调用者压入栈的地址，返回到调用者未执行的代码中继续执行。</li>
<li>本地变量所需的内存就在栈上，跟函数执行所需的其他数据在一起。当函数执行完成之后，这些内存也就自然而然释放掉了<ul>
<li>栈上的分配极为简单，移动一下栈指针而已。</li>
<li>栈上的释放也极为简单，函数执行结束时移动一下栈指针即可。</li>
<li>由于后进先出的执行过程，不可能出现内存碎片</li>
</ul>
</li>
</ul>
</li>
<li><p>RAII</p>
<ul>
<li>C++ 支持将对象存储在栈上面。但是，在很多情况下，对象不能，或不应该，存储在栈上。比如：<ul>
<li>对象很大；</li>
<li>对象的大小在编译时不能确定；</li>
<li>对象是函数的返回值，但由于特殊的原因，不应使用对象的值返回。</li>
</ul>
</li>
<li>常见情况之一是，在工厂方法或其他面向对象编程的情况下，返回值类型是基类：需要把这个返回值放到一个本地变量里，并确保其析构函数会删除该对象即可。</li>
<li>在析构函数里做必要的清理工作，这就是 RAII 的基本用法。这种清理并不限于释放内存，也可以是：<ul>
<li>关闭文件（fstream 的析构就会这么做）</li>
<li>释放同步锁</li>
<li>释放其他重要的系统资源</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="02-自己动手，实现C-的智能指针"><a href="#02-自己动手，实现C-的智能指针" class="headerlink" title="02 | 自己动手，实现C++的智能指针"></a>02 | 自己动手，实现C++的智能指针</h4><ul>
<li><p>智能指针的最基本的功能：对超出作用域的对象进行释放；除此之外还需要考虑模板化和易用性、拷贝构造和赋值</p>
<ul>
<li>要让这个类能够包装任意类型的指针，需要把它变成一个类模板，在开头增加模板声明，并且增加几个成员函数（*运算符、-&gt;运算符，像指针一样用在布尔表达式里）</li>
<li>禁用这两个函数非常简单，但却解决了一种可能出错的情况。否则，smart_ptr<shape>ptr2{ptr1}; 在编译时不会出错，但在运行时却会有未定义行为——由于会对同一内存释放两次，通常情况下会导致程序崩溃。因此不能直接禁用拷贝构造和赋值操作，应该在拷贝时转移指针的所有权</li>
<li>在拷贝构造函数中，通过调用 other 的 release 方法来释放它对指针的所有权。在赋值函数中，则通过拷贝构造产生一个临时对象并调用 swap 来交换对指针的所有权；这个方法保证了强异常安全性：赋值分为拷贝构造和交换两步，异常只可能在第一步发生；而第一步如果发生异常的话，this 对象完全不受任何影响。无论拷贝构造成功与否，结果只有赋值成功和赋值没有效果两种状态，而不会发生因为赋值破坏了当前对象这种场景。但是它的行为会让程序员非常容易犯错。一不小心把它传递给另外一个smart_ptr，你就不再拥有这个对象了</li>
</ul>
</li>
<li><p>smart_ptr 可以如何使用“移动”来改善其行为。</p>
<ul>
<li><p>把拷贝构造函数中的参数类型 smart_ptr&amp; 改成了 smart_ptr&amp;&amp;；现在它成了移动构造函数。</p>
</li>
<li><p>把赋值函数中的参数类型 smart_ptr&amp; 改成了 smart_ptr，在构造参数时直接生成新的智能指针，从而不再需要在函数体中构造临时对象。现在赋值函数的行为是移动还是拷贝，完全依赖于构造参数时走的是移动构造还是拷贝构造。</p>
</li>
<li><p>提供了移动构造函数而没有手动提供拷贝构造函数，那后者自动被禁用；这也是 C++11 的 unique_ptr 的基本行为。</p>
</li>
<li><p>子类指针向基类指针的转换，额外加一点模板代码，就能实现这一行为，修改移动构造函数一处即可</p>
</li>
</ul>
</li>
<li><p>一个对象只能被单个 unique_ptr所拥有，这显然不能满足所有使用场合的需求，一种常见的情况是，多个智能指针同时拥有一个对象；当它们全部都失效时，这个对象也同时会被删除。这也就是 shared_ptr 了。</p>
<ul>
<li>多个不同的 shared_ptr 不仅可以共享一个对象，在共享同一对象时也需要同时共享同一个计数。当最后一个指向对象（和共享计数）的 shared_ptr 析构时，它需要删除对象和共享计数</li>
<li>设计一个shared_count 类，除构造函数之外有三个方法：一个增加计数，一个减少计数，一个获取计数。注意上面的接口增加计数不需要返回计数值；但减少计数时需要返回计数值，以供调用者判断是否它已经是最后一个指向共享计数的 shared_ptr 了</li>
<li>构造函数跟之前的主要不同点是会构造一个 shared_count 出来。析构函数在看到 ptr_非空时（此时根据代码逻辑，shared_count 也必然非空），需要对引用数减一，并在引用数降到零时彻底删除对象和共享计数。</li>
<li>除复制指针之外，对于拷贝构造的情况，需要在指针非空时把引用数加一，并复制共享计数的指针。对于移动构造的情况，我们不需要调整引用数，直接把 other.ptr_ 置为空，认为 other 不再指向该共享对象即可。</li>
<li>模板的各个实例间并不天然就有 friend 关系，因而不能互访私有成员 ptr_ 和shared_count_。我们需要在 smart_ptr 的定义中显式声明：template <typename U> friend class smart_ptr;</li>
</ul>
</li>
<li><p>对应于 C++ 里的不同的类型强制转换：static_cast、reinterpret_cast、const_cast、dynamic_cast；智能指针需要实现类似的函数模板。实现本身并不复杂，但为了实现这些转换，需要添加构造函数，允许在对智能指针内部的指针对象赋值时，使用一个现有的智能指针的共享计数</p>
</li>
</ul>
<h4 id="03-右值和移动究竟解决了什么问题？"><a href="#03-右值和移动究竟解决了什么问题？" class="headerlink" title="03 | 右值和移动究竟解决了什么问题？"></a>03 | 右值和移动究竟解决了什么问题？</h4><ul>
<li><p>值分左右</p>
<ul>
<li>一个 lvalue 是通常可以放在等号左边的表达式，左值</li>
<li>一个 rvalue 是通常只能放在等号右边的表达式，右值</li>
<li>一个 glvalue 是 generalized lvalue，广义左值</li>
<li>一个 xvalue 是 expiring lvalue，将亡值</li>
<li>一个 prvalue 是 pure rvalue，纯右值</li>
</ul>
</li>
<li><p>左值 lvalue 是有标识符、可以取地址的表达式，最常见的情况有：</p>
<ul>
<li>变量、函数或数据成员的名字</li>
<li>返回左值引用的表达式，如 ++x、x &#x3D; 1、cout &lt;&lt; ‘ ‘</li>
<li>字符串字面量如 “hello world”</li>
</ul>
<p>在函数调用时，左值可以绑定到左值引用的参数，如 T&amp;。一个常量只能绑定到常左值引用，如 const T&amp;。</p>
</li>
<li><p>纯右值 prvalue 是没有标识符、不可以取地址的表达式，一般也称之为“临时对象”。最常见的情况有：</p>
<ul>
<li>返回非引用类型的表达式，如 x++、x + 1、make_shared<int>(42)</li>
<li>除字符串字面量之外的字面量，如 42、true</li>
</ul>
</li>
<li><p>C++11 开始，C++ 语言里多了一种引用类型——右值引用。右值引用的形式是 T&amp;&amp;，比左值引用多一个 &amp; 符号。</p>
<ul>
<li>引入一种额外的引用类型当然增加了语言的复杂性，但也带来了很多优化的可能性。由于C++ 有重载，就可以根据不同的引用类型，来选择不同的重载函数，来完成不同的行为</li>
<li>std::move(ptr) 的作用是把一个左值引用强制转换成一个右值引用，而并不改变其内容。std::move(ptr1) 等价于 static_cast&lt;smart_ptr<shape>&amp;&amp;&gt;(ptr1)。可以把 std::move(ptr1) 看作是一个有名字的右值。为了跟无名的纯右值 prvalue相区别，C++ 里目前就把这种表达式叫做 xvalue。跟左值 lvalue 不同，xvalue 仍然是不能取地址的——这点上，xvalue 和 prvalue 相同。所以，xvalue 和 prvalue 都被归为右值 rvalue</li>
</ul>
</li>
<li><p>“值类别”（value category）和“值类型”（value type）是两个看似相似、却毫不相干的术语。前者指的是上面这些左值、右值相关的概念，后者则是与引用类型（reference type）相对而言，表明一个变量是代表实际数值，还是引用另外一个数值。在C++ 里，所有的原生类型、枚举、结构、联合、类都代表值类型，只有引用（&amp;）和指针（*）才是引用类型。</p>
</li>
<li><p>一个变量的生命周期在超出作用域时结束。如果一个变量代表一个对象，当然这个对象的生命周期也在那时结束。那临时对象（prvalue）呢</p>
<ul>
<li>C++ 的规则是：一个临时对象会在包含这个临时对象的完整表达式估值完成后、按生成顺序的逆序被销毁，除非有生命周期延长发生</li>
<li>为了方便对临时对象的使用，C++ 对临时对象有特殊的生命周期延长规则。这条规则是：如果一个 prvalue 被绑定到一个引用上，它的生命周期则会延长到跟这个引用变量一样长<ul>
<li>这条生命期延长规则只对 prvalue 有效，而对 xvalue 无效。如果由于某种原因，prvalue 在绑定到引用以前已经变成了 xvalue，那生命期就不会延长</li>
</ul>
</li>
<li>可以把一个没有虚析构函数的子类对象绑定到基类的引用变量上，这个子类对象的析构仍然是完全正常的——这是因为这条规则只是延后了临时对象的析构而已，不是利用引用计数等复杂的方法，因而只要引用绑定成功，其类型并没有什么影响</li>
</ul>
</li>
<li><p>移动的意义</p>
<ul>
<li>对于 smart_ptr，使用右值引用的目的是实现移动，而实现移动的意义是减少运行的开销——在引用计数指针的场景下，这个开销并不大。</li>
<li>在使用容器类的情况下，移动更有意义；对于这个语句<code>string result = string(&quot;Hello, &quot;) + name + &quot;.&quot;;</code><ul>
<li>在 C++11 之前的年代里，这种写法是绝对不推荐的。因为它会引入很多额外开销，”Hello, “ 复制 3 次，name 复制 2 次，”.” 复制 1 次，并且还有两个临时对象需要析构</li>
<li>从 C++11 开始，性能上，所有的字符串只复制了一次；虽然仍然要增加临时对象的构造和析构，但由于这些操作不牵涉到额外的内存分配和释放，是相当廉价的</li>
</ul>
</li>
<li>C++ 里的对象缺省都是值语义，对于这样的一个类class A {<br>B b_;C c_;}; <ul>
<li>C++ 则会直接把 B 和 C 对象放在 A 的内存空间里</li>
<li>优点:它保证了内存访问的局域性，而局域性在现代处理器架构上是绝对具有性能优势的</li>
<li>缺点:复制对象的开销大大增加</li>
</ul>
</li>
<li>移动语义使得在 C++ 里返回大对象（如容器）的函数和运算符成为现实，因而可以提高代码的简洁性和可读性，提高程序员的生产率</li>
</ul>
</li>
<li><p>要让你设计的对象支持移动的话，通常需要下面几步：</p>
<ul>
<li>你的对象应该有分开的拷贝构造和移动构造函数（除非你只打算支持移动，不支持拷贝——如 unique_ptr）。</li>
<li>你的对象应该有 swap 成员函数，支持和另外一个对象快速交换成员。</li>
<li>在你的对象的名空间下，应当有一个全局的 swap 函数，调用成员函数 swap 来实现交换。支持这种用法会方便别人（包括你自己在将来）在其他对象里包含你的对象，并快速实现它们的 swap 函数。</li>
<li>实现通用的 operator&#x3D;。</li>
<li>上面各个函数如果不抛异常的话，应当标为 noexcept。这对移动构造函数尤为重要</li>
</ul>
</li>
<li><p>有一种常见的 C++ 编程错误，是在函数里返回一个本地对象的引用。由于在函数结束时本地对象即被销毁，返回一个指向本地对象的引用属于未定义行为。</p>
<ul>
<li>在 C++11 之前，返回一个本地对象意味着这个对象会被拷贝，除非编译器发现可以做返回值优化（named return value optimization，或 NRVO），能把对象直接构造到调用者的栈上。</li>
<li>从 C++11 开始，返回值优化仍可以发生，但在没有返回值优化的情况下，编译器将试图把本地对象移动出去，而不是拷贝出去。这一行为不需要程序员手工用 std::move 进行干预——使用std::move 对于移动行为没有帮助，反而会影响返回值优化。</li>
</ul>
</li>
<li><p>引用坍缩（又称“引用折叠”）和完美转发</p>
<ul>
<li>对于 template <typename T> foo(T&amp;&amp;) 这样的代码，如果传递过去的参数是左值，T 的推导结果是左值引用；如果传递过去的参数是右值，T 的推导结果是参数的类型本身。</li>
<li>如果 T 是左值引用，那 T&amp;&amp; 的结果仍然是左值引用——即 type&amp; &amp;&amp; 坍缩成了type&amp;。</li>
<li>如果 T 是一个实际类型，那 T&amp;&amp; 的结果自然就是一个右值引用。</li>
<li>很多标准库里的函数，连目标的参数类型都不知道，但我们仍然需要能够保持参数的值类型：左值的仍然是左值，右值的仍然是右值。这个功能在 C++ 标准库中已经提供了，叫 std::forward。它和 std::move 一样都是利用引用坍缩机制来实现。</li>
<li>在 T 是模板参数时，T&amp;&amp; 的作用主要是保持值类别进行转发，它有个名字就叫“转发引用”（forwarding reference）。因为既可以是左值引用，也可以是右值引用，它也曾经被叫做“万能引用”（universal reference）</li>
</ul>
</li>
</ul>
<h4 id="04丨容器汇编I：比较简单的若干容器"><a href="#04丨容器汇编I：比较简单的若干容器" class="headerlink" title="04丨容器汇编I：比较简单的若干容器"></a>04丨容器汇编I：比较简单的若干容器</h4><ul>
<li><p>string</p>
<ul>
<li><p>string 一般并不被认为是一个 C++ 的容器</p>
</li>
<li><p>string 是模板 basic_string 对于 char 类型的特化，可以认为是一个只存放字符char 类型数据的容器。“真正”的容器类与 string 的最大不同点是里面可以存放任意类型的对象。</p>
</li>
<li><p>跟其他大部分容器一样， string 具有下列成员函数：</p>
<ul>
<li>begin 可以得到对象起始点</li>
<li>end 可以得到对象的结束点</li>
<li>empty 可以得到容器是否为空</li>
<li>size 可以得到容器的大小</li>
<li>swap 可以和另外一个容器交换其内容</li>
</ul>
<p>几乎是所有容器的共同点了。也就是说：</p>
<ul>
<li>容器都有开始和结束点</li>
<li>容器会记录其状态是否非空</li>
<li>容器有大小</li>
<li>容器支持交换</li>
</ul>
</li>
<li><p>string 当然是为了存放字符串。和简单的 C 字符串不同：</p>
<ul>
<li>string 负责自动维护字符串的生命周期</li>
<li>string 支持字符串的拼接操作（如之前说过的 + 和 +&#x3D;）</li>
<li>string 支持字符串的查找操作（如 find 和 rfind）</li>
<li>string 支持从 istream 安全地读入字符串（使用 getline）</li>
<li>string 支持给期待 const char* 的接口传递字符串内容（使用 c_str）</li>
<li>string 支持到数字的互转（stoi 系列函数和 to_string）<br>等</li>
</ul>
</li>
<li><p>如果实现较为复杂、希望使用 string 的成员函数的话，那就应该考虑下面的策略</p>
<ul>
<li>如果不修改字符串的内容，使用 const string&amp; 或 C++17 的 string_view 作为参数类型。后者是最理想的情况，因为即使在只有 C 字符串的情况，也不会引发不必要的内存复制。</li>
<li>如果需要在函数内修改字符串内容、但不影响调用者的该字符串，使用 string 作为参数类型（自动拷贝）。</li>
<li>如果需要改变调用者的字符串内容，使用 string&amp; 作为参数类型（通常不推荐）。</li>
</ul>
</li>
</ul>
</li>
<li><p>vector</p>
<ul>
<li>和 string 相似，vector 的成员在内存里连续存放，同时 begin、end、front、back成员函数指向的位置也和 string 一样</li>
<li>除了容器类的共同点，vector 允许下面的操作（不完全列表）：<ul>
<li>可以使用中括号的下标来访问其成员（同 string）</li>
<li>可以使用 data 来获得指向其内容的裸指针（同 string）</li>
<li>可以使用 capacity 来获得当前分配的存储空间的大小，以元素数量计（同 string）</li>
<li>可以使用 reserve 来改变所需的存储空间的大小，成功后 capacity() 会改变（同string）</li>
<li>可以使用 resize 来改变其大小，成功后 size() 会改变（同 string）</li>
<li>可以使用 pop_back 来删除最后一个元素（同 string）</li>
<li>可以使用 push_back 在尾部插入一个元素（同 string）</li>
<li>可以使用 insert 在指定位置前插入一个元素（同 string）</li>
<li>可以使用 erase 在指定位置删除一个元素（同 string）</li>
<li>可以使用 emplace 在指定位置构造一个元素</li>
<li>可以使用 emplace_back 在尾部新构造一个元素</li>
</ul>
</li>
<li>当 push_back、insert、reserve、resize 等函数导致内存重分配时，或当insert、erase 导致元素位置移动时，vector 会试图把元素“移动”到新的内存区域。vector 通常保证强异常安全性，如果元素类型没有提供一个保证不抛异常的移动构造函数，vector 通常会使用拷贝构造函数。因此，对于拷贝代价较高的自定义元素类型，我们应当定义移动构造函数，并标其为 noexcept，或只在容器中放置对象的智能指针。这就是为什么我之前需要在 smart_ptr 的实现中标上 noexcept 的原因。</li>
<li>C++11 开始提供的 emplace… 系列函数是为了提升容器的性能而设计的。</li>
<li>现代处理器的体系架构使得对连续内存访问的速度比不连续的内存要快得多。因而，vector 的连续内存使用是它的一大优势所在</li>
<li>vector 的一个主要缺陷是大小增长时导致的元素移动。如果可能，尽早使用 reserve 函数为 vector 保留所需的内存，这在 vector 预期会增长很大时能带来很大的性能提升</li>
</ul>
</li>
<li><p>deque</p>
<ul>
<li>deque 的意思是 double-ended queue，双端队列。它主要是用来满足下面这个需求：容器不仅可以从尾部自由地添加和删除元素，也可以从头部自由地添加和删除。</li>
<li>deque 的接口和 vector 相比，有如下的区别：<ul>
<li>deque 提供 push_front、emplace_front 和 pop_front 成员函数。</li>
<li>deque 不提供 data、capacity 和 reserve 成员函数。</li>
</ul>
</li>
<li>如果只从头、尾两个位置对 deque 进行增删操作的话，容器里的对象永远不需要移动。</li>
<li>容器里的元素只是部分连续的（因而没法提供 data 成员函数）。</li>
<li>由于元素的存储大部分仍然连续，它的遍历性能是比较高的。</li>
<li>由于每一段存储大小相等，deque 支持使用下标访问容器元素，大致相当于 <code>index[i / chunk_size][i % chunk_size]</code>，也保持高效。</li>
</ul>
</li>
<li><p>list</p>
<ul>
<li>list 在 C++ 里代表双向链表。和 vector 相比，它优化了在容器中间的插入和删除：<ul>
<li>list 提供高效的、O(1) 复杂度的任意位置的插入和删除操作。</li>
<li>list 不提供使用下标访问其元素。</li>
<li>list 提供 push_front、emplace_front 和 pop_front 成员函数（和 deque 相同）。</li>
<li>list 不提供 data、capacity 和 reserve 成员函数（和 deque 相同）</li>
</ul>
</li>
<li>虽然 list 提供了任意位置插入新元素的灵活性，但由于每个元素的内存空间都是单独分配、不连续，它的遍历性能比 vector 和 deque 都要低。这在很大程度上抵消了它在插入和删除操作时不需要移动元素的理论性能优势。如果你不太需要遍历容器、又需要在中间频繁插入或删除元素，可以考虑使用 list。</li>
<li>另外一个需要注意的地方是，因为某些标准算法在 list 上会导致问题，list 提供了成员函数作为替代，包括下面几个：merge、remove、remove_if、reverse、sort、unique</li>
</ul>
</li>
<li><p>forward_list</p>
<ul>
<li>大部分 C++ 容器都支持 insert 成员函数，语义是从指定的位置之前插入一个元素，对于forward_list，这不是一件容易做到的事情。标准库提供了一个insert_after 作为替代。此外，它跟 list 相比还缺了下面这些成员函数：<ul>
<li>back</li>
<li>size</li>
<li>push_back</li>
<li>emplace_back</li>
<li>pop_back</li>
</ul>
</li>
<li>在元素大小较小的情况下，forward_list 能节约的内存是非常可观的；在列表不长的情况下，不能反向查找也不是个大问题。提高内存利用率，往往就能提高程序性能，更不用说在内存可能不足时的情况了。</li>
</ul>
</li>
<li><p>queue</p>
<ul>
<li>被称为容器适配器（container adaptor）。</li>
<li>先进先出（FIFO）的数据结构，queue 缺省用 deque 来实现。它的接口跟 deque 比，有如下改变：<ul>
<li>不能按下标访问元素</li>
<li>没有 begin、end 成员函数</li>
<li>用 emplace 替代了 emplace_back，用 push 替代了 push_back，用 pop 替代了pop_front；</li>
<li>没有其他的 push_…、pop_…、emplace…、insert、erase 函数</li>
</ul>
</li>
<li>queue 不提供 begin 和 end 方法，无法无损遍历</li>
</ul>
</li>
<li><p>stack</p>
<ul>
<li>栈 stack 是后进先出（LIFO）的数据结构。</li>
<li>queue 缺省也是用 deque 来实现，但它的概念和 vector 更相似。一般图形表示法会把 stack 表示成一个竖起的 vector</li>
<li>stack 跟内存管理时的栈有一个区别：在这里下面是低地址，向上则地址增大；而讨论内存管理时，高地址在下面，向上则地址减小，方向正好相反</li>
<li>为什么 stack（或 queue）的 pop 函数返回类型为 void，而不是直接返回容器的top（或 front）成员？<ul>
<li>实现pop时返回元素时，满足强异常安全，代码实现复杂，可读性差。</li>
</ul>
</li>
</ul>
</li>
</ul>
</article><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/202307192211377.png" target="_blank"><img class="post-qr-code-img" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/202307192211377.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/202307192207910.png" target="_blank"><img class="post-qr-code-img" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/202307192207910.png" alt="alipayautoh"/></a><div class="post-qr-code-desc">alipayautoh</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://acall.love/2023/06/05/2.C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=undefined&amp;url=http://acall.love/2023/06/05/2.C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/&amp;pic=undefined" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/C/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>C++<span class="tagsPageCount">23</span></a><a class="post-meta__box__tags" href="/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>后端开发<span class="tagsPageCount">22</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/d6g1gl.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><div class="post-copyright"><i class="anzhiyufont anzhiyu-icon-copyright"></i><div class="post-copyright__author"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://acall.love/2023/06/05/2.C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">原创</a><a class="post-copyright-title"><span>2.C++读书笔记</span></a></div><div class="post-copyright-info-box"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"></span><a class="link" href="http://acall.love">🎵张小佑♪</a></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a class="link" href="http://acall.love/2023/06/05/2.C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">http://acall.love/2023/06/05/2.C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</a></span><span class="copy-button" onclick="rm.copyPageUrl('http://acall.love/2023/06/05/2.C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/')"><i class="anzhiyufont anzhiyu-icon-copy"></i></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://acall.love" target="_blank">♪张小佑</a>！</span></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/01/1.C++%E5%B2%97%E4%BD%8D%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E5%AE%9D%E5%85%B8/"><img class="prev-cover" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/iTab-p92mj3%20(2).webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">1.C++岗位面试真题宝典</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/10/3.C++%20%E9%9D%A2%E8%AF%95%E7%AA%81%E7%A0%B4/"><img class="next-cover" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/d6g1gl.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">3.面试突破</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/05/01/1.%E4%B8%AA%E4%BA%BA%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/" title="1.个人问题"><img class="cover" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/p9918p.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-05-01</div><div class="title">1.个人问题</div></div></a></div><div><a href="/2023/06/01/1.C++%E5%B2%97%E4%BD%8D%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E5%AE%9D%E5%85%B8/" title="1.C++岗位面试真题宝典"><img class="cover" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/iTab-p92mj3%20(2).webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-06-01</div><div class="title">1.C++岗位面试真题宝典</div></div></a></div><div><a href="/2023/05/05/2.%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F%E7%AC%94%E8%AE%B0/" title="2.极客笔记"><img class="cover" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/o5g6r7.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-05-05</div><div class="title">2.极客笔记</div></div></a></div><div><a href="/2023/06/10/3.C++%20%E9%9D%A2%E8%AF%95%E7%AA%81%E7%A0%B4/" title="3.面试突破"><img class="cover" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/d6g1gl.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-06-10</div><div class="title">3.面试突破</div></div></a></div><div><a href="/2023/01/05/day02%E7%AC%94%E8%AE%B0/" title="2.C++入门"><img class="cover" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/001.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-01-05</div><div class="title">2.C++入门</div></div></a></div><div><a href="/2023/01/10/day03%E7%AC%94%E8%AE%B0/" title="3.C++入门"><img class="cover" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/1pqq1w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-01-10</div><div class="title">3.C++入门</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">C++ 读书笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Effective-C"><span class="toc-number">1.1.</span> <span class="toc-text">Effective C++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E6%83%AFC"><span class="toc-number">1.1.1.</span> <span class="toc-text">习惯C++</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE01%EF%BC%9A%E8%A7%86C-%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">条款01：视C++为一个语言联邦</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE02%EF%BC%9A%E5%B0%BD%E9%87%8F%E4%BB%A5const-enum-inline-%E6%9B%BF%E6%8D%A2-define%EF%BC%88%E5%AE%81%E5%8F%AF%E4%BB%A5%E7%BC%96%E8%AF%91%E5%99%A8%E6%9B%BF%E6%8D%A2%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%89"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">条款02：尽量以const enum inline 替换#define（宁可以编译器替换预处理器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE03%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">条款03：尽可能使用const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE04%EF%BC%9A%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">条款04：确定对象被使用前已先被初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0-x2F-%E6%9E%90%E6%9E%84-x2F-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97"><span class="toc-number">1.1.2.</span> <span class="toc-text">构造&#x2F;析构&#x2F;赋值运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE05%EF%BC%9A%E4%BA%86%E8%A7%A3C-%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E4%BA%86%E9%82%A3%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">条款05：了解C++默默编写并调用了那些函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE06%EF%BC%9A%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E5%BA%94%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">条款06：若不想使用编译器自动生成的函数，就应该明确拒绝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE07%EF%BC%9A%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8Evirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">条款07：为多态基类声明virtual析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE08%EF%BC%9A%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">条款08：别让异常逃离析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE09%EF%BC%9A%E7%BB%9D%E4%B8%8D%E8%A6%81%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">条款09：绝不要在构造和析构过程中调用virtual函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE10%EF%BC%9A%E4%BB%A4operator-x3D-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA-reference-to-this"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">条款10：令operator&#x3D;返回一个 reference to *this</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE11%EF%BC%9A%E5%9C%A8operator-x3D-%E4%B8%AD%E5%A4%84%E7%90%86%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC"><span class="toc-number">1.1.2.7.</span> <span class="toc-text">条款11：在operator&#x3D;中处理自我赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE12%EF%BC%9A%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E5%8B%BF%E5%BF%98%E5%85%B6%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%88%90%E5%88%86"><span class="toc-number">1.1.2.8.</span> <span class="toc-text">条款12：复制对象时，勿忘其每一个成分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE13%EF%BC%9A%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90"><span class="toc-number">1.1.2.9.</span> <span class="toc-text">条款13：以对象管理资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE14%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E5%B0%8F%E5%BF%83copying%E8%A1%8C%E4%B8%BA"><span class="toc-number">1.1.2.10.</span> <span class="toc-text">条款14：在资源管理类小心copying行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE15%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">1.1.2.11.</span> <span class="toc-text">条款15：在资源管理类中提供对原始资源的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE16%EF%BC%9A%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8new%E5%92%8Cdelete%E6%97%B6%E5%80%99%E8%A6%81%E9%87%87%E5%8F%96%E7%9B%B8%E5%90%8C%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.1.2.12.</span> <span class="toc-text">条款16：成对使用new和delete时候要采取相同形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE17%EF%BC%9A%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86newed%E5%AF%B9%E8%B1%A1%E7%BD%AE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">1.1.2.13.</span> <span class="toc-text">条款17：以独立语句将newed对象置入智能指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE18%EF%BC%9A%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%AE%B9%E6%98%93%E8%A2%AB%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E8%A2%AB%E8%AF%AF%E7%94%A8"><span class="toc-number">1.1.2.14.</span> <span class="toc-text">条款18：让接口容易被正确使用，而不是被误用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE19%EF%BC%9A%E8%AE%BE%E8%AE%A1class%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1type"><span class="toc-number">1.1.2.15.</span> <span class="toc-text">条款19：设计class犹如设计type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE20%EF%BC%9A%E5%AE%81%E4%BB%A5pass-by-reference-to-const"><span class="toc-number">1.1.2.16.</span> <span class="toc-text">条款20：宁以pass by reference to const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE21%EF%BC%9A%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6reference"><span class="toc-number">1.1.2.17.</span> <span class="toc-text">条款21：必须返回对象别妄想返回其reference</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE22%EF%BC%9A%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BAprivate"><span class="toc-number">1.1.2.18.</span> <span class="toc-text">条款22：将成员变量声明为private</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE23%EF%BC%9A%E5%AE%81%E4%BB%A5non-member-non-friend-%E6%9B%BF%E6%8D%A2"><span class="toc-number">1.1.2.19.</span> <span class="toc-text">条款23：宁以non-member non-friend 替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE24%EF%BC%9A%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E9%83%BD%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8non-member%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.2.20.</span> <span class="toc-text">条款24：若所有参数都需要类型转换，请为此采用non-member函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE25%EF%BC%9A%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.2.21.</span> <span class="toc-text">条款25：考虑写出一个不抛出异常的swap函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE26%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E7%9A%84%E5%87%BA%E7%8E%B0%E6%97%B6%E9%97%B4"><span class="toc-number">1.1.2.22.</span> <span class="toc-text">条款26：尽可能延后变量定义式的出现时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE27%EF%BC%9A%E5%B0%BD%E9%87%8F%E5%B0%91%E5%81%9A%E8%BD%AC%E5%9E%8B%E5%8A%A8%E4%BD%9C"><span class="toc-number">1.1.2.23.</span> <span class="toc-text">条款27：尽量少做转型动作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE28%EF%BC%9A%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9Ehandles%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86"><span class="toc-number">1.1.2.24.</span> <span class="toc-text">条款28：避免返回handles指向对象内部成分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE29%EF%BC%9A%E4%B8%BA%E2%80%9C%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E2%80%9D%E8%80%8C%E5%8A%AA%E5%8A%9B%E6%98%AF%E5%80%BC%E5%BE%97%E7%9A%84"><span class="toc-number">1.1.2.25.</span> <span class="toc-text">条款29：为“异常安全”而努力是值得的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE30%EF%BC%9A%E9%80%8F%E5%BD%BB%E4%BA%86%E8%A7%A3inlining%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96"><span class="toc-number">1.1.2.26.</span> <span class="toc-text">条款30：透彻了解inlining的里里外外</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE31%EF%BC%9A%E5%B0%86%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB%E9%99%8D%E8%87%B3%E6%9C%80%E4%BD%8E"><span class="toc-number">1.1.2.27.</span> <span class="toc-text">条款31：将文件的编译依存关系降至最低</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE32%EF%BC%9A%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84public%E7%BB%A7%E6%89%BF%E5%A1%91%E8%86%9C%E5%87%BAis-a%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.2.28.</span> <span class="toc-text">条款32：确定你的public继承塑膜出is-a关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE33%EF%BC%9A%E9%81%BF%E5%85%8D%E9%81%AE%E6%8E%A9%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-number">1.1.2.29.</span> <span class="toc-text">条款33：避免遮掩继承而来的名称</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE34%EF%BC%9A%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">1.1.2.30.</span> <span class="toc-text">条款34：区分接口继承和实现继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE35%EF%BC%9A%E8%80%83%E8%99%91virtual%E5%87%BD%E6%95%B0%E4%BB%A5%E5%A4%96%E7%9A%84%E5%85%B6%E4%BB%96%E9%80%89%E6%8B%A9"><span class="toc-number">1.1.2.31.</span> <span class="toc-text">条款35：考虑virtual函数以外的其他选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-36%EF%BC%9A%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84non-virtual%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.2.32.</span> <span class="toc-text">条款 36：绝不重新定义继承而来的non-virtual函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE37%EF%BC%9A%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%80%BC"><span class="toc-number">1.1.2.33.</span> <span class="toc-text">条款37：绝不重新定义继承而来的缺省参数值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE38%EF%BC%9A%E9%80%9A%E8%BF%87%E5%A4%8D%E5%90%88%E5%A1%91%E8%86%9C%E5%87%BAhas-a%E6%88%96%E2%80%9C%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA%E2%80%9D"><span class="toc-number">1.1.2.34.</span> <span class="toc-text">条款38：通过复合塑膜出has-a或“根据某物实现出”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE39-%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8private-%E7%BB%A7%E6%89%BF"><span class="toc-number">1.1.2.35.</span> <span class="toc-text">条款39:明智而审慎地使用private 继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE40-%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">1.1.2.36.</span> <span class="toc-text">条款40:明智而审慎地使用多重继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">模板与泛型编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE-41-%E4%BA%86%E8%A7%A3%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">条款 41:了解隐式接口和编译期多态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE42-%E4%BA%86%E8%A7%A3-typename-%E7%9A%84%E5%8F%8C%E9%87%8D%E6%84%8F%E4%B9%89"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">条款42:了解 typename 的双重意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE43-%E5%AD%A6%E4%B9%A0%E5%A4%84%E7%90%86%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%9F%BA%E7%B1%BB%E5%86%85%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">条款43:学习处理模板化基类内的名称</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE44-%E5%B0%86%E4%B8%8E%E5%8F%82%E6%95%B0%E6%97%A0%E5%85%B3%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8A%BD%E7%A6%BB-templates"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">条款44:将与参数无关的代码抽离 templates</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE45-%E8%BF%90%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%8E%A5%E5%8F%97%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">条款45:运用成员函数模板接受所有兼容类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE46-%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%97%B6%E8%AF%B7%E4%B8%BA%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.3.6.</span> <span class="toc-text">条款46:需要类型转换时请为模板定义非成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE47-%E8%AF%B7%E4%BD%BF%E7%94%A8-traits-classes-%E8%A1%A8%E7%8E%B0%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-number">1.1.3.7.</span> <span class="toc-text">条款47:请使用 traits classes 表现类型信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE48-%E8%AE%A4%E8%AF%86-template%E5%85%83%E7%BC%96%E7%A8%8B"><span class="toc-number">1.1.3.8.</span> <span class="toc-text">条款48:认识 template元编程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3C-%E5%AE%9E%E6%88%9830%E8%AE%B2"><span class="toc-number">1.2.</span> <span class="toc-text">现代C++实战30讲</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BE%E5%89%8D%E5%BF%85%E8%AF%BB-2%E8%AE%B2"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">课前必读 (2讲)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#00%E4%B8%A8%E5%BC%80%E7%AF%87%E8%AF%8D%E4%B8%A8C-%E8%BF%99%E4%B9%88%E9%9A%BE%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%BF%98%E8%A6%81%E7%94%A8C-%EF%BC%9F"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">00丨开篇词丨C++这么难，为什么我们还要用C++？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%AF%87-9%E8%AE%B2"><span class="toc-number">1.2.1.</span> <span class="toc-text">基础篇 (9讲)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#01%E4%B8%A8%E5%A0%86%E3%80%81%E6%A0%88%E3%80%81RAII%EF%BC%9AC-%E9%87%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90%EF%BC%9F"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">01丨堆、栈、RAII：C++里该如何管理资源？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#02-%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%EF%BC%8C%E5%AE%9E%E7%8E%B0C-%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">02 | 自己动手，实现C++的智能指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#03-%E5%8F%B3%E5%80%BC%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%A9%B6%E7%AB%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">03 | 右值和移动究竟解决了什么问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#04%E4%B8%A8%E5%AE%B9%E5%99%A8%E6%B1%87%E7%BC%96I%EF%BC%9A%E6%AF%94%E8%BE%83%E7%AE%80%E5%8D%95%E7%9A%84%E8%8B%A5%E5%B9%B2%E5%AE%B9%E5%99%A8"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">04丨容器汇编I：比较简单的若干容器</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 🎵张小佑♪</div></div></footer></div></div></div><div id="sidebar"><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child" style="left:17px;"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li></ul></div></div></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.4.0/source/js/utils.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.4.0/source/js/main.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.4.0/source/js/tw_cn.js"></script><script src="https://npm.elemecdn.com/@fancyapps/ui@4.0.31/dist/fancybox.umd.js"></script><script src="https://npm.elemecdn.com/instant.page@5.1.1/instantpage.js" type="module"></script><script src="https://npm.elemecdn.com/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://npm.elemecdn.com/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("09/01/2022 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2022 By 安知鱼 1.4.0",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 🎵张小佑♪ 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anheyu.com";</script><script>//动态标题
let leaveTitle = '♪张小佑 - 分享思考与科技生活';
let backTitle = '♪张小佑 - 分享思考与科技生活';
let OriginTitile = document.title
let titleTime
document.addEventListener('visibilitychange', function () {
  if (document.hidden) {
    //离开当前页面时标签显示内容
    document.title = leaveTitle
    clearTimeout(titleTime)
  } else {
    //返回当前页面时标签显示内容
    document.title = backTitle + OriginTitile
    //两秒后变回正常标题
    titleTime = setTimeout(function () {
      document.title = OriginTitile
    }, 2000)
  }
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script>// 初始化函数
let rm = {};

//禁止图片与超链接拖拽
let aElements = document.getElementsByTagName("a");
for (let i = 0; i < aElements.length; i++) {
  aElements[i].setAttribute("draggable", "false");
  let imgElements = aElements[i].getElementsByTagName("img");
  for (let j = 0; j < imgElements.length; j++) {
    imgElements[j].setAttribute("draggable", "false");
  }
}

// 显示菜单
rm.showRightMenu = function (isTrue, x = 0, y = 0) {
  console.info(x, y)
  let rightMenu = document.getElementById("rightMenu");
  rightMenu.style.top = x + "px";
  rightMenu.style.left = y + "px";
  if (isTrue) {
    rightMenu.style.display = "block";
    stopMaskScroll();
  } else {
    rightMenu.style.display = "none";
  }
};

// 隐藏菜单
rm.hideRightMenu = function () {
  rm.showRightMenu(false);
  let rightMenuMask = document.querySelector("#rightmenu-mask");
  rightMenuMask.style.display = "none";
};

// 尺寸
let rmWidth = document.getElementById("rightMenu").offsetWidth;
let rmHeight = document.getElementById("rightMenu").offsetHeight;

// 重新定义尺寸
rm.reloadrmSize = function () {
  rightMenu.style.visibility = "hidden";
  rightMenu.style.display = "block";
  // 获取宽度和高度
  rmWidth = document.getElementById("rightMenu").offsetWidth;
  rmHeight = document.getElementById("rightMenu").offsetHeight;
  rightMenu.style.visibility = "visible";
};

// 获取点击的href
let domhref = "";
let domImgSrc = "";
let globalEvent = null;

var oncontextmenuFunction = function (event) {
  if (document.body.clientWidth > 768) {
    let pageX = event.clientX + 10; //加10是为了防止显示时鼠标遮在菜单上
    let pageY = event.clientY;

    //其他额外菜单
    const $rightMenuOther = document.querySelector(".rightMenuOther");
    const $rightMenuPlugin = document.querySelector(".rightMenuPlugin");
    const $rightMenuCopyText = document.querySelector("#menu-copytext");
    const $rightMenuPasteText = document.querySelector("#menu-pastetext");
    const $rightMenuCommentText = document.querySelector("#menu-commenttext");
    const $rightMenuNewWindow = document.querySelector("#menu-newwindow");
    const $rightMenuNewWindowImg = document.querySelector("#menu-newwindowimg");
    const $rightMenuCopyLink = document.querySelector("#menu-copylink");
    const $rightMenuCopyImg = document.querySelector("#menu-copyimg");
    const $rightMenuDownloadImg = document.querySelector("#menu-downloadimg");
    const $rightMenuSearch = document.querySelector("#menu-search");
    const $rightMenuSearchBaidu = document.querySelector("#menu-searchBaidu");
    const $rightMenuMusicToggle = document.querySelector("#menu-music-toggle");
    const $rightMenuMusicBack = document.querySelector("#menu-music-back");
    const $rightMenuMusicForward = document.querySelector("#menu-music-forward");
    const $rightMenuMusicPlaylist = document.querySelector("#menu-music-playlist");
    const $rightMenuMusicCopyMusicName = document.querySelector("#menu-music-copyMusicName");

    let href = event.target.href;
    let imgsrc = event.target.currentSrc;

    // 判断模式 扩展模式为有事件
    let pluginMode = false;
    $rightMenuOther.style.display = "block";
    globalEvent = event;

    // 检查是否需要复制 是否有选中文本
    if (selectTextNow && window.getSelection()) {
      pluginMode = true;
      $rightMenuCopyText.style.display = "block";
      $rightMenuCommentText.style.display = "block";
      $rightMenuSearch.style.display = "block";
      $rightMenuSearchBaidu.style.display = "block";
    } else {
      $rightMenuCopyText.style.display = "none";
      $rightMenuCommentText.style.display = "none";
      $rightMenuSearchBaidu.style.display = "none";
      $rightMenuSearch.style.display = "none";
    }

    //检查是否右键点击了链接a标签
    if (href) {
      pluginMode = true;
      $rightMenuNewWindow.style.display = "block";
      $rightMenuCopyLink.style.display = "block";
      domhref = href;
    } else {
      $rightMenuNewWindow.style.display = "none";
      $rightMenuCopyLink.style.display = "none";
    }

    //检查是否需要复制图片
    if (imgsrc) {
      pluginMode = true;
      $rightMenuCopyImg.style.display = "block";
      $rightMenuDownloadImg.style.display = "block";
      $rightMenuNewWindowImg.style.display = "block";
      document.getElementById("rightMenu").style.width="12rem"
      domImgSrc = imgsrc;
    } else {
      $rightMenuCopyImg.style.display = "none";
      $rightMenuDownloadImg.style.display = "none";
      $rightMenuNewWindowImg.style.display = "none";
    }

    // 判断是否为输入框
    if (event.target.tagName.toLowerCase() === "input" || event.target.tagName.toLowerCase() === "textarea") {
      pluginMode = true;
      $rightMenuPasteText.style.display = "block";
    } else {
      $rightMenuPasteText.style.display = "none";
    }
    const navMusicEl = document.querySelector("#nav-music");
    //判断是否是音乐
    if (navMusicEl && navMusicEl.contains(event.target)) {
      pluginMode = true;
      $rightMenuMusicToggle.style.display = "block";
      $rightMenuMusicBack.style.display = "block";
      $rightMenuMusicForward.style.display = "block";
      $rightMenuMusicPlaylist.style.display = "block";
      $rightMenuMusicCopyMusicName.style.display = "block";
    } else {
      $rightMenuMusicToggle.style.display = "none";
      $rightMenuMusicBack.style.display = "none";
      $rightMenuMusicForward.style.display = "none";
      $rightMenuMusicPlaylist.style.display = "none";
      $rightMenuMusicCopyMusicName.style.display = "none";
    }

    // 如果不是扩展模式则隐藏扩展模块
    if (pluginMode) {
      $rightMenuOther.style.display = "none";
      $rightMenuPlugin.style.display = "block";
    } else {
      $rightMenuPlugin.style.display = "none";
    }

    rm.reloadrmSize();

    // 鼠标默认显示在鼠标右下方，当鼠标靠右或靠下时，将菜单显示在鼠标左方\上方
    if (pageX + rmWidth > window.innerWidth) {
      pageX -= rmWidth + 10;
    }
    if (pageY + rmHeight > window.innerHeight) {
      pageY -= pageY + rmHeight - window.innerHeight;
    }

    rm.showRightMenu(true, pageY, pageX);
    document.getElementById("rightmenu-mask").style.display = "flex";
    return false;
  }
};

// 监听右键初始化
window.oncontextmenu = oncontextmenuFunction

// 下载图片状态
rm.downloadimging = false;

// 复制图片到剪贴板
rm.writeClipImg = function (imgsrc) {
  console.log("按下复制");
  rm.hideRightMenu();
  anzhiyu.snackbarShow("正在下载中，请稍后", false, 10000);
  if (rm.downloadimging == false) {
    rm.downloadimging = true;
    setTimeout(function () {
      copyImage(imgsrc);
      anzhiyu.snackbarShow("复制成功！图片已添加盲水印，请遵守版权协议");
      rm.downloadimging = false;
    }, "10000");
  }
};

function imageToBlob(imageURL) {
  const img = new Image();
  const c = document.createElement("canvas");
  const ctx = c.getContext("2d");
  img.crossOrigin = "";
  img.src = imageURL;
  return new Promise(resolve => {
    img.onload = function () {
      c.width = this.naturalWidth;
      c.height = this.naturalHeight;
      ctx.drawImage(this, 0, 0);
      c.toBlob(
        blob => {
          // here the image is a blob
          resolve(blob);
        },
        "image/png",
        0.75
      );
    };
  });
}

async function copyImage(imageURL) {
  const blob = await imageToBlob(imageURL);
  const item = new ClipboardItem({ "image/png": blob });
  navigator.clipboard.write([item]);
}

rm.copyUrl = function (id) {
  const input = document.createElement("input"); // Create a new <input> element
  input.id = "copyVal"; // Set the id of the new element to "copyVal"
  document.body.appendChild(input); // Append the new element to the end of the <body> element
  
  const text = id;
  input.value = text;
  input.select();
  input.setSelectionRange(0, input.value.length);
  document.execCommand("copy");
  
  input.remove(); // Remove the <input> element from the DOM
};

function stopMaskScroll() {
  if (document.getElementById("rightmenu-mask")) {
    let xscroll = document.getElementById("rightmenu-mask");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      { passive: true }
    );
  }
  if (document.getElementById("rightMenu")) {
    let xscroll = document.getElementById("rightMenu");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      { passive: true }
    );
  }
}

rm.rightmenuCopyText = function (txt) {
  if (navigator.clipboard) {
    navigator.clipboard.writeText(txt);
  }
  rm.hideRightMenu();
};

rm.copyPageUrl = function (url) {
  if (!url) {
    url = window.location.href;
  }
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制本页链接地址成功", false, 2000);
  rm.hideRightMenu();
};

rm.sharePage = function () {
  var content = window.location.href;
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制本页链接地址成功", false, 2000);
  rm.hideRightMenu();
};

// 复制当前选中文本
var selectTextNow = "";
document.onmouseup = document.ondblclick = selceText;

function selceText() {
  var txt;
  if (document.selection) {
    txt = document.selection.createRange().text;
  } else {
    txt = window.getSelection().toString();
  }
  selectTextNow = txt !== "" ? txt : "";
}

// 读取剪切板
rm.readClipboard = function () {
  if (navigator.clipboard) {
    navigator.clipboard.readText().then(clipText => rm.insertAtCaret(globalEvent.target, clipText));
  }
};

// 粘贴文本到焦点
rm.insertAtCaret = function (elemt, value) {
  const startPos = elemt.selectionStart,
    endPos = elemt.selectionEnd;
  if (document.selection) {
    elemt.focus();
    var sel = document.selection.createRange();
    sel.text = value;
    elemt.focus();
  } else {
    if (startPos || startPos == "0") {
      var scrollTop = elemt.scrollTop;
      elemt.value = elemt.value.substring(0, startPos) + value + elemt.value.substring(endPos, elemt.value.length);
      elemt.focus();
      elemt.selectionStart = startPos + value.length;
      elemt.selectionEnd = startPos + value.length;
      elemt.scrollTop = scrollTop;
    } else {
      elemt.value += value;
      elemt.focus();
    }
  }
};

//粘贴文本
rm.pasteText = function () {
  const result = rm.readClipboard() || "";
  rm.hideRightMenu();
};

//引用到评论
rm.rightMenuCommentText = function (txt) {
  rm.hideRightMenu();
  const postCommentDom = document.getElementById("post-comment");
  var domTop = postCommentDom.offsetTop;
  window.scrollTo(0, domTop - 80);
  if (txt == "undefined" || txt == "null") txt = "好棒！";
  function setText() {
    setTimeout(() => {
      var input = document.getElementsByClassName("el-textarea__inner")[0];
      if (!input) setText();
      let evt = document.createEvent("HTMLEvents");
      evt.initEvent("input", true, true);
      let inputValue = replaceAll(txt, "\n", "\n> ");
      input.value = "> " + inputValue + "\n\n";
      input.dispatchEvent(evt);
      input.focus();
      input.setSelectionRange(-1, -1);
      if (document.getElementById("comment-tips")) {
        document.getElementById("comment-tips").classList.add("show");
      }
    }, 100);
  }
  setText();
};

//替换所有内容
function replaceAll(string, search, replace) {
  return string.split(search).join(replace);
}

// 百度搜索
rm.searchBaidu = function () {
  anzhiyu.snackbarShow("即将跳转到百度搜索", false, 2000);
  setTimeout(function () {
    window.open("https://www.baidu.com/s?wd=" + selectTextNow);
  }, "2000");
  rm.hideRightMenu();
};

//分享链接
rm.copyLink = function () {
  rm.rightmenuCopyText(domhref);
  anzhiyu.snackbarShow("已复制链接地址");
};

function addRightMenuClickEvent() {
  // 添加点击事件
  document.getElementById("menu-backward").addEventListener("click", function () {
  window.history.back();
    rm.hideRightMenu();
  });

  document.getElementById("menu-forward").addEventListener("click", function () {
    window.history.forward();
    rm.hideRightMenu();
  });

  document.getElementById("menu-refresh").addEventListener("click", function () {
    window.location.reload();
  });

  document.getElementById("menu-top").addEventListener("click", function () {
    anzhiyu.scrollToDest(0, 500);
    rm.hideRightMenu();
  });

  const menuLinks = document.querySelectorAll(".menu-link");
  menuLinks.forEach(function (link) {
    link.addEventListener("click", rm.hideRightMenu);
  });

  document.getElementById("menu-darkmode").addEventListener("click", anzhiyu.switchDarkMode);

  document.getElementById("menu-home") && document.getElementById("menu-home").addEventListener("click", function () {
    window.location.href = window.location.origin;
  });

  document.getElementById("menu-randomPost").addEventListener("click", function () {
    toRandomPost();
  });

  document.getElementById("menu-commentBarrage").addEventListener("click", anzhiyu.switchCommentBarrage);

  document.getElementById("rightmenu-mask").addEventListener("click", rm.hideRightMenu);

  document.getElementById("rightmenu-mask").addEventListener("contextmenu", function (event) {
    rm.hideRightMenu();
    event.preventDefault(); // Prevent the default context menu from appearing
  });

  document.getElementById("menu-copy").addEventListener("click", rm.copyPageUrl);

  document.getElementById("menu-pastetext").addEventListener("click", rm.pasteText);

  document.getElementById("menu-copytext").addEventListener("click", function () {
    rm.rightmenuCopyText(selectTextNow);
    anzhiyu.snackbarShow("复制成功，复制和转载请标注本文地址");
  });

  document.getElementById("menu-commenttext").addEventListener("click", function () {
    rm.rightMenuCommentText(selectTextNow);
  });

  document.getElementById("menu-newwindow").addEventListener("click", function () {
    window.open(domhref, "_blank");
    rm.hideRightMenu();
  });

  document.getElementById("menu-copylink").addEventListener("click", rm.copyLink);

  document.getElementById("menu-downloadimg").addEventListener("click", function () {
    anzhiyu.downloadImage(domImgSrc, "anzhiyu");
  });

  document.getElementById("menu-newwindowimg").addEventListener("click", function () {
    window.open(domImgSrc, "_blank");
    rm.hideRightMenu();
  });

  document.getElementById("menu-copyimg").addEventListener("click", function () {
    rm.writeClipImg(domImgSrc);
  });

  document.getElementById("menu-searchBaidu").addEventListener("click", rm.searchBaidu);

  //音乐
  document.getElementById("menu-music-toggle").addEventListener("click", anzhiyu.musicToggle);

  document.getElementById("menu-music-back").addEventListener("click", anzhiyu.musicSkipBack);

  document.getElementById("menu-music-forward").addEventListener("click", anzhiyu.musicSkipForward);

  document.getElementById("menu-music-copyMusicName").addEventListener("click", function () {
    rm.rightmenuCopyText(anzhiyu.musicGetName());
    anzhiyu.snackbarShow("复制歌曲名称成功", false, 3000);
  });

}

addRightMenuClickEvent();</script><script data-pjax>var themeColorMeta = document.querySelector('meta[name="theme-color"]');
var pageHeaderEl = document.getElementById("page-header");
var navMusicEl = document.getElementById("nav-music");
var consoleEl = document.getElementById("console");
// 已随机的歌曲
var selectRandomSong = [];
// 音乐默认声音大小
var musicVolume = 0.8;
// 是否切换了周杰伦音乐列表
var changeMusicListFlag = false;
// 当前默认播放列表
var defaultPlayMusicList = [];

document.getElementById("page-name").innerText = document.title.split(" | ♪张小佑")[0];
anzhiyu.initIndexEssay();
anzhiyu.changeTimeInEssay();
anzhiyu.removeBodyPaceClass();
anzhiyu.qrcodeCreate();
anzhiyu.changeTimeInAlbumDetail();
anzhiyu.reflashEssayWaterFall();
anzhiyu.sayhi();
anzhiyu.stopImgRightDrag();
anzhiyu.addNavBackgroundInit();
anzhiyu.setValueToBodyType();
anzhiyu.catalogActive();
anzhiyu.tagsPageActive();
anzhiyu.categoriesBarActive();
anzhiyu.topCategoriesBarScroll();
anzhiyu.switchRightClickMenuHotReview();
anzhiyu.getCustomPlayList();
anzhiyu.addEventListenerConsoleMusicList(false);
setTimeout(() => {
  if (typeof addFriendLinksInFooter === "function") {
    addFriendLinksInFooter();
  }
}, 200)</script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.1.4/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://npm.elemecdn.com/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://npm.elemecdn.com/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://npm.elemecdn.com/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>