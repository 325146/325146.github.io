<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>学习笔记面试合集 | ♪张小佑</title><meta name="keywords" content="C++"><meta name="author" content="🎵张小佑♪"><meta name="copyright" content="🎵张小佑♪"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="学习笔记面试合集"><meta name="application-name" content="学习笔记面试合集"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta name="description" content="积极学习C++吧！">
<meta property="og:type" content="article">
<meta property="og:title" content="学习笔记面试合集">
<meta property="og:url" content="http://acall.love/2023/03/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="♪张小佑">
<meta property="og:description" content="积极学习C++吧！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/iTab-vqm813.webp">
<meta property="article:published_time" content="2023-02-28T16:00:00.000Z">
<meta property="article:modified_time" content="2023-02-28T16:00:00.000Z">
<meta property="article:author" content="🎵张小佑♪">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="后端开发">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/iTab-vqm813.webp"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://acall.love/2023/03/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/"><link rel="preconnect" href="//npm.elemecdn.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://npm.elemecdn.com/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/@fancyapps/ui@4.0.31/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  friends_vue_info: undefined,
  navMusic: true,
  changeMainColorPost: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#3b70fc","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://npm.elemecdn.com/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://npm.elemecdn.com/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '学习笔记面试合集',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-03-01 00:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/1.jpg"/><div class="loading-image-dot"></div><div id="loading-percentage">0%</div></div></div><script>const loadingPercentage = document.getElementById("loading-percentage");
let loadingPercentageTimer = setInterval(function() {
  var progressBar = document.querySelector(".pace-progress");
  if (!progressBar) return
  var currentValue = progressBar.getAttribute("data-progress-text");
  if (currentValue !== loadingPercentage.textContent) {
    loadingPercentage.textContent = currentValue;
    if (currentValue === "100%") {
      clearInterval(loadingPercentageTimer);
    }
  }
}, 100);
const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
    Pace.restart()
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/progress_bar/progress_bar.css"/><script async="async" src="https://npm.elemecdn.com/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div id="web_box"><div id="web_container"><div id="menu-mask"></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://acall.love/" title="博客" target="_blank"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" href="https://image.anheyu.com/" title="安知鱼图床" target="_blank"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">♪张小佑</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child" style="left:17px;"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/202307192211377.png" target="_blank"><img class="post-qr-code-img" alt="wechat" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/202307192211377.png"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/202307192207910.png" target="_blank"><img class="post-qr-code-img" alt="alipayautoh" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/202307192207910.png"/></a><div class="post-qr-code-desc">alipayautoh</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments" onclick="anzhiyu.hideConsole()"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> <span>最新评论</span></span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags" onclick="anzhiyu.hideConsole()"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>23</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" style="font-size: 1.05rem;">后端开发<sup>22</sup></a><a href="/tags/%E9%9D%A2%E7%BB%8F/" style="font-size: 1.05rem;">面经<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>3</sup></a></div></div><hr/></div></div><div class="console-card history" onclick="anzhiyu.hideConsole()"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">五月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">四月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/03/"><span class="card-archive-list-date">三月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/02/"><span class="card-archive-list-date">二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/01/"><span class="card-archive-list-date">一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" onclick="anzhiyu.switchDarkMode()" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div><div class="console-btn-item" id="consoleKeyboard" onclick="anzhiyu.keyboardToggle()" title="快捷键开关"><a class="keyboard-switch"><i class="anzhiyufont anzhiyu-icon-keyboard"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B6%AF/">大学生涯</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/C/" tabindex="-1"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>C++</span></a><a class="article-meta__tags" href="/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" tabindex="-1"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>后端开发</span></a><a class="article-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/" tabindex="-1"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>面试</span></a></span></div></div><h1 class="post-title">学习笔记面试合集</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-28T16:00:00.000Z" title="发表于 2023-03-01 00:00:00">2023-03-01</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-28T16:00:00.000Z" title="更新于 2023-03-01 00:00:00">2023-03-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">91.3k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>277分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="学习笔记面试合集"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为郑州"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>郑州</span></div></div></div><article class="post-content" id="article-container"><h2 id="学习笔记操作系统面经整理："><a href="#学习笔记操作系统面经整理：" class="headerlink" title="学习笔记操作系统面经整理："></a>学习笔记操作系统面经整理：</h2><h4 id="1、进程、线程和协程的区别和联系"><a href="#1、进程、线程和协程的区别和联系" class="headerlink" title="1、进程、线程和协程的区别和联系"></a>1、进程、线程和协程的区别和联系</h4><ul>
<li>进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序；其系统开销较大，需要切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换；进程间通信需要借助操作系统</li>
<li>线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束；切换时只需保存和设置少量寄存器内容，因此开销很小；线程间可以直接读写进程数据段(如全局变量)来进行通信</li>
<li>协程是用户态的轻量级线程，线程内部调度的基本单位，协程处于用户态(没有陷入内核)，调用者为用户栈；直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快；可以通过共享内存、消息队列进行通信</li>
</ul>
<h4 id="2、线程与进程的比较"><a href="#2、线程与进程的比较" class="headerlink" title="2、线程与进程的比较"></a>2、线程与进程的比较</h4><ul>
<li>线程启动速度快，轻量级</li>
<li>线程的系统开销小</li>
<li>线程使用有一定难度，需要处理数据一致性问题</li>
<li>同一线程共享的有堆、全局变量、静态变量、指针，引用、文件等，而独自占有栈</li>
<li>调度：线程是调度的基本单位（PC，状态码，通用寄存器，线程栈及栈指针）；进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）。</li>
<li>并发性：一个进程内多个线程可以并发（最好和CPU核数相等）；多个进程可以并发。</li>
<li>拥有资源：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。</li>
<li>系统开销：线程创建销毁只需要处理PC值，状态码，通用寄存器值，线程栈及栈指针即可；进程创建和销毁需要重新分配及销毁task_struct结构。</li>
</ul>
<h4 id="3、一个进程可以创建多少线程，和什么有关？"><a href="#3、一个进程可以创建多少线程，和什么有关？" class="headerlink" title="3、一个进程可以创建多少线程，和什么有关？"></a>3、一个进程可以创建多少线程，和什么有关？</h4><ul>
<li><p>这个和系统有关，对于32 位系统，用户态的虚拟空间只有 3G，如果创建线程时分配的栈空间是 10M，那么一个进程最多只能创建 300 个左右的线程</p>
</li>
<li><p>如果是64 位系统，用户态的虚拟空间大到有 128T，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制</p>
<p>ps：<strong>过多的线程将会导致大量的时间浪费在线程切换上，给程序运行效率带来负面影响，无用线程要及时销毁</strong></p>
</li>
</ul>
<h4 id="4、外中断和异常有什么区别？"><a href="#4、外中断和异常有什么区别？" class="headerlink" title="4、外中断和异常有什么区别？"></a>4、外中断和异常有什么区别？</h4><ul>
<li>外中断是指由 CPU 执行指令以外的事件引起，如 I&#x2F;O 完成中断，表示设备输入&#x2F;输出处理已经完成，处理器能够发送下一个输入&#x2F;输出请求。此外还有时钟中断、控制台中断等。</li>
<li>而异常时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</li>
</ul>
<h4 id="5、进程线程模型你知道多少？"><a href="#5、进程线程模型你知道多少？" class="headerlink" title="5、进程线程模型你知道多少？"></a>5、进程线程模型你知道多少？</h4><p><strong>多线程</strong></p>
<ul>
<li>用户态的多线程模型：同一个进程内部有多个线程，所有的线程共享同一个进程的内存空间，进程中定义的全局变量会被所有的线程共享，比如有全局变量int i &#x3D; 10，这一进程中所有并发运行的线程都可以读取和修改这个i的值，而多个线程被CPU调度的顺序又是不可控的，所以对临界资源的访问尤其需要注意安全</li>
<li><strong>做一次简单的i &#x3D; i + 1在计算机中并不是原子操作，涉及内存取数，计算和写入内存几个环节，</strong>而线程的切换有可能发生在上述任何一个环节中间，所以不同的操作顺序很有可能带来意想不到的结果</li>
<li>虽然线程在安全性方面会引入许多新挑战，但是线程带来的好处也是有目共睹的。首先，原先顺序执行的程序（暂时不考虑多进程）可以被拆分成几个独立的逻辑流，这些逻辑流可以独立完成一些任务（最好这些任务是不相关的）</li>
<li>多线程模型需要特别关注线程之间有无先后访问顺序（线程依赖关系）和多个线程共享访问同一变量（同步互斥问题）；</li>
<li>每个线程特有的部分除了标识线程的tid，还有自己独立的栈空间，线程彼此之间是无法访问其他线程栈上内容的。而作为处理机调度的最小单位，线程调度只需要保存线程栈、寄存器数据和PC即可，相比进程切换开销要小很多</li>
<li>线程基本操作的接口如下：<ul>
<li><p>创建线程：int pthread_create(pthread_t *tidp,const pthread_attr_t *attr, void *(<em>start_rtn)(void</em>),void *arg);创建一个新线程，pthread和start_routine不可或缺，分别用于标识线程和执行体入口，其他可以填NULL。</p>
<ul>
<li>pthread：用来返回线程的tid，*pthread值即为tid，类型pthread_t &#x3D;&#x3D; unsigned long int。</li>
<li>attr：指向线程属性结构体的指针，用于改变所创线程的属性，填NULL使用默认值。</li>
<li>start_routine：线程执行函数的首地址，传入函数指针。</li>
<li>arg：通过地址传递来传递函数参数，这里是无符号类型指针，可以传任意类型变量的地址，在被传入函数中先强制类型转换成所需类型即可。</li>
</ul>
</li>
<li><p>获得线程ID：pthread_t pthread_self();调用时，会打印线程ID。</p>
</li>
<li><p>等待线程结束：int pthread_join(pthread_t tid, void** retval);主线程调用，等待子线程退出并回收其资源，类似于进程中wait&#x2F;waitpid回收僵尸进程，调用pthread_join的线程会被阻塞。</p>
<ul>
<li>tid：创建线程时通过指针得到tid值。</li>
<li>retval：指向返回值的指针。</li>
</ul>
</li>
<li><p>结束线程：pthread_exit(void *retval);子线程执行，用来结束当前线程并通过retval传递返回值，该返回值可通过pthread_join获得。</p>
</li>
<li><p>分离线程：int pthread_detach(pthread_t tid);主线程、子线程均可调用。主线程中pthread_detach(tid)，子线程中pthread_detach(pthread_self())，调用后和主线程分离，子线程结束时自己立即回收资源。</p>
</li>
</ul>
</li>
</ul>
<p><strong>多进程</strong></p>
<ul>
<li><p>每一个进程是资源分配的基本单位。进程结构由以下几个部分组成：代码段、堆栈段、数据段。代码段是静态的二进制代码，多个程序可以共享。实际上在父进程创建子进程之后，父、子进程除了pid外，几乎所有的部分几乎一样。父、子进程共享全部数据，但并不是说他们就是对同一块数据进行操作，子进程在读写数据时会通过写时复制机制将公共的数据重新拷贝一份，之后在拷贝出的数据上进行操作；如果子进程想要运行自己的代码段，还可以通过调用execv()函数重新加载新的代码段，之后就和父进程独立开了。</p>
</li>
<li><p>进程有两种创建方式，一种是操作系统创建的一种是父进程创建的。所有创建的进程都是shell进程的子进程，这也就是为什么shell一关闭，在shell中执行的进程都自动被关闭的原因。从shell进程到创建其他子进程需要通过以下接口：</p>
<ul>
<li><p>创建进程：pid_t fork(void);返回值：出错返回-1；父进程中返回pid &gt; 0；子进程中pid &#x3D;&#x3D; 0</p>
</li>
<li><p>结束进程：void exit(int status); status是退出状态，保存在全局变量中S?，通常0表示正常退出。</p>
</li>
<li><p>获得PID：pid_t getpid(void);返回调用者pid。</p>
</li>
<li><p>获得父进程PID：pid_t getppid(void); 返回父进程pid。</p>
</li>
</ul>
</li>
<li><p>正常退出方式：exit()、_exit()、return（在main中）。</p>
<p>exit()和 _ exit()区别：exit()是对 _ _ exit()的封装，都会终止进程并做相关收尾工作，最主要的区别是 _ exit()函数关闭全部描述符和清理函数后不会刷新流，但是exit()会在调用_exit()函数前刷新数据流。</p>
<p>return和exit()区别：exit()是函数，但有参数，执行完之后控制权交给系统。return若是在调用函数中，执行完之后控制权交给调用进程，若是在main函数中，控制权交给系统。</p>
</li>
<li><p>异常退出方式：abort()、终止信号。</p>
</li>
<li><p>进程地址空间（地址空间）：虚拟存储器为每个进程提供了独占系统地址空间的假象。尽管每个进程地址空间内容不尽相同，但是他们的都有相似的结构。X86 Linux进程的地址空间底部是保留给用户程序的，包括文本、数据、堆、栈等，其中文本区和数据区是通过存储器映射方式将磁盘中可执行文件的相应段映射至虚拟存储器地址空间中。对于32位进程来说，代码段从0x08048000开始。从0xC0000000开始到0xFFFFFFFF是内核地址空间，通常情况下代码运行在用户态</p>
</li>
<li><p>进程的调度实际就是内核选择相应的进程控制块，被选择的进程控制块中包含了一个进程基本的信息。每一次进程调度就是一次上下文切换，所谓的上下文本质上就是当前运行状态，主要包括通用寄存器、浮点寄存器、状态寄存器、程序计数器、用户栈和内核数据结构（页表、进程表、文件表）等。进程执行时刻，内核可以决定抢占当前进程并开始新的进程，这个过程由内核调度器完成，当调度器选择了某个进程时称为该进程被调度，该过程通过上下文切换来改变当前状态。一次完整的上下文切换通常是进程原先运行于用户态，之后因系统调用或时间片到切换到内核态执行内核指令，完成上下文切换后回到用户态，此时已经切换到进程B。</p>
</li>
</ul>
<h4 id="6、进程调度算法你了解多少？"><a href="#6、进程调度算法你了解多少？" class="headerlink" title="6、进程调度算法你了解多少？"></a>6、进程调度算法你了解多少？</h4><ul>
<li><p><strong>先来先服务 first-come first-serverd（FCFS）</strong>：非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长</p>
</li>
<li><p><strong>短作业优先 shortest job first（SJF）</strong>：非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
</li>
<li><p><strong>最短剩余时间优先 shortest remaining time next（SRTN）</strong>：最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
</li>
<li><p><strong>时间片轮转</strong>：将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。时间片轮转算法的效率和时间片的大小有很大关系：</p>
<ul>
<li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li>
<li>而如果时间片过长，那么实时性就不能得到保证。</li>
</ul>
</li>
<li><p><strong>优先级调度</strong>：为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
</li>
<li><p><strong>多级反馈队列</strong>：一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>
</li>
</ul>
<h4 id="7、Linux下进程间通信方式？"><a href="#7、Linux下进程间通信方式？" class="headerlink" title="7、Linux下进程间通信方式？"></a>7、Linux下进程间通信方式？</h4><ul>
<li>无名管道（内存文件）：无名管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。</li>
<li>有名管道（FIFO文件，借助文件系统）：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式。</li>
<li>共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与信号量，配合使用来实现进程间的同步和通信。</li>
<li>消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点</li>
<li>套接字：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。</li>
<li>信号：用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。</li>
<li>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问</li>
</ul>
<h4 id="8、Linux下同步机制？"><a href="#8、Linux下同步机制？" class="headerlink" title="8、Linux下同步机制？"></a>8、Linux下同步机制？</h4><ul>
<li>POSIX信号量：可用于进程同步，也可用于线程同步。</li>
<li>POSIX互斥锁 + 条件变量：只能用于线程同步。</li>
</ul>
<h4 id="9、如果系统中具有快表后，那么地址的转换过程变成什么样了？"><a href="#9、如果系统中具有快表后，那么地址的转换过程变成什么样了？" class="headerlink" title="9、如果系统中具有快表后，那么地址的转换过程变成什么样了？"></a>9、如果系统中具有快表后，那么地址的转换过程变成什么样了？</h4><p>①CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</p>
<p>②如果找到匹配的页号，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。</p>
<p>③如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此,若快表未命中，则访问某个逻辑地址需要两次访存(注意:在找到页表项后，应同时将其存入快表,以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换)</p>
<p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。 因为局部性原理，一般来说快表的命中率可以达到90%以上。</p>
<h4 id="10、内存交换和覆盖有什么区别？"><a href="#10、内存交换和覆盖有什么区别？" class="headerlink" title="10、内存交换和覆盖有什么区别？"></a>10、内存交换和覆盖有什么区别？</h4><ul>
<li>交换技术主要是在不同进程（或作业）之间进行，而覆盖则用于同一程序或进程中</li>
<li>覆盖的基本思想是：由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序）， 因此可以把用户空间分成一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分按调用关系分段。首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段</li>
<li>交换（对换）的基本思想是： 把处于等待（阻塞）状态（或在CPU调度原则下被剥夺运行权利）的程序（进程）从内存移到外存，把内存空间腾出来，这一过程又叫换出。把准备好竞争CPU运行的程序从外存移到内存，这一过程又称为换入</li>
</ul>
<h4 id="11、动态分区分配算法有哪几种？可以分别说说吗？"><a href="#11、动态分区分配算法有哪几种？可以分别说说吗？" class="headerlink" title="11、动态分区分配算法有哪几种？可以分别说说吗？"></a>11、动态分区分配算法有哪几种？可以分别说说吗？</h4><ul>
<li>首次适应算法：每次都从低地址开始查找，找到第一个能满足大小的空闲分区；空闲分区以地址递增的次序排列。</li>
<li>最佳适应算法：为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区,即优先使用更小的空闲区；空闲分区按容量递增次序链接；</li>
<li>最坏适应算法：为了解决最佳适应算法的问题—即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用；空闲分区按容量递减次序链接</li>
<li>邻近适应算法：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题；每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区</li>
</ul>
<h4 id="12、虚拟技术你了解吗？"><a href="#12、虚拟技术你了解吗？" class="headerlink" title="12、虚拟技术你了解吗？"></a>12、虚拟技术你了解吗？</h4><ul>
<li>主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</li>
<li><strong>多进程与多线程</strong>：多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</li>
<li><strong>虚拟内存</strong>使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中</li>
</ul>
<h4 id="13、进程状态的切换你知道多少？"><a href="#13、进程状态的切换你知道多少？" class="headerlink" title="13、进程状态的切换你知道多少？"></a>13、进程状态的切换你知道多少？</h4><ul>
<li>主要分为就绪状态（等待被调度）和运行状态以及阻塞状态（等待资源）</li>
<li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li>
<li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li>
</ul>
<h4 id="14、一个程序从开始运行到结束的完整过程，你能说出来多少？"><a href="#14、一个程序从开始运行到结束的完整过程，你能说出来多少？" class="headerlink" title="14、一个程序从开始运行到结束的完整过程，你能说出来多少？"></a>14、一个程序从开始运行到结束的完整过程，你能说出来多少？</h4><ul>
<li><strong>预编译</strong>：主要处理源代码文件中的以“#”开头的预编译指令</li>
<li><strong>编译</strong>： 把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件</li>
<li><strong>汇编</strong>：将汇编代码转变成机器可以执行的指令(机器码文件)。 根据汇编指令和机器指令的对照表一一翻译过来</li>
<li><strong>链接</strong>：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：<ul>
<li>静态链接：函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。 空间浪费、更新困难、运行速度快</li>
<li>动态链接：把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。共享库、更新方便、性能损耗</li>
</ul>
</li>
</ul>
<h4 id="15、通过例子讲解逻辑地址转换为物理地址的基本过程"><a href="#15、通过例子讲解逻辑地址转换为物理地址的基本过程" class="headerlink" title="15、通过例子讲解逻辑地址转换为物理地址的基本过程"></a>15、通过例子讲解逻辑地址转换为物理地址的基本过程</h4><ul>
<li><p>借助进程的页表将逻辑地址转换为物理地址；通常会在系统中设置一个页表寄存器(PTR)，存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块(PCB) 中，当进程被调度时，操作系统内核会把它们放到页表寄存器中</p>
</li>
<li><p>首先根据逻辑地址计算出页号和页面偏移量，判断页号是否越界，无越界则查询页表，找到页号对应的页表项，对应页面；然后用内存块号和偏移量得到物理地址访问目标内存单元</p>
</li>
<li><p>例:若页面大小L为1K字节，页号2对应的内存块号b&#x3D;8，将逻辑地址A&#x3D;2500转换为物理地址E。 等价描述：某系统按字节寻址，逻辑地址结构中，页内偏移量占10位(说明一个页面的大小为2^10B &#x3D; 1KB)，页号2对应的内存块号 b&#x3D;8，将逻辑地址A&#x3D;2500转换为物理地址E。</p>
<blockquote>
<p>①计算页号、页内偏移量 页号P&#x3D;A&#x2F;L &#x3D; 2500&#x2F;1024 &#x3D; 2; 页内偏移量W&#x3D; A%L &#x3D; 2500%1024 &#x3D; 452</p>
<p>②根据题中条件可知，页号2没有越界，其存放的内存块号b&#x3D;8</p>
<p>③物理地址E&#x3D;b*L+W&#x3D;8 * 1024+ 425 &#x3D; 8644</p>
</blockquote>
</li>
<li><p>在分页存储管理(页式管理)的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理中地址是一维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。</p>
</li>
</ul>
<h4 id="16、进程同步的四种方法？"><a href="#16、进程同步的四种方法？" class="headerlink" title="16、进程同步的四种方法？"></a>16、进程同步的四种方法？</h4><ul>
<li>临界区：对临界资源进行访问的那段代码称为临界区。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</li>
<li>互斥量：采用互斥对象机制。 只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。</li>
<li>信号量：允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目，与操作系统中的PV操作相同，信号量S是一个整数，S大于等于零时代表可供并发进程使用的资源实体数，但S小于零时则表示正在等待使用共享资源的进程数。</li>
<li>事件： 通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作</li>
</ul>
<h4 id="17、操作系统在对内存进行管理的时候需要做些什么"><a href="#17、操作系统在对内存进行管理的时候需要做些什么" class="headerlink" title="17、操作系统在对内存进行管理的时候需要做些什么?"></a>17、操作系统在对内存进行管理的时候需要做些什么?</h4><ul>
<li><p>负责内存空间的分配与回收。</p>
</li>
<li><p>需要提供某种技术从逻辑上对内存空间进行扩充。</p>
</li>
<li><p>需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换。</p>
</li>
<li><p>需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰</p>
</li>
</ul>
<h4 id="18、进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）"><a href="#18、进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）" class="headerlink" title="18、进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）"></a>18、进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）</h4><ul>
<li>管道(pipe)：允许一个进程和另一个与它有共同祖先的进程之间进行通信</li>
<li>命名管道(FIFO)：类似于管道，但是它可以用于任何两个进程之间的通信，命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建</li>
<li>消息队列(MQ)：消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收</li>
<li>信号量(semaphore)：信号量主要作为进程间以及同进程不同线程之间的同步手段；</li>
<li>共享内存(shared memory)：它使得多个进程可以访问同一块内存空间，<strong>是最快的可用IPC形式。</strong>这是针对其他通信机制运行效率较低而设计的。它往往与其他通信机制，如信号量结合使用，以达到进程间的同步及互斥</li>
<li>信号(signal)：信号是比较复杂的通信方式，用于通知接收进程有某种事情发生，除了用于进程间通信外，进程还可以发送信号给进程本身</li>
<li>内存映射(mapped memory)：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它</li>
<li>Socket：它是更为通用的进程间通信机制，可用于不同机器之间的进程间通信</li>
<li>线程通信方法主要有信号、信号量、条件变量和锁机制等，window下还有全局变量、Message消息机制和CEvent对象等</li>
</ul>
<h4 id="20、虚拟内存的目的是什么？"><a href="#20、虚拟内存的目的是什么？" class="headerlink" title="20、虚拟内存的目的是什么？"></a>20、虚拟内存的目的是什么？</h4><ul>
<li><p>为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p>
</li>
<li><p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p>
</li>
<li><p>虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能</p>
</li>
</ul>
<h4 id="21、说一下你理解中的内存？他有什么作用呢？"><a href="#21、说一下你理解中的内存？他有什么作用呢？" class="headerlink" title="21、说一下你理解中的内存？他有什么作用呢？"></a>21、说一下你理解中的内存？他有什么作用呢？</h4><ul>
<li><p>内存用于暂时存放处理器中的运算数据，以及与硬盘等外部储存器交换的数据，内存是外界与处理器进行沟通的桥梁，程序执行前都需要放到内存才能被CPU进行处理</p>
</li>
<li><p>磁盘也是存放数据的硬件，但是磁盘的速度很慢，如果都在磁盘上运行将会很慢，<strong>内存比机械硬盘快 100000 倍左右；</strong>CPU cache又太小，无法存放太多的数据。</p>
</li>
</ul>
<h4 id="22、操作系统经典问题之哲学家进餐问题"><a href="#22、操作系统经典问题之哲学家进餐问题" class="headerlink" title="22、操作系统经典问题之哲学家进餐问题"></a>22、操作系统经典问题之哲学家进餐问题</h4><ul>
<li>为了防止死锁的发生，可以设置两个条件：必须同时拿起左右两根筷子；只有在两个邻居都没有进餐的情况下才允许进餐</li>
</ul>
<h4 id="23、操作系统经典问题之读者-写者问题"><a href="#23、操作系统经典问题之读者-写者问题" class="headerlink" title="23、操作系统经典问题之读者-写者问题"></a>23、操作系统经典问题之读者-写者问题</h4><ul>
<li><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p>
</li>
<li><p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p>
</li>
</ul>
<h4 id="24、介绍一下几种典型的锁？"><a href="#24、介绍一下几种典型的锁？" class="headerlink" title="24、介绍一下几种典型的锁？"></a>24、介绍一下几种典型的锁？</h4><ul>
<li>读写锁：多个读者可以同时进行读；写者必须互斥（只允许一个写者写，也不能读者写者同时进行）；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</li>
<li>互斥锁：一次只能一个线程拥有互斥锁，其他线程只有等待；在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，在加锁操作时涉及上下文的切换</li>
<li>条件变量：互斥锁一个明显的缺点是只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件；互斥锁是线程间互斥的机制，条件变量则是同步机制</li>
<li>自旋锁：如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。一般应用于加锁时间很短的场景，这个时候效率比较高</li>
</ul>
<h4 id="25、逻辑地址VS物理地址"><a href="#25、逻辑地址VS物理地址" class="headerlink" title="25、逻辑地址VS物理地址"></a>25、逻辑地址VS物理地址</h4><ul>
<li>编译时只需确定变量x存放的相对地址是100 ( 也就是说相对于进程在内存中的起始地址而言的地址)。CPU想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可。 相对地址又称逻辑地址，绝对地址又称物理地址。</li>
</ul>
<h4 id="28、内存交换是什么？有什么特点？"><a href="#28、内存交换是什么？有什么特点？" class="headerlink" title="28、内存交换是什么？有什么特点？"></a>28、内存交换是什么？有什么特点？</h4><ul>
<li><strong>交换(对换)技术的设计思想</strong>：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存<ul>
<li><p>换入：把准备好竞争CPU运行的程序从辅存移到内存。 </p>
</li>
<li><p>换出：把处于等待状态的程序从内存移到辅存，把内存空间腾出来</p>
</li>
</ul>
</li>
</ul>
<h4 id="29、什么时候会进行内存的交换？"><a href="#29、什么时候会进行内存的交换？" class="headerlink" title="29、什么时候会进行内存的交换？"></a>29、什么时候会进行内存的交换？</h4><ul>
<li>内存交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如:在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程;如果缺页率明显下降，就可以暂停换出</li>
</ul>
<h4 id="30、终端退出，终端运行的进程会怎样"><a href="#30、终端退出，终端运行的进程会怎样" class="headerlink" title="30、终端退出，终端运行的进程会怎样"></a>30、终端退出，终端运行的进程会怎样</h4><ul>
<li>终端在退出时会发送SIGHUP给对应的bash进程，bash进程收到这个信号后首先将它发给session下面的进程，如果程序没有对SIGHUP信号做特殊处理，那么进程就会随着终端关闭而退出</li>
</ul>
<h4 id="31、如何让进程后台运行"><a href="#31、如何让进程后台运行" class="headerlink" title="31、如何让进程后台运行"></a>31、如何让进程后台运行</h4><ul>
<li><p>命令后面加上&amp;即可，实际上，这样是将命令放入到一个作业队列中了</p>
</li>
<li><p>ctrl + z 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程</p>
</li>
<li><p>nohup + &amp;，将标准输出和标准错误缺省会被重定向到 nohup.out 文件中，忽略所有挂断（SIGHUP）信号</p>
</li>
<li><p>运行指令前面 + setsid，使其父进程编程init进程，不受HUP信号的影响</p>
</li>
<li><p>将 命令+ &amp;放在()括号中，也可以是进程不受HUP信号的影响</p>
</li>
</ul>
<h4 id="32、什么是快表，你知道多少关于快表的知识？"><a href="#32、什么是快表，你知道多少关于快表的知识？" class="headerlink" title="32、什么是快表，你知道多少关于快表的知识？"></a>32、什么是快表，你知道多少关于快表的知识？</h4><ul>
<li>快表，又称联想寄存器(TLB) ，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。其实就是一种缓存的思想，缓存使用过的页表</li>
</ul>
<h4 id="34、在执行malloc申请内存的时候，操作系统是怎么做的？"><a href="#34、在执行malloc申请内存的时候，操作系统是怎么做的？" class="headerlink" title="34、在执行malloc申请内存的时候，操作系统是怎么做的？"></a>34、在执行malloc申请内存的时候，操作系统是怎么做的？</h4><ul>
<li><p>从操作系统层面上看，malloc是通过两个系统调用来实现的： brk和mmap</p>
<ul>
<li>brk是将进程数据段(.data)的最高地址指针向高处移动，这一步可以扩大进程在运行时的堆大小</li>
<li>mmap是在进程的虚拟地址空间中寻找一块空闲的虚拟内存，这一步可以获得一块可以操作的堆内存。</li>
</ul>
</li>
<li><p>通常，分配的内存小于128k时，使用brk调用来获得虚拟内存，大于128k时就使用mmap来获得虚拟内存。</p>
</li>
<li><p>进程先通过这两个系统调用获取或者扩大进程的虚拟内存，获得相应的虚拟地址，在访问这些虚拟地址的时候，通过缺页中断，让内核分配相应的物理内存，这样内存分配才算完成。</p>
</li>
</ul>
<h4 id="35、-守护进程、僵尸进程和孤儿进程"><a href="#35、-守护进程、僵尸进程和孤儿进程" class="headerlink" title="35、 守护进程、僵尸进程和孤儿进程"></a>35、 守护进程、僵尸进程和孤儿进程</h4><ul>
<li>守护进程：在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。Linux的大多数服务器就是用守护进程的方式实现的，如web服务器进程http等；主要是通过fork产生一个子进程，然后使父进程退出</li>
<li>孤儿进程：如果父进程先退出，子进程还没退出，那么子进程的父进程将变为init进程(注：任何一个进程都必须有父进程）一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</li>
<li>僵尸进程：如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵尸进程。设置<strong>僵尸进程的目</strong>的是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息。如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程ID将被重置为1，继承这些子进程的init进程将清理它们</li>
</ul>
<h4 id="36、如何避免僵尸进程？"><a href="#36、如何避免僵尸进程？" class="headerlink" title="36、如何避免僵尸进程？"></a>36、如何避免僵尸进程？</h4><ul>
<li><p>通过signal(SIGCHLD, SIG_IGN)通知内核对子进程的结束不关心，由内核回收。这常用于并发服务器的性能提高，因为并发服务器常常fork很多子进程，子进程终结之后需要服务器进程去wait清理资源。如果将此信号的处理方式设为忽略，可让内核把僵尸子进程转交给init进程去处理，省去了大量僵尸进程占用系统资源。</p>
</li>
<li><p>父进程调用wait&#x2F;waitpid等函数等待子进程结束，如果尚无子进程退出wait会导致父进程阻塞。waitpid可以通过传递WNOHANG使父进程不阻塞立即返回。</p>
</li>
<li><p>通过两次调用fork。父进程首先调用fork创建一个子进程然后waitpid等待子进程退出，子进程再fork一个孙进程后退出。这样子进程退出后会被父进程等待回收，而对于孙子进程其父进程已经退出所以孙进程成为一个孤儿进程，孤儿进程由init进程接管，孙进程结束后，init会等待回收。</p>
</li>
</ul>
<h4 id="37、局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？"><a href="#37、局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？" class="headerlink" title="37、局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？"></a>37、局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？</h4><ul>
<li>主要分为<strong>时间局部性和空间局部性</strong>。</li>
<li>时间局部性:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)</li>
<li>空间局部性:一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)</li>
</ul>
<h4 id="38、父进程、子进程、进程组、作业和会话"><a href="#38、父进程、子进程、进程组、作业和会话" class="headerlink" title="38、父进程、子进程、进程组、作业和会话"></a>38、父进程、子进程、进程组、作业和会话</h4><ul>
<li>父进程：已创建一个或多个子进程的进程</li>
<li>子进程：由fork创建的新进程被称为子进程（child process）。该函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0，而父进程的返回值则是新进程（子进程）的进程 id。<ul>
<li>fork之后，操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系，这2个进程共享代码空间，但是数据空间是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置</li>
<li>将子进程id返回给父进程的理由是：因为一个进程的子进程可以多于一个，没有一个函数使一个进程可以获得其所有子进程的进程id。</li>
<li>对子进程来说，之所以fork返回0给它，是因为它随时可以调用getpid()来获取自己的pid；也可以调用getppid()来获取父进程的id。(进程id 0总是由交换进程使用，所以一个子进程的进程id不可能为0 )。</li>
<li>子进程从父进程继承的有：进程的资格；环境(environment)；堆栈；内存；进程组号</li>
<li>独有：进程号；不同的父进程号；资源使用(resource utilizations)设定为0</li>
</ul>
</li>
<li>进程组：进程组就是多个进程的集合，其中肯定有一个组长，其进程PID等于进程组的PGID。只要在某个进程组中一个进程存在，该进程组就存在，这与其组长进程是否终止无关。</li>
<li>作业：shell分前后台来控制的不是进程而是作业（job）或者进程组（Process Group）。<ul>
<li>一个前台作业可以由多个进程组成，一个后台也可以由多个进程组成，shell可以运行一个前台作业和任意多个后台作业，这称为作业控制</li>
<li>为什么只能运行一个前台作业？<ul>
<li>当我们在前台新起了一个作业，shell就被提到了后台，因此shell就没有办法再继续接受我们的指令并且解析运行了。 但是如果前台进程退出了，shell就会有被提到前台来，就可以继续接受我们的命令并且解析运行。</li>
</ul>
</li>
<li>作业与进程组的区别：如果作业中的某个进程有创建了子进程，则该子进程是不属于该作业的。 一旦作业运行结束，shell就把自己提到前台（子进程还存在，但是子进程不属于作业），如果原来的前台进程还存在（这个子进程还没有终止），他将自动变为后台进程组</li>
</ul>
</li>
<li>会话:会话（Session）是一个或多个进程组的集合。一个会话可以有一个控制终端。在xshell或者WinSCP中打开一个窗口就是新建一个会话。</li>
</ul>
<h4 id="39、进程终止的几种方式"><a href="#39、进程终止的几种方式" class="headerlink" title="39、进程终止的几种方式"></a>39、进程终止的几种方式</h4><ul>
<li>main函数的自然返回，<code>return</code> </li>
<li>调用<code>exit</code>函数，属于c的函数库 </li>
<li>调用<code>_exit</code>函数，属于系统调用 </li>
<li>调用<code>abort</code>函数，异常程序终止，同时发送SIGABRT信号给调用进程。 </li>
<li>接受能导致进程终止的信号：ctrl+c (^C)、SIGINT(SIGINT中断进程)</li>
</ul>
<h4 id="40、Linux中异常和中断的区别"><a href="#40、Linux中异常和中断的区别" class="headerlink" title="40、Linux中异常和中断的区别"></a>40、Linux中异常和中断的区别</h4><ul>
<li><p><strong>中断</strong>：中断是由硬件设备产生的，而它们从物理上说就是电信号，之后，它们通过中断控制器发送给CPU，接着CPU判断收到的中断来自于哪个硬件设备（这定义在内核中），最后，由CPU发送给内核，有内核处理中断。比如在敲击键盘的同时就会产生中断，当硬盘读写完数据之后也会产生中断</p>
</li>
<li><p><strong>异常</strong>：异常是由CPU产生的，同时，它会发送给内核，要求内核处理这些异常，比如CPU处理程序的时候一旦程序不在内存中，会产生缺页异常；当运行除法程序时，当除数为0时，又会产生除0异常。</p>
</li>
<li><p><strong>相同点</strong>：</p>
<ul>
<li><p>最后都是由CPU发送给内核，由内核去处理</p>
</li>
<li><p>处理程序的流程设计上是相似的</p>
</li>
</ul>
</li>
<li><p><strong>不同点</strong>：</p>
<ul>
<li><p>产生源不相同，异常是由CPU产生的，而中断是由硬件设备产生的</p>
</li>
<li><p>内核需要根据是异常还是中断调用不同的处理程序</p>
</li>
<li><p>中断不是时钟同步的，这意味着中断可能随时到来；异常由于是CPU产生的，所以它是时钟同步的</p>
</li>
<li><p>当处理中断时，处于中断上下文中；处理异常时，处于进程上下文中</p>
</li>
</ul>
</li>
</ul>
<h4 id="41、Windows和Linux环境下内存分布情况"><a href="#41、Windows和Linux环境下内存分布情况" class="headerlink" title="41、Windows和Linux环境下内存分布情况"></a>41、Windows和Linux环境下内存分布情况</h4><p>用户空间内存，从<strong>低到高</strong>分别是 7 种不同的内存段：</p>
<ul>
<li>程序文件段，包括二进制可执行代码；</li>
<li>已初始化数据段，包括静态常量；</li>
<li>未初始化数据段，包括未初始化的静态变量；</li>
<li>堆段，包括动态分配的内存，从低地址开始向上增长；</li>
<li>文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关）</li>
<li>栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 <code>8 MB</code>。当然系统也提供了参数，以便我们自定义大小；</li>
</ul>
<h4 id="42、一个由C-x2F-C-编译的程序占用的内存分为哪几个部分？"><a href="#42、一个由C-x2F-C-编译的程序占用的内存分为哪几个部分？" class="headerlink" title="42、一个由C&#x2F;C++编译的程序占用的内存分为哪几个部分？"></a>42、一个由C&#x2F;C++编译的程序占用的内存分为哪几个部分？</h4><ul>
<li>栈区（stack）— 地址向下增长，由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的数据结构中的栈，先进后出。</li>
<li>堆区（heap）— 地址向上增长，一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</li>
<li>全局区（静态区）（static）—全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放</li>
<li>文字常量区 —常量字符串就是放在这里的。程序结束后由系统释放</li>
<li>程序代码区(text)—存放函数体的二进制代码</li>
</ul>
<h4 id="43、一般情况下在Linux-x2F-windows平台下栈空间的大小"><a href="#43、一般情况下在Linux-x2F-windows平台下栈空间的大小" class="headerlink" title="43、一般情况下在Linux&#x2F;windows平台下栈空间的大小"></a>43、一般情况下在Linux&#x2F;windows平台下栈空间的大小</h4><ul>
<li>Linux环境下有操作系统决定，一般是8MB，8192KB，通过ulimit命令查看以及修改</li>
<li>Windows环境下由编译器决定，VC++6.0一般是1M</li>
</ul>
<h4 id="44、程序从堆中动态分配内存时，虚拟内存上怎么操作的"><a href="#44、程序从堆中动态分配内存时，虚拟内存上怎么操作的" class="headerlink" title="44、程序从堆中动态分配内存时，虚拟内存上怎么操作的"></a>44、程序从堆中动态分配内存时，虚拟内存上怎么操作的</h4><ul>
<li>在进行动态内存分配时，例如malloc()函数或者其他高级语言中的new关键字，操作系统会在硬盘中创建或申请一段虚拟内存空间，并更新到页表（分配一个页表条目（PTE），使该PTE指向硬盘上这个新创建的虚拟页），通过PTE建立虚拟页和物理页的映射关系</li>
</ul>
<h4 id="45、常见的几种磁盘调度算法"><a href="#45、常见的几种磁盘调度算法" class="headerlink" title="45、常见的几种磁盘调度算法"></a>45、常见的几种磁盘调度算法</h4><ul>
<li>先来先服务：按照磁盘请求的顺序进行调度。</li>
<li>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</li>
<li>最短寻道时间优先：优先调度与当前磁头所在磁道距离最近的磁道。<ul>
<li>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</li>
</ul>
</li>
<li>电梯扫描算法：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</li>
<li>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</li>
<li>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题</li>
</ul>
<h4 id="46、交换空间与虚拟内存的关系"><a href="#46、交换空间与虚拟内存的关系" class="headerlink" title="46、交换空间与虚拟内存的关系"></a>46、交换空间与虚拟内存的关系</h4><ul>
<li><strong>交换空间</strong>：Linux 中的交换空间（Swap space）在<strong>物理内存</strong>（RAM）被充满时被使用。如果系统需要更多的内存资源，而物理内存已经充满，内存中不活跃的页就会被移到交换空间去。<ul>
<li>虽然交换空间可以为带有少量内存的机器提供帮助，但是这种方法不应该被当做是对内存的取代。</li>
<li>交换空间位于硬盘驱动器上，它比进入物理内存要慢。 </li>
<li>交换空间可以是一个专用的交换分区（推荐的方法），交换文件，或两者的组合。 </li>
<li>交换空间的总大小应该相当于你的计算机内存的两倍和 32 MB这两个值中较大的一个，但是它不能超过 2048MB（2 GB）</li>
</ul>
</li>
<li><strong>虚拟内存</strong>：虚拟内存是文件数据交叉链接的活动文件。<ul>
<li>就速度方面而言,CPU的L1和L2缓存速度最快，内存次之，硬盘再次之。但是<strong>虚拟内存使用的是硬盘的空间</strong></li>
<li>为什么我们要使用速度最慢的硬盘来做为虚拟内存呢？因为电脑中所有运行的程序都需要经过内存来执行，如果执行的程序很大或很多，就会导致内存消耗殆尽。而硬盘空间动辄几十G上百G，为了解决这个问题，Windows中运用了虚拟内存技术，即拿出一部分硬盘空间来充当内存使用。</li>
</ul>
</li>
</ul>
<h4 id="47、抖动你知道是什么吗？它也叫颠簸现象"><a href="#47、抖动你知道是什么吗？它也叫颠簸现象" class="headerlink" title="47、抖动你知道是什么吗？它也叫颠簸现象"></a>47、抖动你知道是什么吗？它也叫颠簸现象</h4><ul>
<li><strong>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存</strong>，这种频繁的页面调度行为称为抖动，或颠簸。</li>
<li>产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够)<ul>
<li>为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率</li>
</ul>
</li>
</ul>
<h4 id="48、从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）"><a href="#48、从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）" class="headerlink" title="48、从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）"></a>48、从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）</h4><ul>
<li>分配和释放，堆在分配和释放时都要调用函数（malloc,free)，比如分配时会到堆空间去寻找足够大小的空间（因为多次分配释放后会造成内存碎片），这些都会花费一定的时间，具体可以看看malloc和free的源代码，函数做了很多额外的工作，而栈却不需要这些。</li>
<li>访问时间，访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正的数据，而栈只需访问一次。另外，堆的内容被操作系统交换到外存的概率比栈大，栈一般是不会被交换出去的。</li>
</ul>
<h4 id="49、常见内存分配方式有哪些？"><a href="#49、常见内存分配方式有哪些？" class="headerlink" title="49、常见内存分配方式有哪些？"></a>49、常见内存分配方式有哪些？</h4><ul>
<li>静态存储区分配，在main之间编译期间分配，如全局变量、static静态变量</li>
<li>栈上创建，执行函数时，函数的局部变量都分配在栈上，执行结束自动被释放，效率很高，但是分配的内存容量有限。</li>
<li>从堆上分配，也叫动态内存分配，使用new和malloc就是在该区域分配，需要程序员自己管理，否则会产生内存泄露问题，比较灵活，但也容易出错</li>
</ul>
<h4 id="50、常见内存分配内存错误"><a href="#50、常见内存分配内存错误" class="headerlink" title="50、常见内存分配内存错误"></a>50、常见内存分配内存错误</h4><ul>
<li><p>内存未分配就使用、内存虽然分配但没有初始化、分配了但是越界、忘记释放内存、释放了却继续使用</p>
</li>
<li><p>函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁；</p>
</li>
<li><p>使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”</p>
</li>
</ul>
<h4 id="51、内存交换中，被换出的进程保存在哪里？"><a href="#51、内存交换中，被换出的进程保存在哪里？" class="headerlink" title="51、内存交换中，被换出的进程保存在哪里？"></a>51、内存交换中，被换出的进程保存在哪里？</h4><ul>
<li>磁盘空间分为文件区和对换区两部分，对换区就用于换出的进程数据存储，对换区采用连续分配方式，I&#x2F;O速度比文件区的更快。</li>
</ul>
<h4 id="52、在发生内存交换时，有些进程是被优先考虑的？你可以说一说吗？"><a href="#52、在发生内存交换时，有些进程是被优先考虑的？你可以说一说吗？" class="headerlink" title="52、在发生内存交换时，有些进程是被优先考虑的？你可以说一说吗？"></a>52、在发生内存交换时，有些进程是被优先考虑的？你可以说一说吗？</h4><ul>
<li><p>可优先换出阻塞进程;</p>
</li>
<li><p>可换出优先级低的进程;</p>
</li>
<li><p>为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间（PCB 会常驻内存，不会被换出外存）</p>
</li>
</ul>
<h4 id="53、ASCII、Unicode和UTF-8编码的区别？"><a href="#53、ASCII、Unicode和UTF-8编码的区别？" class="headerlink" title="53、ASCII、Unicode和UTF-8编码的区别？"></a>53、ASCII、Unicode和UTF-8编码的区别？</h4><ul>
<li><p>ASCII 只有127个字符，比较少；</p>
</li>
<li><p>Unicode就是将这些语言统一到一套编码格式中，占用空间较大；</p>
</li>
<li><p>UTF-8编码将Unicode字符按数字大小编码为1-6个字节，变为“<strong>可变长编码</strong>”</p>
</li>
</ul>
<h4 id="54、原子操作的是如何实现的"><a href="#54、原子操作的是如何实现的" class="headerlink" title="54、原子操作的是如何实现的"></a>54、原子操作的是如何实现的</h4><ul>
<li>处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作</li>
<li>总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存</li>
</ul>
<h4 id="55、内存交换你知道有哪些需要注意的关键点吗？"><a href="#55、内存交换你知道有哪些需要注意的关键点吗？" class="headerlink" title="55、内存交换你知道有哪些需要注意的关键点吗？"></a>55、内存交换你知道有哪些需要注意的关键点吗？</h4><ul>
<li>交换需要备份存储，通常是快速磁盘，它必须足够大，并且提供对这些内存映像的直接访问。</li>
<li>交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用就可能很快</li>
<li>交换通常在有许多进程运行且内存空间吃紧时开始启动，而系统负荷降低就暂停</li>
</ul>
<h4 id="56、系统并发和并行，分得清吗？"><a href="#56、系统并发和并行，分得清吗？" class="headerlink" title="56、系统并发和并行，分得清吗？"></a>56、系统并发和并行，分得清吗？</h4><ul>
<li>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</li>
<li>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</li>
<li>操作系统通过引入进程和线程，使得程序能够并发运行</li>
</ul>
<h4 id="57、页面置换算法总结"><a href="#57、页面置换算法总结" class="headerlink" title="57、页面置换算法总结"></a>57、页面置换算法总结</h4><ul>
<li>最佳置换法(OPT)，每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，无法实现，通常用来评定算法优劣</li>
<li>先进先出置换算法(FIFO) :每次选择淘汰的页面是最早进入内存的页面，性能较差，因为较早调入的页往往是经常被访问的页，这些页在FIFO算法下被反复调入和调出，并且有Belady现象（如果对—个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的异常现象）</li>
<li>最近最久未使用置换算法(LRU) :每次淘汰的页面是最近最久未使用的页面 ，性能较好，但需要寄存器和栈的硬件支持，一般不使用</li>
<li>时钟置换算法(CLOCK)，或最近未用算法(NRU，Not Recently Used)，为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列</li>
<li>改进型的时钟置换算法，增加了一个修改位，用(访问位，修改位)的形式表示各页面状态</li>
</ul>
<h4 id="58、共享是什么？"><a href="#58、共享是什么？" class="headerlink" title="58、共享是什么？"></a>58、共享是什么？</h4><ul>
<li><p>共享是指系统中的资源可以被多个并发进程共同使用。</p>
</li>
<li><p>有两种共享方式：互斥共享和同时共享。</p>
<ul>
<li>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问</li>
</ul>
</li>
</ul>
<h4 id="59、死锁问题总结"><a href="#59、死锁问题总结" class="headerlink" title="59、死锁问题总结"></a>59、死锁问题总结</h4><ul>
<li>死锁是指两个（多个）线程相互等待对方数据的过程，死锁的产生会导致程序卡死，不解锁程序将永远无法进行下去</li>
<li>死锁产生四个条件：互斥条件、不剥夺条件、请求和保持条件、循环等待条件</li>
<li>死锁的解决方案： 保证上锁的顺序一致</li>
<li>死锁预防：破坏四个条件</li>
</ul>
<h4 id="60、为什么分段式存储管理有外部碎片而无内部碎片？为什么固定分区分配有内部碎片而不会有外部碎片？"><a href="#60、为什么分段式存储管理有外部碎片而无内部碎片？为什么固定分区分配有内部碎片而不会有外部碎片？" class="headerlink" title="60、为什么分段式存储管理有外部碎片而无内部碎片？为什么固定分区分配有内部碎片而不会有外部碎片？"></a>60、为什么分段式存储管理有外部碎片而无内部碎片？为什么固定分区分配有内部碎片而不会有外部碎片？</h4><ul>
<li>分段式分配是按需分配，而固定式分配是固定分配的方式。</li>
</ul>
<h4 id="61、内部碎片与外部碎片"><a href="#61、内部碎片与外部碎片" class="headerlink" title="61、内部碎片与外部碎片"></a>61、内部碎片与外部碎片</h4><ul>
<li>内碎片：分配给某些进程的内存区域中有些部分没用上，常见于固定分配方式；<ul>
<li>分段式分配，按需分配，一个程序需要45M，就给分片45MB，剩下的55M供其它程序使用，不存在内部碎片</li>
</ul>
</li>
<li>外碎片：内存中某些空闲区因为比较小，而难以利用上，一般出现在内存动态分配方式中</li>
</ul>
<h4 id="62、如何消除碎片文件"><a href="#62、如何消除碎片文件" class="headerlink" title="62、如何消除碎片文件"></a>62、如何消除碎片文件</h4><ul>
<li>对于外部碎片，通过<strong>紧凑技术</strong>消除，就是操作系统不时地对进程进行移动和整理。但是这需要动态重定位寄存器地支持，且相对费时</li>
<li>解决外部内存碎片的问题就是<strong>内存交换</strong>。就是通过将进程先写到磁盘上然后再写回时紧跟已经被占用的内存后面，回收内存时要尽可能地将相邻的空闲空间合并</li>
</ul>
<h4 id="63、冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？"><a href="#63、冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？" class="headerlink" title="63、冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？"></a>63、冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？</h4><ul>
<li>存储器：内存；</li>
<li>控制器：南桥北桥；</li>
<li>运算器：CPU；</li>
<li>输入设备：键盘；</li>
<li>输出设备：显示器、网卡</li>
</ul>
<h4 id="64、多进程和多线程的区别是什么？换句话说，什么时候该用多线程，什么时候该用多进程？"><a href="#64、多进程和多线程的区别是什么？换句话说，什么时候该用多线程，什么时候该用多进程？" class="headerlink" title="64、多进程和多线程的区别是什么？换句话说，什么时候该用多线程，什么时候该用多进程？"></a>64、多进程和多线程的区别是什么？换句话说，什么时候该用多线程，什么时候该用多进程？</h4><ul>
<li>频繁修改：需要频繁创建和销毁的优先使用<strong>多线程</strong></li>
<li>计算量：需要大量计算的优先使用<strong>多线程</strong> 因为需要消耗大量CPU资源且切换频繁，所以多线程好一点</li>
<li>相关性：任务间相关性比较强的用<strong>多线程</strong>，相关性比较弱的用多进程。因为线程之间的数据共享和同步比较简单。</li>
<li>多分布：可能要扩展到多机分布的用<strong>多进程</strong>，多核分布的用<strong>多线程</strong>。</li>
</ul>
<p>但是实际中更常见的是进程加线程的结合方式，并不是非此即彼的</p>
<h4 id="65、服务器高并发的解决方案你知道多少？"><a href="#65、服务器高并发的解决方案你知道多少？" class="headerlink" title="65、服务器高并发的解决方案你知道多少？"></a>65、服务器高并发的解决方案你知道多少？</h4><ul>
<li>应用数据与静态资源分离：将静态资源（图片，视频，js，css等）单独保存到专门的静态资源服务器中，在客户端访问的时候从静态资源服务器中返回静态资源，从主服务器中返回应用数据。</li>
<li>客户端缓存：因为效率最高，消耗资源最小的就是纯静态的html页面，所以可以把网站上的页面尽可能用静态的来实现，在页面过期或者有数据更新之后再将页面重新缓存。或者先生成静态页面，然后用ajax异步请求获取动态数据。</li>
<li>集群和分布式 ：集群是所有的服务器都有相同的功能，请求哪台都可以，主要起分流作用；分布式是将不同的业务放到不同的服务器中，处理一个请求可能需要使用到多台服务器，起到加快请求处理的速度。可以使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器上。同时加快请求处理的速度。</li>
<li>反向代理：在访问服务器的时候，服务器通过别的服务器获取资源或结果返回给客户端</li>
</ul>
<h2 id="阿秀学习笔记计网面经整理："><a href="#阿秀学习笔记计网面经整理：" class="headerlink" title="阿秀学习笔记计网面经整理："></a>阿秀学习笔记计网面经整理：</h2><h4 id="1、OSI-的七层模型分别是？各自的功能是什么？"><a href="#1、OSI-的七层模型分别是？各自的功能是什么？" class="headerlink" title="1、OSI 的七层模型分别是？各自的功能是什么？"></a>1、OSI 的七层模型分别是？各自的功能是什么？</h4><ul>
<li>物理层：底层数据传输，如网线；网卡标准。</li>
<li>数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。</li>
<li>网络层：定义IP编址，定义路由功能；如不同设备的数据转发。</li>
<li>传输层：端到端传输数据的基本功能；如 TCP、UDP。</li>
<li>会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。</li>
<li>表示层：数据格式标识，基本压缩加密功能。</li>
<li>应用层：各种应用软件，包括 Web 应用。</li>
</ul>
<h4 id="2、说一下一次完整的HTTP请求过程包括哪些内容？"><a href="#2、说一下一次完整的HTTP请求过程包括哪些内容？" class="headerlink" title="2、说一下一次完整的HTTP请求过程包括哪些内容？"></a>2、说一下一次完整的HTTP请求过程包括哪些内容？</h4><p>域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户</p>
<h4 id="3、你知道DNS是什么？"><a href="#3、你知道DNS是什么？" class="headerlink" title="3、你知道DNS是什么？"></a>3、你知道DNS是什么？</h4><ul>
<li>DNS（Domain Name System，域名系统），因特网上作为<strong>域名和IP地址相互映射</strong>的一个<strong>分布式数据库</strong>，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</li>
<li>通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。<strong>通俗的讲</strong>，我们更习惯于记住一个网站的名字，比如<a href="http://www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2">www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2</a></li>
</ul>
<h4 id="4、DNS的工作原理？"><a href="#4、DNS的工作原理？" class="headerlink" title="4、DNS的工作原理？"></a>4、DNS的工作原理？</h4><ul>
<li>将主机域名转换为ip地址，属于应用层协议，使用UDP传输。</li>
<li>浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。 <ul>
<li>主机向本地域名服务器的查询一般都是采用递归查询。 </li>
<li>本地域名服务器向根域名服务器的查询的迭代查询。</li>
</ul>
</li>
</ul>
<h4 id="5、为什么域名解析用UDP协议？"><a href="#5、为什么域名解析用UDP协议？" class="headerlink" title="5、为什么域名解析用UDP协议？"></a>5、为什么域名解析用UDP协议？</h4><ul>
<li>UDP的DNS协议只要一个请求、一个应答就好了。</li>
<li>而使用基于TCP的DNS协议要三次握手、发送数据以及应答、四次挥手，但是UDP协议传输内容不能超过512字节。</li>
<li>不过客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。</li>
</ul>
<h4 id="6、为什么区域传送用TCP协议？"><a href="#6、为什么区域传送用TCP协议？" class="headerlink" title="6、为什么区域传送用TCP协议？"></a>6、为什么区域传送用TCP协议？</h4><ul>
<li>因为TCP协议可靠性好，需要从主DNS上复制内容</li>
<li>因为TCP协议传输的内容大，用最大只能传512字节的UDP协议无法满足</li>
</ul>
<h4 id="7、HTTP长连接和短连接的区别"><a href="#7、HTTP长连接和短连接的区别" class="headerlink" title="7、HTTP长连接和短连接的区别"></a>7、HTTP长连接和短连接的区别</h4><ul>
<li>在HTTP&#x2F;1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。</li>
<li>而从HTTP&#x2F;1.1起，默认使用长连接，用以保持连接特性</li>
</ul>
<h4 id="8、什么是TCP粘包-x2F-拆包？发生的原因？"><a href="#8、什么是TCP粘包-x2F-拆包？发生的原因？" class="headerlink" title="8、什么是TCP粘包&#x2F;拆包？发生的原因？"></a>8、什么是TCP粘包&#x2F;拆包？发生的原因？</h4><ul>
<li>一个完整的业务可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这个就是TCP的拆包和粘包问题。</li>
<li><strong>原因</strong><ul>
<li>应用程序写入数据的字节大小大于套接字发送缓冲区的大小.</li>
<li>进行MSS大小的TCP分段。</li>
<li>以太网的payload大于MTU进行IP分片。</li>
</ul>
</li>
<li><strong>解决方案</strong>:<ul>
<li>消息定长</li>
<li>在包尾部增加回车或者空格符等特殊字符进行分割</li>
<li>将消息分为消息头和消息尾</li>
<li>使用其它复杂的协议，如RTMP协议等</li>
</ul>
</li>
</ul>
<h4 id="9、为什么服务器会缓存这一项功能-如何实现的？"><a href="#9、为什么服务器会缓存这一项功能-如何实现的？" class="headerlink" title="9、为什么服务器会缓存这一项功能?如何实现的？"></a>9、为什么服务器会缓存这一项功能?如何实现的？</h4><p><strong>原因</strong></p>
<ul>
<li>缓解服务器压力；</li>
<li>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</li>
</ul>
<p><strong>实现方法</strong></p>
<ul>
<li>让代理服务器进行缓存；</li>
<li>让客户端浏览器进行缓存。</li>
</ul>
<h4 id="10、HTTP请求方法你知道多少？"><a href="#10、HTTP请求方法你知道多少？" class="headerlink" title="10、HTTP请求方法你知道多少？"></a>10、HTTP请求方法你知道多少？</h4><ul>
<li><p>客户端发送的 <strong>请求报文</strong> 第一行为请求行，包含了方法字段。</p>
</li>
<li><p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。</p>
</li>
<li><p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。</p>
</li>
<li><p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p>
</li>
</ul>
<h4 id="11、GET-和-POST-的区别，你知道哪些？"><a href="#11、GET-和-POST-的区别，你知道哪些？" class="headerlink" title="11、GET 和 POST 的区别，你知道哪些？"></a>11、GET 和 POST 的区别，你知道哪些？</h4><ul>
<li>从语义上来说get是获取数据，post是修改数据</li>
<li>get把请求的数据放在url上， 以?分割URL和传输数据，参数之间以&amp;相连，所以get不太安全。而post把数据放在HTTP的包体内（requrest body）</li>
<li>get提交的数据最大是2k（ 限制实际上取决于浏览器）， post理论上没有限制。</li>
<li>GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。</li>
<li>GET请求会被浏览器主动缓存，而POST不会，除非手动设置。</li>
<li>本质区别：GET是幂等的，而POST不是幂等的；幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。<ul>
<li>不应该且<strong>不能用get请求做数据的增删改这些有副作用的操作</strong>。因为get请求是幂等的，<strong>在网络不好的隧道中会尝试重试</strong>。如果用get请求增数据，会有<strong>重复操作</strong>的风险，而这种重复操作可能会导致副作用</li>
</ul>
</li>
</ul>
<h4 id="12、一个TCP连接可以对应几个HTTP请求？"><a href="#12、一个TCP连接可以对应几个HTTP请求？" class="headerlink" title="12、一个TCP连接可以对应几个HTTP请求？"></a>12、一个TCP连接可以对应几个HTTP请求？</h4><ul>
<li>如果维持连接，一个 TCP 连接是可以发送多个 HTTP 请求的。</li>
</ul>
<h4 id="13、一个-TCP-连接中-HTTP-请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？"><a href="#13、一个-TCP-连接中-HTTP-请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？" class="headerlink" title="13、一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？"></a>13、一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？</h4><ul>
<li>HTTP&#x2F;1.1 存在一个问题，单个 TCP 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。浏览器是如何提高页面加载效率的呢？主要有下面两点：<ul>
<li>维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。</li>
<li>和服务器建立多个 TCP 连接。</li>
</ul>
</li>
<li>在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。</li>
</ul>
<h4 id="14、浏览器对同一-Host-建立-TCP-连接到的数量有没有限制？"><a href="#14、浏览器对同一-Host-建立-TCP-连接到的数量有没有限制？" class="headerlink" title="14、浏览器对同一 Host 建立 TCP 连接到的数量有没有限制？"></a>14、浏览器对同一 Host 建立 TCP 连接到的数量有没有限制？</h4><ul>
<li><strong>有。Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。</strong></li>
<li>如果图片都是 HTTPS 连接并且在同一个域名下，那么浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2，如果能的话就使用 Multiplexing 功能在这个连接上进行多路传输。不过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。</li>
<li>如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP&#x2F;1.1）。那浏览器就会在一个 HOST 上建立多个 TCP 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等了</li>
</ul>
<h4 id="15、在浏览器中输入url地址后显示主页的过程"><a href="#15、在浏览器中输入url地址后显示主页的过程" class="headerlink" title="15、在浏览器中输入url地址后显示主页的过程?"></a>15、在浏览器中输入url地址后显示主页的过程?</h4><ul>
<li>根据域名，进行DNS域名解析；</li>
<li>拿到解析的IP地址，建立TCP连接；</li>
<li>向IP地址，发送HTTP请求；</li>
<li>服务器处理请求；</li>
<li>返回响应结果；</li>
<li>关闭TCP连接；</li>
<li>浏览器解析HTML；</li>
<li>浏览器布局渲染；</li>
</ul>
<h4 id="16、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？"><a href="#16、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？" class="headerlink" title="16、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？"></a>16、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？</h4><ul>
<li>查浏览器缓存，看看有没有已经缓存好的，如果没有检查本机host文件，调用API，Linux下Socket函数 gethostbyname</li>
<li>向DNS服务器发送DNS请求，查询本地DNS服务器，这其中用的是UDP的协议</li>
<li>如果在一个子网内采用ARP地址解析协议进行ARP查询如果不在一个子网那就需要对默认网关进行DNS查询，如果还找不到会一直向上找根DNS服务器，直到最终拿到IP地址</li>
<li>这个时候我们就有了服务器的IP地址 以及默认的端口号了，http默认是80 https是 443 端口号，会，首先尝试http然后调用Socket建立TCP连接，经过三次握手成功建立连接后，开始传送数据</li>
<li>如果正是http协议的话，就返回就完事了；如果不是http协议，服务器会返回一个5开头的的重定向消息，告诉我们用的是https，那就是说IP没变，但是端口号从80变成443了，再四次挥手，完事</li>
<li>采用SSL的加密技术来保证传输数据的安全性，保证数据传输过程中不被修改或者替换之类的，这次依然是三次握手，沟通好双方使用的认证算法，加密和检验算法，在此过程中也会检验对方的CA安全证书。</li>
<li>确认无误后，开始通信，然后服务器就会返回你所要访问的网址的一些数据，在此过程中会将界面进行渲染，牵涉到ajax技术之类的，直到最后我们看到色彩斑斓的网页</li>
</ul>
<h4 id="17、谈谈DNS解析过程，具体一点"><a href="#17、谈谈DNS解析过程，具体一点" class="headerlink" title="17、谈谈DNS解析过程，具体一点"></a>17、谈谈DNS解析过程，具体一点</h4><ul>
<li>请求一旦发起，若是chrome浏览器，先在浏览器找之前<strong>有没有缓存过的域名所对应的ip地址</strong>，有的话，直接跳过dns解析了，若是没有，就会<strong>找硬盘的hosts文件</strong>，看看有没有，有的话，直接找到hosts文件里面的ip</li>
<li>如果本地的hosts文件没有能得到对应的ip地址，浏览器会发出一个<strong>dns请求到本地dns服务器</strong>，<strong>本地dns服务器一般都是你的网络接入服务器商提供</strong>，比如中国电信，中国移动等。</li>
<li>查询你输入的网址的DNS请求到达本地DNS服务器之后，<strong>本地DNS服务器会首先查询它的缓存记录</strong>，如果缓存中有此条记录，就可以直接返回结果，此过程是<strong>递归的方式进行查询</strong>。如果没有，本地DNS服务器还要向<strong>DNS根服务器</strong>进行查询。</li>
<li>本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。</li>
<li>最后，本地DNS服务器向<strong>域名的解析服务器</strong>发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</li>
</ul>
<h4 id="18、DNS负载均衡是什么策略？"><a href="#18、DNS负载均衡是什么策略？" class="headerlink" title="18、DNS负载均衡是什么策略？"></a>18、DNS负载均衡是什么策略？</h4><ul>
<li>当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会崩掉。处理办法就是用DNS负载均衡技术，它的原理是在<strong>DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器</strong>,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。</li>
</ul>
<h4 id="19、HTTPS和HTTP的区别"><a href="#19、HTTPS和HTTP的区别" class="headerlink" title="19、HTTPS和HTTP的区别"></a>19、HTTPS和HTTP的区别</h4><ul>
<li>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全， HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</li>
<li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 </li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
</ul>
<h4 id="20、什么是SSL-x2F-TLS-？"><a href="#20、什么是SSL-x2F-TLS-？" class="headerlink" title="20、什么是SSL&#x2F;TLS ？"></a>20、什么是SSL&#x2F;TLS ？</h4><ul>
<li>SSL代表安全套接字层。它是一种用于加密和验证应用程序（如浏览器）和Web服务器之间发送的数据的协议。 身份验证 ， 加密Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。</li>
<li>SSL&#x2F;TLS协议作用：认证用户和服务，加密数据，维护数据的完整性的应用层协议加密和解密需要两个不同的密钥，故被称为非对称加密；</li>
<li>加密和解密都使用同一个密钥的对称加密：优点在于加密、解密效率通常比较高 ，HTTPS 是基于非对称加密的， 公钥是公开的</li>
</ul>
<h4 id="21、HTTPS是如何保证数据传输的安全，整体的流程是什么？（SSL是怎么工作保证安全的）"><a href="#21、HTTPS是如何保证数据传输的安全，整体的流程是什么？（SSL是怎么工作保证安全的）" class="headerlink" title="21、HTTPS是如何保证数据传输的安全，整体的流程是什么？（SSL是怎么工作保证安全的）"></a>21、HTTPS是如何保证数据传输的安全，整体的流程是什么？（SSL是怎么工作保证安全的）</h4><p>（1）客户端向服务器端发起SSL连接请求； </p>
<p>（2） 服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥 </p>
<p>（3）客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端 </p>
<p>（4）服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密， </p>
<p>（5）进行数据传输，服务器和客户端双方用公有的相同的对称秘钥对数据进行加密解密，可以保证在数据收发过程中的安全，即是第三方获得数据包，也无法对其进行加密，解密和篡改。</p>
<p>因为数字签名、摘要是证书防伪非常关键的武器。 “摘要”就是对传输的内容，通过hash算法计算出一段固定长度的串。然后，通过发送方的私钥对这段摘要进行加密，加密后得到的结果就是“数字签名”</p>
<p>SSL&#x2F;TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p>
<h4 id="22、如何保证公钥不被篡改？"><a href="#22、如何保证公钥不被篡改？" class="headerlink" title="22、如何保证公钥不被篡改？"></a>22、如何保证公钥不被篡改？</h4><ul>
<li>将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。 公钥加密计算量太大，如何减少耗用的时间？ 每一次对话（session），客户端和服务器端都生成一个”对话密钥” （session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。 <ul>
<li>客户端向服务器端索要并验证公钥。 </li>
<li>双方协商生成”对话密钥”。</li>
<li>双方采用”对话密钥”进行加密通信。上面过程的前两步，又称为”握手阶段”（handshake）。</li>
</ul>
</li>
</ul>
<h4 id="23、HTTP请求和响应报文有哪些主要字段？"><a href="#23、HTTP请求和响应报文有哪些主要字段？" class="headerlink" title="23、HTTP请求和响应报文有哪些主要字段？"></a>23、HTTP请求和响应报文有哪些主要字段？</h4><ul>
<li><p>请求报文：</p>
<ul>
<li><p>请求行：Request Line</p>
</li>
<li><p>请求头：Request Headers</p>
</li>
<li><p>请求体：Request Body</p>
</li>
</ul>
</li>
<li><p>响应报文：</p>
<ul>
<li><p>状态行：Status Line</p>
</li>
<li><p>响应头：Response Headers</p>
</li>
<li><p>响应体：Response Body</p>
</li>
</ul>
</li>
</ul>
<h4 id="24、Cookie是什么？"><a href="#24、Cookie是什么？" class="headerlink" title="24、Cookie是什么？"></a>24、Cookie是什么？</h4><ul>
<li>HTTP 协议是<strong>无状态</strong>的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务，HTTP&#x2F;1.1 引入 Cookie 来保存状态信息。</li>
<li>Cookie 是<strong>服务器发送到用户浏览器并保存在本地的一小块数据</strong>，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</li>
<li>cookie 的出现因为 HTTP 是无状态的一种协议，换句话说，服务器记不住你，可能你每刷新一次网页，就要重新输入一次账号密码进行登录。这显然是让人无法接受的，cookie 的作用就好比服务器给你贴个标签，然后你每次向服务器再发请求时，服务器就能够 cookie 认出你。</li>
<li>抽象地概括一下：一个 cookie 可以认为是一个「变量」，形如 name&#x3D;value，存储在浏览器；一个 session 可以理解为一种数据结构，多数情况是「映射」（键值对），存储在服务器上。</li>
</ul>
<h4 id="25、Cookie有什么用途？用途"><a href="#25、Cookie有什么用途？用途" class="headerlink" title="25、Cookie有什么用途？用途"></a>25、Cookie有什么用途？用途</h4><ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<h4 id="26、Session知识大总结"><a href="#26、Session知识大总结" class="headerlink" title="26、Session知识大总结"></a>26、Session知识大总结</h4><ul>
<li><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p>
</li>
<li><p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p>
</li>
<li><p>使用 Session 维护用户登录状态的过程如下：</p>
<ul>
<li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li>
<li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li>
<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li>
<li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li>
</ul>
</li>
<li><p>注意：Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式</p>
</li>
</ul>
<h4 id="27、Session-的工作原理是什么？"><a href="#27、Session-的工作原理是什么？" class="headerlink" title="27、Session 的工作原理是什么？"></a>27、Session 的工作原理是什么？</h4><ul>
<li>session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了。</li>
</ul>
<h4 id="28、Cookie与Session的对比"><a href="#28、Cookie与Session的对比" class="headerlink" title="28、Cookie与Session的对比"></a>28、Cookie与Session的对比</h4><p>HTTP作为无状态协议，必然需要在某种方式保持连接状态。这里简要介绍一下Cookie和Session。</p>
<ul>
<li><p><strong>Cookie</strong>：Cookie是客户端保持状态的方法。</p>
<ul>
<li><p>Cookie简单的理解就是存储由服务器发至客户端并由客户端保存的一段字符串。为了保持会话，服务器可以在响应客户端请求时将Cookie字符串放在Set-Cookie下，客户机收到Cookie之后保存这段字符串，之后再请求时候带上Cookie就可以被识别。</p>
</li>
<li><p>Cookie在客户端的保存形式可以有两种，一种是会话Cookie一种是持久Cookie，会话Cookie就是将服务器返回的Cookie字符串保持在内存中，关闭浏览器之后自动销毁，持久Cookie则是存储在客户端磁盘上，其有效时间在服务器响应头中被指定，在有效期内，客户端再次请求服务器时都可以直接从本地取出。需要说明的是，存储在磁盘中的Cookie是可以被多个浏览器代理所共享的。</p>
</li>
</ul>
</li>
<li><p><strong>Session</strong>：Session是服务器保持状态的方法。</p>
<ul>
<li>Session保存在服务器上，可以保存在数据库、文件或内存中，每个用户有独立的Session用户在客户端上记录用户的操作。可以理解为每个用户有一个独一无二的Session ID作为Session文件的Hash键，通过这个值可以锁定具体的Session结构的数据，这个Session结构中存储了用户操作行为。</li>
<li>当服务器需要识别客户端时就需要结合Cookie了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在Cookie里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。如果客户端的浏览器禁用了Cookie，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如sid&#x3D;xxxxx这样的参数，服务端据此来识别用户，这样就可以帮用户完成诸如用户名等信息自动填入的操作了</li>
</ul>
</li>
</ul>
<h4 id="29、SQL注入攻击了解吗？"><a href="#29、SQL注入攻击了解吗？" class="headerlink" title="29、SQL注入攻击了解吗？"></a>29、SQL注入攻击了解吗？</h4><ul>
<li>攻击者在HTTP请求中注入恶意的SQL代码，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。 用户登录，输入用户名 lianggzone，密码 ‘ or ‘1’&#x3D;’1 ，如果此时使用参数构造的方式，就会出现 select * from user where name &#x3D; ‘lianggzone’ and password &#x3D; ‘’ or ‘1’&#x3D;‘1’ 不管用户名和密码是什么内容，使查询出来的用户列表不为空。如何防范SQL注入攻击使用预编译的PrepareStatement是必须的，但是一般我们会从两个方面同时入手。 </li>
<li>Web端 <ul>
<li>有效性检验。</li>
<li>限制字符串输入的长度。</li>
</ul>
</li>
<li>服务端 <ul>
<li>不用拼接SQL字符串</li>
<li>使用预编译的PrepareStatement。</li>
<li>有效性检验。(外部都是不可信的，防止攻击者绕过Web端请求) </li>
<li>过滤SQL需要的参数中的特殊字符。比如单引号、双引号</li>
</ul>
</li>
</ul>
<h4 id="31、什么是RARP？工作原理"><a href="#31、什么是RARP？工作原理" class="headerlink" title="31、什么是RARP？工作原理"></a>31、什么是RARP？工作原理</h4><ul>
<li>反向地址转换协议，网络层协议，RARP与ARP工作方式相反。 RARP使只知道自己硬件地址的主机能够知道其IP地址。RARP发出要反向解释的物理地址并希望返回其IP地址，应答包括能够提供所需信息的RARP服务器发出的IP地址。 <ul>
<li>网络上的每台设备都会有一个独一无二的硬件地址，通常是由设备厂商分配的MAC地址。主机从网卡上读取MAC地址，然后在网络上发送一个RARP请求的广播数据包，请求RARP服务器回复该主机的IP地址。</li>
<li>RARP服务器收到了RARP请求数据包，为其分配IP地址，并将RARP回应发送给主机。</li>
<li>PC收到RARP回应后，就使用得到的IP地址进行通讯。</li>
</ul>
</li>
</ul>
<h4 id="32、端口有效范围是多少到多少？"><a href="#32、端口有效范围是多少到多少？" class="headerlink" title="32、端口有效范围是多少到多少？"></a>32、端口有效范围是多少到多少？</h4><ul>
<li>0-1023为知名端口号，比如其中HTTP是80，FTP是20（数据端口）、21（控制端口）</li>
<li>UDP和TCP报头使用两个字节存放端口号，所以端口号的有效范围是从0到65535。动态端口的范围是从1024到65535</li>
</ul>
<h4 id="33、为何需要把-TCP-x2F-IP-协议栈分成-5-层（或7层）？"><a href="#33、为何需要把-TCP-x2F-IP-协议栈分成-5-层（或7层）？" class="headerlink" title="33、为何需要把 TCP&#x2F;IP 协议栈分成 5 层（或7层）？"></a>33、为何需要把 TCP&#x2F;IP 协议栈分成 5 层（或7层）？</h4><p>①隔层之间是独立的</p>
<p>②灵活性好</p>
<p>③结构上可以分隔开</p>
<p>④易于实现和维护</p>
<p>⑤能促进标准化工作。</p>
<ul>
<li><p>45、MTU和MSS分别是什么？</p>
<ul>
<li><p>MTU是最大传输单元，由硬件规定，以太网的MYU为1500字节</p>
</li>
<li><p>MSS是TCP数据包每次传输时的最大数据分段大小，MSS &#x3D; MTU - IP header - TCP header</p>
</li>
</ul>
</li>
<li><p>46、HTTP中有个缓存机制，但如何保证缓存是最新的呢</p>
<ul>
<li>由请求报文中的Cache-Control中的max-age指令确定，若小于则有效，大于则过期</li>
<li>Expires首部字段也可用于告知该资源什么时候过期</li>
</ul>
</li>
<li><p>47、TCP头部中有哪些信息？</p>
<ul>
<li>序列号syn：字节流的编号，初始会被设定为一个初始值ISN，后续则为ISN + 数据在字节流中的偏移值，用于标识TCP网络包，解决乱序问题</li>
<li>确认号ack：接收方对于发送方syn的响应，ack &#x3D; syn + 1，用于告知该数据包已收到</li>
<li>首部长：标识首部有多少个4字节 * 首部长</li>
<li>标志位：主要ACK（确认报文段），SYN（连接报文段），RST（复位报文段），FIN（断开报文段）</li>
<li>窗口大小：用于告知发送方接收窗口的大小（还能接受多少数据），用于流量控制</li>
<li>校验和：检验整个报文段有无损坏</li>
</ul>
</li>
<li><p>48、常见TCP的连接状态有哪些？</p>
<ul>
<li>CLOSE：初始状态；</li>
<li>LISTEN：监听状态；</li>
<li>SYN_SEND：客户端发送完SYN包；</li>
<li>SYN_RECV：服务端收到SYN包并发送服务端SYN包；</li>
<li>ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。</li>
<li>FIN_WAIT_1：终止连接一方（挥手方）发送了FIN报文</li>
<li>CLOSE_WAIT：（被挥手方）接收到FIN后返回ACK报文，等待剩余数据传输</li>
<li>FIN_WAIT_2: 挥手方收到四次挥手中另一方的ACK报文，处于半连接状态，等待另一方的FIN报文</li>
<li>LAST_ACK：被挥手方已经发送完数据，发送出FIN报文，等待最后的ACK</li>
<li>TIME_WAIT: 挥手方收到了FIN报文，进入最后的确认等待状态，持续2_MSL时间</li>
</ul>
</li>
<li><p>49、网络的七层&#x2F;五层模型主要的协议有哪些？</p>
<ul>
<li>应用层（OSI则为应用层、表示层、会话层）：HTTP、DNS、FTP等</li>
<li>传输层：TCP、UDP</li>
<li>网络层：IP、ICMP、RIP等</li>
<li>数据链路层：ARP、RARP</li>
<li>物理层：PAM5等等。。。</li>
</ul>
</li>
<li><p>50、TCP是什么？</p>
<ul>
<li>TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议</li>
</ul>
</li>
<li><p>51、TCP头部报文字段介绍几个？各自的功能？</p>
<ul>
<li>见47，额外添加source port 和 destination port；两者分别为「源端口号」和「目的端口号」。源端口号就是指本地端口，目的端口就是远程端口（ip + 端口组成套接字socket，一对套接字组成一个连接）</li>
</ul>
</li>
<li><p>52、OSI 的七层模型的主要功能？</p>
<ul>
<li><strong>物理层：</strong>利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</li>
<li><strong>数据链路层：</strong>接收来自物理层的位流形式的数据，并封装成帧，传送到上一层 </li>
<li><strong>网络层：</strong>将网络地址翻译成对应的物理地址，并通过路由选择算法为分组通过通信子网选择最适当的路径。 </li>
<li><strong>传输层：</strong>在源端与目的端之间提供可靠的透明数据传输 </li>
<li><strong>会话层：</strong>负责在网络中的两节点之间建立、维持和终止通信 </li>
<li><strong>表示层：</strong>处理用户信息的表示问题，数据的编码，压缩和解压缩，数据的加密和解密 </li>
<li><strong>应用层：</strong>为用户的应用进程提供网络通信服务</li>
</ul>
</li>
<li><p>53、应用层常见协议知道多少？了解几个？</p>
</li>
<li><p>HTTP（ 超文本传输协议  端口80  基于TCP）、HTTPS （超文本传输安全协议  端口443  基于TCP）、Telnet （远程登录服务的标准协议  23  TCP）、FTP（ 文件传输协议  20传输和21连接  TCP）、DNS  （域名解析服务  53  服务器间进行域传输的时候用TCP 客户端查询DNS服务器时用 UDP）</p>
</li>
<li><p>54、浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？</p>
<ul>
<li>这取决于是否支持Connection: keep-alive 的 Header ；HTTP&#x2F;1.1 就把 Connection 头写进标准，并且默认开启持久连接；这样的好处是连接可以被重新使用，之后发送 HTTP 请求的时候不需要重新建立 TCP 连接，以及如果维持连接，那么 SSL 的开销也可以避免。</li>
<li>默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接</li>
</ul>
</li>
<li><p>55、三次握手相关内容</p>
<ul>
<li>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换<code>TCP窗口大小</code>信息。</li>
<li>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态；随后客户端需要发起连接，其发送一个SYN报文， 在TCP 首部的「序号」字段中填入一个随机初始化序号，同时把 <code>SYN</code> 标志位置为 <code>1</code>，之后客户端处于SYN_SENT的状态；然后服务端收到客户端的SYN报文后，生成一个SYN + ACK报文，其也产生自己的一个随机化序号填入首部「序号」字段中，TCP 首部的「确认应答号」字段填入 收到的syn + 1，并且将SYN和ACK标志位置为1，随后处于SYN_RCVD状态；客户端若收到服务端的SYN+ACK报文，那么会产生一个ACK报文，其可以包含数据了，将报文的ACK标志位置为1即可，且ack num &#x3D; 收到的syn + 1,之后客户端处于 <code>ESTABLISHED</code> 状态。</li>
</ul>
</li>
<li><p>56、为什么需要三次握手，两次不行吗？</p>
<ul>
<li>需要三次握手才能确认双方的接收与发送能力是否正常。第一次握手证明客户端的发送能力、服务端的接收能力是正常的；第二次握手证明服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。第三次握手服务端才能得出结论：客户端的接收、发送能力正常</li>
<li>如果是用两次握手则可能出现某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源</li>
</ul>
</li>
<li><p>57、什么是半连接队列？</p>
<ul>
<li>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个<strong>队列</strong>里，我们把这种队列称之为<strong>半连接队列</strong>。</li>
<li>如果SYN-ACK重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。 注意，每次重传等待的时间不一定相同，一般会是指数增长</li>
</ul>
</li>
<li><p>58、 ISN(Initial Sequence Number)是固定的吗？</p>
<ul>
<li>ISN随时间而变化，因此每个连接都将具有不同的ISN，ISN是一个有可以看作是一个32比特的计数器，但并不是简单的计数器，大概每4ms加1 。ISN &#x3D; M + F(localhost, localport, remotehost, remoteport)(M为计数器)，ISN应该由这个公式确定，F为哈希算法，不是一个简单计数器</li>
<li>这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的</li>
</ul>
</li>
<li><p>59、 三次握手过程中可以携带数据吗？</p>
</li>
<li><p><strong>第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病</strong></p>
</li>
<li><p>60、SYN攻击是什么？</p>
<ul>
<li><strong>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的</strong>，所以服务器容易受到SYN洪泛攻击。</li>
<li>SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用半连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS&#x2F;DDoS 攻击。</li>
<li>常见的防御 SYN 攻击的方法有如下几种：缩短超时（SYN Timeout）时间；增加最大半连接数；过滤网关防护；SYN cookies技术</li>
</ul>
</li>
<li><p>61、 四次挥手相关内容</p>
<ul>
<li><p>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p>
<ul>
<li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 <code>FIN_WAIT1</code> 状态。 即发出<strong>连接释放报文段</strong>（FIN&#x3D;1，序号seq&#x3D;u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</li>
<li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT</code> 状态。 即服务端收到连接释放报文段后即发出<strong>确认报文段</strong>（ACK&#x3D;1，确认号ack&#x3D;u+1，序号seq&#x3D;v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</li>
<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态。 即服务端没有要向客户端发出的数据，服务端发出<strong>连接释放报文段</strong>（FIN&#x3D;1，ACK&#x3D;1，序号seq&#x3D;w，确认号ack&#x3D;u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</li>
<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的确认号值，此时客户端处于 <code>TIME_WAIT</code> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 <code>CLOSED</code> 状态。 即客户端收到服务端的连接释放报文段后，对此发出<strong>确认报文段</strong>（ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</li>
</ul>
<p>收到一个FIN只意味着在这一方向上没有数据流动。<strong>客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。</strong>在socket编程中，任何一方执行close()&#x2F;shutdown()操作即可产生挥手操作。</p>
</li>
</ul>
</li>
<li><p>62、挥手为什么需要四次？</p>
<ul>
<li>当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中<strong>ACK报文是用来应答的，SYN报文是用来同步的</strong>。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文。当另一方也没有数据再发送的时候，则发出连接释放通知FIN，对方确认后就完全关闭了TCP连接</li>
</ul>
</li>
<li><p>63、2MSL等待状态？</p>
<ul>
<li>TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。</li>
<li>当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。</li>
<li>这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。</li>
</ul>
</li>
<li><p>64、四次挥手释放连接时，等待2MSL的意义?</p>
<ul>
<li>保证客户端发送的最后一个ACK报文段能够到达服务端，防止最后一个ACK丢包导致服务器无法正确关闭</li>
<li>防止“已失效的连接请求报文段”出现在本连接中。 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</li>
</ul>
</li>
<li><p>65、为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？</p>
<ul>
<li>同上</li>
</ul>
</li>
<li><p>66、TCP粘包问题是什么？你会如何去解决它？</p>
<ul>
<li><strong>TCP粘包</strong>是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。TCP默认会使用Nagle算法，此算法会导致粘包问题（只有上一个分组得到确认，才会发送下一个分组；收集多个小分组，在一个确认到来时一起发送）；TCP<strong>连接复用</strong>、<strong>数据包过大</strong>、流量控制，<strong>拥塞控制</strong>、<strong>接收方不及时接收缓冲区的包，造成多个包接收</strong>也都可能导致粘包问题</li>
<li>解决方法:<ul>
<li>尾部标记序列。通过特殊标识符表示数据包的边界，例如\n\r，\t，或者一些隐藏字符。</li>
<li>头部标记分步接收。在TCP报文的头部加上表示数据长度。</li>
<li>应用层发送数据时<strong>定长</strong>发送</li>
</ul>
</li>
</ul>
</li>
<li><p>67、OSI七层模型中表示层和会话层功能是什么？</p>
<ul>
<li>表示层：图像、视频编码解，数据加密。</li>
<li>会话层：建立会话，如session认证、断点续传。</li>
</ul>
</li>
<li><p>68、三次握手四次挥手的变迁图</p>
</li>
<li><p>69、对称密钥加密你了解吗？优缺点？</p>
<ul>
<li>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</li>
<li>优点：运算速度快；缺点：无法安全地将密钥传输给通信方</li>
</ul>
</li>
<li><p>70、非对称密钥加密你了解吗？优缺点？</p>
<ul>
<li><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。公开密钥所有人都可以获得，<strong>通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密</strong>，<strong>接收方收到通信内容后使用私有密钥解密</strong>。</p>
</li>
<li><p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p>
</li>
<li><p>优点：可以更安全地将公开密钥传输给通信发送方；缺点：运算速度慢。</p>
</li>
</ul>
</li>
<li><p>71、HTTPS是什么？</p>
<ul>
<li>HTTPS 并不是新协议，而是让 <strong>HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信</strong>。通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</li>
</ul>
</li>
<li><p>72、HTTP的缺点有哪些？</p>
<ul>
<li>使用明文进行通信，内容可能会被窃听；</li>
<li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li>
<li>无法证明报文的完整性，报文有可能遭篡改。</li>
</ul>
</li>
<li><p>73、HTTPS采用的加密方式有哪些？是对称还是非对称？</p>
<ul>
<li><p>HTTPS 采用混合的加密机制，使用<strong>非对称密钥加密用于传输对称密钥来保证传输过程的安全性</strong>，之后使用<strong>对称密钥加密进行通信来保证通信过程的效率</strong>。</p>
</li>
<li><p>确保传输安全过程（其实就是rsa原理）：</p>
<ol>
<li>Client给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。</li>
<li>Server确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。</li>
<li>Client确认数字证书有效，然后生成呀一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给Server。</li>
<li>Server使用自己的私钥，获取Client发来的随机数（Premaster secret）。</li>
<li>Client和Server根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程。</li>
</ol>
</li>
</ul>
</li>
<li><p>74、为什么有的时候刷新页面不需要重新建立 SSL 连接？</p>
<ul>
<li>TCP 连接有的时候会被浏览器和服务端维持一段时间，TCP 不需要重新建立，SSL 自然也会用之前的</li>
</ul>
</li>
<li><p>75、SSL中的认证中的证书是什么？了解过吗？</p>
<ul>
<li>通过使用 <strong>证书</strong> 来对通信方进行认证。数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</li>
<li>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</li>
<li>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</li>
</ul>
</li>
<li><p>76、HTTP如何禁用缓存？如何确认缓存？</p>
<ul>
<li>HTTP&#x2F;1.1 通过 Cache-Control 首部字段来控制缓存。</li>
<li><strong>禁止进行缓存</strong>：no-store 指令规定不能对请求或响应的任何一部分进行缓存。</li>
<li><strong>强制确认缓存</strong>：no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。</li>
</ul>
</li>
<li><p>77、GET与POST传递数据的最大长度能够达到多少呢？</p>
<ul>
<li>GET是通过URL提交数据，因此GET可提交的数据量就跟URL所能达到的最大长度有直接关系；URL不存在参数上限的问题，HTTP协议规范也没有对URL长度进行限制，主要的限制是特定的浏览器及服务器对它的限制，如果url太长，服务器可能会因为安全方面的设置从而拒绝请求或者发生不完整的数据请求</li>
<li>POST理论上讲是没有大小限制的，HTTP协议规范也没有进行大小限制，但实际上POST所能传递的数据量大小取决于服务器的设置和内存大小</li>
</ul>
</li>
<li><p>78、网络层常见协议？可以说一下吗？</p>
<ul>
<li>IP (网际协议) ：IP协议不但定义了数据传输时的基本单元和格式，还定义了数据报的递交方法和路由选择</li>
<li>ICMP (Internet控制报文协议):  ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性，是ping和traceroute的工作协议</li>
<li>IGMP (Internet组管理协议): 用于实现组播、广播等通信</li>
<li>RIP (路由信息协议): 使用“跳数”(即metric)来衡量到达目标地址的路由距离</li>
</ul>
</li>
<li><p>79、TCP四大拥塞控制算法总结</p>
<ul>
<li><p>慢热启动算法 – Slow Start：所谓慢启动，也就是TCP连接刚建立，一点一点地提速，试探一下网络的承受能力，以免直接扰乱了网络通道的秩序。</p>
<ol>
<li>连接建好的开始先初始化拥塞窗口cwnd大小为1，表明可以传一个MSS大小的数据。</li>
<li>每当收到一个ACK，cwnd大小加一，呈线性上升。</li>
<li>每当过了一个往返延迟时间RTT(Round-Trip Time)，cwnd大小直接翻倍，乘以2，呈指数上升。</li>
<li>还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;&#x3D; ssthresh时，就会进入“拥塞避免算法”</li>
</ol>
</li>
<li><p>拥塞避免算法 – Congestion Avoidance：当拥塞窗口大小cwnd大于等于慢启动阈值ssthresh后，就进入拥塞避免算法。算法如下：</p>
<ol>
<li>收到一个ACK，则cwnd &#x3D; cwnd + 1 &#x2F; cwnd</li>
<li>每当过了一个往返延迟时间RTT，cwnd大小加一。</li>
</ol>
<p>过了慢启动阈值后，拥塞避免算法可以避免窗口增长过快导致窗口拥塞，而是缓慢的增加调整到网络的最佳值。</p>
</li>
<li><p>拥塞发生状态时的算法：TCP拥塞控制默认认为网络丢包是由于网络拥塞导致的，所以一般的TCP拥塞控制算法以丢包为网络进入拥塞状态的信号。对于丢包有两种判定方式：</p>
<ul>
<li>超时重传RTO[Retransmission Timeout]：超时重传是TCP协议保证数据可靠性的一个重要机制，其原理是在发送一个数据以后就开启一个计时器，在一定时间内如果没有得到发送数据报的ACK报文，那么就重新发送数据，直到发送成功为止<ul>
<li>由于发生丢包，将慢启动阈值ssthresh设置为当前cwnd的一半，即ssthresh &#x3D; cwnd &#x2F; 2.</li>
<li>cwnd重置为1</li>
<li>进入慢启动过程</li>
</ul>
</li>
<li>收到三个重复确认ACK：如果发送端接收到3个以上的重复ACK，TCP就意识到数据发生丢失，需要重传。这个机制不需要等到重传定时器超时，所以叫做快速重传，而快速重传后没有使用慢启动算法，而是拥塞避免算法，所以这又叫做快速恢复算法<ul>
<li>cwnd大小缩小为当前的一半</li>
<li>ssthresh设置为缩小后的cwnd大小</li>
<li>然后进入快速恢复算法Fast Recovery。</li>
</ul>
</li>
</ul>
</li>
<li><p>快速恢复算法 – Fast Recovery：进入快速恢复之前，cwnd和ssthresh已经被更改为原有cwnd的一半。快速恢复算法的逻辑如下：</p>
<ul>
<li><p>cwnd &#x3D; cwnd + 3 *MSS，加3 MSS的原因是因为收到3个重复的ACK。</p>
</li>
<li><p>重传DACKs指定的数据包。</p>
</li>
<li><p>如果再收到DACKs，那么cwnd大小增加一。</p>
</li>
<li><p>如果收到新的ACK，表明重传的包成功了，那么退出快速恢复算法。将cwnd设置为ssthresh，然后进入拥塞避免算法。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>80、为何快速重传是选择3次ACK？</p>
<ul>
<li><p>主要的考虑还是要区分包的丢失是由于链路故障还是乱序等其他因素引发。两次duplicated ACK时很可能是乱序造成的，三次duplicated ACK时很可能是丢包造成的，四次duplicated ACK更更更可能是丢包造成的，但是这样的响应策略太慢。丢包肯定会造成三次duplicated ACK，综上是选择收到三个重复确认时窗口减半效果最好，这是实践经验。</p>
</li>
<li><p>在没有fast retransmit &#x2F; recovery 算法之前，重传依靠发送方的retransmit timeout，就是在timeout内如果没有接收到对方的ACK，默认包丢了，发送方就重传，包的丢失原因</p>
<p>1）包checksum 出错</p>
<p>2）网络拥塞</p>
<p>3）网络断，包括路由重收敛，</p>
</li>
<li><p>但是发送方无法判断是哪一种情况，于是采用最笨的办法，就是将自己的发送速率减半，即CWND 减为1&#x2F;2，这样的方法对2是有效的，可以缓解网络拥塞，3则无所谓，反正网络断了，无论发快发慢都会被丢；但对于1来说，丢包是因为偶尔的出错引起，一丢包就对半减速不合理。</p>
</li>
<li><p>于是有了fast retransmit 算法，基于在反向还可以接收到ACK，可以认为网络并没有断，否则也接收不到ACK，如果在timeout 时间内没有接收到&gt; 2 的duplicated ACK，则概率大事件为乱序，乱序无需重传，接收方会进行排序工作；而如果接收到三个或三个以上的duplicated ACK，则大概率是丢包，可以逻辑推理，发送方可以接收ACK，则网络是通的，可能是1、2造成的，先不降速，重传一次，如果接收到正确的ACK，则一切OK，流速依然（包出错被丢）。</p>
</li>
<li><p>而如果依然接收到duplicated ACK，则认为是网络拥塞造成的，此时降速则比较合理</p>
</li>
</ul>
</li>
<li><p>81、对于FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？你知道多少?</p>
<ul>
<li>FIN_WAIT_2：半关闭状态；发送断开请求一方还有接收数据能力，但已经没有发送数据能力。</li>
<li>CLOSE_WAIT状态：<ul>
<li>被动关闭连接一方接收到FIN包会立即回应ACK包表示已接收到断开请求。</li>
<li>被动关闭连接一方如果还有剩余数据要发送就会进入CLOSE_WAIT状态。</li>
</ul>
</li>
<li>TIME_WAIT状态：又叫2MSL等待状态。<ul>
<li>TIME_WAIT状态目的是防止最后一次握手数据没有到达对方而触发重传FIN准备的。在2MSL时间内，同一个socket不能再被使用，否则有可能会和旧连接数据混淆（如果新连接和旧连接的socket相同的话）。</li>
</ul>
</li>
</ul>
</li>
<li><p>82、你了解流量控制原理吗？</p>
<ul>
<li>目的是接收方通过TCP头窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。所以流量控制是点对点控制。</li>
<li>TCP是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗。发送窗用来限制发送方可以发送的数据大小，其中发送窗口的大小由接收端返回的TCP报文段中窗口字段来控制，接收方通过此字段告知发送方自己的缓冲（受系统、硬件等限制）大小。接收窗用来标记可以接收的数据大小。</li>
<li>TCP是流数据，发送出去的数据流可以被分为以下四部分：已发送且被确认部分 | 已发送未被确认部分 | 未发送但可发送部分 | 不可发送部分，其中发送窗 &#x3D; 已发送未确认部分 + 未发但可发送部分。接收到的数据流可分为：已接收 | 未接收但准备接收 | 未接收不准备接收。接收窗 &#x3D; 未接收但准备接收部分。</li>
<li>发送窗内数据只有当接收到接收端某段发送数据的ACK响应时才移动发送窗，左边缘紧贴刚被确认的数据。接收窗也只有接收到数据且最左侧连续时才移动接收窗口。</li>
</ul>
</li>
<li><p>83、建立TCP服务器的各个系统调用过程是怎样的？</p>
<ul>
<li><p>服务器：</p>
<ul>
<li><p>创建socket -&gt; int socket(int domain, int type, int protocol);</p>
<ul>
<li>domain：协议域，决定了socket的地址类型，IPv4为AF_INET。</li>
<li>type：指定socket类型，SOCK_STREAM为TCP连接。</li>
<li>protocol：指定协议。IPPROTO_TCP表示TCP协议，为0时自动选择type默认协议。</li>
</ul>
</li>
<li><p>绑定socket和端口号 -&gt; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p>
<ul>
<li>sockfd：socket返回的套接字描述符，类似于文件描述符fd。</li>
<li>addr：有个sockaddr类型数据的指针，指向的是被绑定结构变量。</li>
<li>addrlen：地址长度。</li>
</ul>
</li>
<li><p>监听端口号 -&gt; int listen(int sockfd, int backlog);</p>
<ul>
<li>sockfd：要监听的sock描述字。</li>
<li>backlog：socket可以排队的最大连接数。</li>
</ul>
</li>
<li><p>接收用户请求 -&gt; int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</p>
<ul>
<li>sockfd：服务器socket描述字。</li>
<li>addr：指向地址结构指针。</li>
<li>addrlen：协议地址长度。</li>
<li>注：一旦accept某个客户机请求成功将返回一个全新的描述符用于标识具体客户的TCP连接。</li>
</ul>
</li>
<li><p>从socket中读取字符 -&gt; ssize_t read(int fd, void *buf, size_t count);</p>
<ul>
<li>fd：连接描述字。</li>
<li>buf：缓冲区buf。</li>
<li>count：缓冲区长度。</li>
<li>注：大于0表示读取的字节数，返回0表示文件读取结束，小于0表示发生错误。</li>
</ul>
</li>
<li><p>关闭socket -&gt; int close(int fd);</p>
<ul>
<li>fd：accept返回的连接描述字，每个连接有一个，生命周期为连接周期。</li>
<li>注：sockfd是监听描述字，一个服务器只有一个，用于监听是否有连接；fd是连接描述字，用于每个连接的操作。</li>
</ul>
</li>
</ul>
</li>
<li><p>客户端：</p>
<ul>
<li>创建socket -&gt; int socket(int domain, int type, int protocol);</li>
<li>连接指定计算机 -&gt; int connect(int sockfd, struct sockaddr* addr, socklen_t addrlen);<ul>
<li>sockfd客户端的sock描述字。</li>
<li>addr：服务器的地址。</li>
<li>addrlen：socket地址长度。</li>
</ul>
</li>
<li>向socket写入信息 -&gt; ssize_t write(int fd, const void *buf, size_t count);<ul>
<li>fd、buf、count：同read中意义。</li>
<li>大于0表示写了部分或全部数据，小于0表示出错。</li>
</ul>
</li>
<li>关闭socket -&gt; int close(int fd);<ul>
<li>fd：同服务器端fd。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>84、TCP 协议如何保证可靠传输？</p>
<ul>
<li>建立连接（标志位）：通信前确认通信实体存在。</li>
<li>序号机制（序号、确认号）：确保了数据是按序、完整到达。</li>
<li>数据校验（校验和）：CRC校验全部数据。</li>
<li>超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。</li>
<li>窗口机制（窗口）：提供流量控制，避免过量发送。</li>
<li>拥塞控制：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失</li>
<li><strong>数据合理分片和排序</strong>：tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层</li>
</ul>
</li>
<li><p>85、UDP是什么？</p>
<ul>
<li>提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证可靠性</strong>）的用户数据报协议</li>
</ul>
</li>
<li><p>86、TCP和UDP的区别</p>
<ul>
<li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</li>
<li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</li>
<li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</li>
<li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的通信</li>
<li>TCP首部开销20字节;UDP的首部开销小，只有8个字节</li>
</ul>
</li>
<li><p>封包和拆包你听说过吗？它是基于TCP还是UDP的？</p>
<p>封包和拆包都是基于TCP的概念。因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。</p>
<ul>
<li>封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。</li>
<li>拆包：接收方在接收到报文后提取包头中的长度信息进行截取。</li>
</ul>
</li>
<li><p>87、UDP的特点有哪些？</p>
<ul>
<li>UDP是<strong>无连接的</strong>；</li>
<li>UDP使用<strong>尽最大努力交付</strong>，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；</li>
<li>UDP是<strong>面向报文</strong>的；</li>
<li>UDP<strong>没有拥塞控制</strong>，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）；</li>
<li>UDP<strong>支持一对一、一对多、多对一和多对多</strong>的交互通信；</li>
<li>UDP的<strong>首部开销小</strong>，只有8个字节，比TCP的20个字节的首部要短。</li>
</ul>
</li>
<li><p>88、TCP对应的应用层协议</p>
<ul>
<li>HTTP：超文本传输协议。使用80端口</li>
<li>FTP：定义了文件传输协议，使用21端口. </li>
<li>Telnet：它是一种用于远程登陆的端口,23端口 </li>
<li>SSH：Secure Shell，22端口</li>
</ul>
</li>
<li><p>89、UDP对应的应用层协议</p>
<ul>
<li>DNS：用于域名解析服务，用的是53号端口 </li>
<li>SNMP：简单网络管理协议，使用161号端口 </li>
<li>TFTP(Trival File Transfer Protocal)：简单文件传输协议，69</li>
</ul>
</li>
<li><p>90、数据链路层常见协议？可以说一下吗？</p>
<ul>
<li>ARP：地址解析协议，根据IP地址获取物理地址</li>
<li>RARP：反向地址转换协议，根据物理地址获取IP地址</li>
<li>PPP：点对点协议，主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案</li>
</ul>
</li>
<li><p>91、Ping命令基于哪一层协议的原理是什么？</p>
<ul>
<li>ping命令基于网络层的命令，是基于ICMP协议工作的。</li>
<li><code>ICMP</code> 主要的功能包括：<strong>确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</strong></li>
<li>Ping 这个程序是<strong>使用了 ICMP 里面的 ECHO REQUEST（类型为 8 ） 和 ECHO REPLY （类型为 0）</strong></li>
</ul>
</li>
<li><p>92、在进行UDP编程的时候，一次发送多少bytes好?</p>
<ul>
<li>1500字节被称为链路层的MTU(最大传输单元)，IP数据报的首部为20字节,所以IP数据报的数据区长度最大为1480字节，又因为UDP数据报的首部8字节,所以UDP数据报的数据区最大长度为1472字节；在普通的局域网环境下，建议将UDP的数据控制在1472字节以下为好</li>
<li>Internet上的标准MTU值为576字节，在进行Internet的UDP编程时. 最好将UDP的数据长度控件在548字节(576-8-20)以内</li>
</ul>
</li>
<li><p>93、TCP 利用滑动窗口实现流量控制的机制？</p>
<ul>
<li>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着<strong>接收方还有多大的缓冲区可以用于接收数据</strong>。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据。</li>
</ul>
</li>
<li><p>94、可以解释一下RTO，RTT和超时重传分别是什么吗？</p>
<ul>
<li>超时重传：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：<ul>
<li>发送的数据没能到达接收端，所以对方没有响应。</li>
<li>接收端接收到数据，但是ACK报文在返回过程中丢失。</li>
<li>接收端拒绝或丢弃数据。</li>
</ul>
</li>
<li>RTO：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。就是重传间隔。通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT……重传次数到达上限之后停止重传。</li>
<li>RTT：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定。</li>
</ul>
</li>
<li><p>95、XSS攻击是什么？</p>
<ul>
<li>跨站点脚本攻击，指攻击者通过篡改网页，嵌入恶意脚本程序，在用户浏览网页时，控制用户浏览器进行恶意操作的一种攻击方式</li>
<li>如何防范XSS攻击：需要字符串输入的长度限制；需要对HTML转义处理，将其中的”&lt;”,”&gt;”等特殊字符进行转义编码。核心是必须对输入的数据做过滤处理。</li>
</ul>
</li>
<li><p>96、CSRF攻击？你知道吗？</p>
<ul>
<li>跨站点请求伪造，指攻击者通过跨站请求，以合法的用户的身份进行非法操作</li>
<li>攻击者盗用你的身份，以你的名义向第三方网站发送恶意请求。CRSF能做的事情包括利用你的身份发邮件，发短信，进行交易转账，甚至盗取账号信息。</li>
</ul>
</li>
<li><p>97、如何防范CSRF攻击</p>
<ul>
<li>验证请求来源地址：HTTP Header中的字段Referer，记录了HTTP请求的来源地址</li>
<li>关键操作添加验证码：出于用户体验考虑，验证码只能作为一种辅助手段，而不是最主要的解决方案</li>
<li>在请求地址添加 token 并验证：HTTP请求中进行token验证，如果请求中没有token或者token内容不正确，则认为CSRF攻击而拒绝该请求</li>
</ul>
</li>
<li><p>98、文件上传漏洞是如何发生的？你有经历过吗？</p>
<ul>
<li>用户上传一个可执行的脚本文件，并通过此脚本文件获得了执行服务端命令的能力</li>
</ul>
</li>
<li><p>99、如何防范文件上传漏洞</p>
<ul>
<li>文件上传的目录设置为不可执行</li>
<li>判断文件类型</li>
<li>对上传的文件类型进行白名单校验，只允许上传可靠类型</li>
<li>上传的文件需要进行重新命名，使攻击者无法猜想上传文件的访问路径</li>
<li>限制上传文件的大小</li>
<li>独设置文件服务器的域名</li>
</ul>
</li>
<li><p>100、拥塞控制原理听说过吗？</p>
<ul>
<li>拥塞控制目的是防止数据过多注入到网络中导致网络资源（路由器、交换机等）过载。因为拥塞控制涉及网络链路全局，所以属于全局控制。控制拥塞使用拥塞窗口。</li>
<li>TCP拥塞控制算法：慢开始 &amp; 拥塞避免、快速重传 &amp; 快速恢复</li>
</ul>
</li>
<li><p>101、如何区分流量控制和拥塞控制？</p>
<ul>
<li>流量控制属于通信双方协商；拥塞控制涉及通信链路全局。</li>
<li>流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；</li>
<li>拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整</li>
<li>实际最终发送窗口 &#x3D; min{流控发送窗口，拥塞窗口}。</li>
</ul>
</li>
<li><p>102、常见的HTTP状态码有哪些？</p>
<ul>
<li><p>2xx 成功</p>
<ul>
<li><strong>200 OK</strong></li>
<li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li>
<li><strong>206 Partial Content</strong> ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li>
</ul>
</li>
<li><p>3xx 重定向</p>
<ul>
<li><strong>301 Moved Permanently</strong> ：永久性重定向</li>
<li><strong>302 Found</strong> ：临时性重定向</li>
<li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li>
<li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li>
<li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li>
</ul>
</li>
<li><p>4xx 客户端错误</p>
<ul>
<li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li>
<li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li>
<li><strong>403 Forbidden</strong> ：请求被拒绝。</li>
<li><strong>404 Not Found</strong></li>
</ul>
</li>
<li><p>5xx 服务器错误</p>
<ul>
<li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</li>
<li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li>
</ul>
</li>
</ul>
</li>
<li><p>103、服务器出现大量close_wait的连接的原因是什么？有什么解决方法？</p>
<ul>
<li><p>close_wait状态是在TCP四次挥手的时候收到FIN但是没有发送自己的FIN时出现的，服务器出现大量close_wait状态的原因有两种：</p>
<ul>
<li>服务器内部业务处理占用了过多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法</li>
<li>服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致socket的引用不为0无法回收</li>
</ul>
</li>
<li><p>处理方法：停止应用程序；修改程序里的bug</p>
</li>
</ul>
</li>
<li><p>104、一台机器能够使用的端口号上限是多少，是否可以修改？如果想要用的端口超过这个限制怎么办？</p>
<ul>
<li>65536.因为TCP的报文头部中源端口号和目的端口号的长度是16位，也就是可以表示2^16&#x3D;65536个不同端口号，因此TCP可供识别的端口号最多只有65536个。但是由于0到1023是知名服务端口，所以实际上还要少1024个端口号。</li>
<li>而对于服务器来说，可以开的端口号与65536无关，其实是受限于Linux可以打开的文件数量，并且可以通过MaxUserPort来进行配置。</li>
</ul>
</li>
</ul>
<h2 id="阿秀学习笔记C-面经整理："><a href="#阿秀学习笔记C-面经整理：" class="headerlink" title="阿秀学习笔记C++面经整理："></a>阿秀学习笔记C++面经整理：</h2><h3 id="C-常见问题"><a href="#C-常见问题" class="headerlink" title="C++常见问题"></a>C++常见问题</h3><h4 id="1、-在main执行之前和之后执行的代码可能是什么？"><a href="#1、-在main执行之前和之后执行的代码可能是什么？" class="headerlink" title="1、 在main执行之前和之后执行的代码可能是什么？"></a>1、 在main执行之前和之后执行的代码可能是什么？</h4><ul>
<li>main执行之前会进行初始化系统相关资源，比如设置栈指针、初始化静态static变量和全局变量（.idata段）、未初始化全局变量赋初值、全局对象初始化（在main直接调用构造函数）、传递argc和argv给main</li>
<li>main函数执行后主要是进行全局对象的析构函数</li>
</ul>
<h4 id="2、结构体内存对齐问题？"><a href="#2、结构体内存对齐问题？" class="headerlink" title="2、结构体内存对齐问题？"></a>2、结构体内存对齐问题？</h4><ul>
<li>结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。</li>
<li>未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐。）</li>
</ul>
<h4 id="3、指针和引用的区别"><a href="#3、指针和引用的区别" class="headerlink" title="3、指针和引用的区别"></a>3、指针和引用的区别</h4><ul>
<li>指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名</li>
<li>指针可以有多级，引用只有一级；指针可以为空，引用不能为NULL且在定义时必须初始化；指针在初始化后可以改变指向，而引用在初始化之后不可再改变</li>
<li>sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小</li>
<li>当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以</li>
</ul>
<h4 id="4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？"><a href="#4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？" class="headerlink" title="4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？"></a>4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？</h4><ul>
<li>需要返回函数内局部变量的内存的时候用指针（用完要记得释放指针，不然会内存泄漏），而返回局部变量的引用是没有意义的</li>
<li>栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小；类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式</li>
</ul>
<h4 id="5、堆和栈的区别"><a href="#5、堆和栈的区别" class="headerlink" title="5、堆和栈的区别"></a>5、堆和栈的区别</h4><ul>
<li><p>申请方式不同:栈由系统自动分配(连续存储空间);堆是自己申请和释放的（一个记录空闲内存地址的链表）</p>
</li>
<li><p>申请大小限制不同:栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定； 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。</p>
</li>
<li><p>申请效率不同：栈由系统分配，速度快，不会有碎片；堆由程序员分配，速度慢，且会有碎片。</p>
</li>
</ul>
<h4 id="6、你觉得堆快一点还是栈快一点？"><a href="#6、你觉得堆快一点还是栈快一点？" class="headerlink" title="6、你觉得堆快一点还是栈快一点？"></a>6、你觉得堆快一点还是栈快一点？</h4><ul>
<li>栈快一点。因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快</li>
<li>堆的操作是由C&#x2F;C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢</li>
</ul>
<h4 id="7、区别以下指针类型"><a href="#7、区别以下指针类型" class="headerlink" title="7、区别以下指针类型"></a>7、区别以下指针类型</h4><ul>
<li><p>int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。</p>
</li>
<li><p>int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。</p>
</li>
<li><p>int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。</p>
</li>
<li><p>int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。</p>
</li>
</ul>
<h4 id="8、new-x2F-delete-与-malloc-x2F-free的异同"><a href="#8、new-x2F-delete-与-malloc-x2F-free的异同" class="headerlink" title="8、new &#x2F; delete 与 malloc &#x2F; free的异同"></a>8、new &#x2F; delete 与 malloc &#x2F; free的异同</h4><ul>
<li><strong>相同点</strong>：都可用于内存的动态申请和释放</li>
<li><strong>不同点</strong>：<ul>
<li>malloc和free是标准库函数，支持覆盖；new和delete是运算符，不重载；</li>
<li>new自动计算要分配的空间大小，malloc需要手工计算；</li>
<li>new是类型安全的，malloc不是（malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针）</li>
<li>new调用名为<strong>operator new</strong>的标准库函数分配足够空间并调用相关对象的构造函数，delete对指针所指对象运行适当的析构函数；然后通过调用名为<strong>operator delete</strong>的标准库函数释放该对象所用内存。后者均没有相关调用；</li>
<li>malloc &#x2F; free需要库文件支持，new &#x2F; delete不用；</li>
<li>new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象</li>
</ul>
</li>
</ul>
<h4 id="9、new和delete是如何实现的？"><a href="#9、new和delete是如何实现的？" class="headerlink" title="9、new和delete是如何实现的？"></a>9、new和delete是如何实现的？</h4><ul>
<li>new调用名为<strong>operator new</strong>的标准库函数分配足够空间并调用相关对象的构造函数，delete对指针所指对象运行适当的析构函数；然后通过调用名为<strong>operator delete</strong>的标准库函数释放该对象所用内存。</li>
</ul>
<h4 id="11、既然有了malloc-x2F-free，C-中为什么还需要new-x2F-delete呢？直接用malloc-x2F-free不好吗？"><a href="#11、既然有了malloc-x2F-free，C-中为什么还需要new-x2F-delete呢？直接用malloc-x2F-free不好吗？" class="headerlink" title="11、既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？直接用malloc&#x2F;free不好吗？"></a>11、既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？直接用malloc&#x2F;free不好吗？</h4><ul>
<li>在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc&#x2F;free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc&#x2F;free，所以new&#x2F;delete是必不可少的</li>
</ul>
<h4 id="12、被free回收的内存是立即返还给操作系统吗？"><a href="#12、被free回收的内存是立即返还给操作系统吗？" class="headerlink" title="12、被free回收的内存是立即返还给操作系统吗？"></a>12、被free回收的内存是立即返还给操作系统吗？</h4><ul>
<li>不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片</li>
</ul>
<h4 id="13、宏定义和函数有何区别？"><a href="#13、宏定义和函数有何区别？" class="headerlink" title="13、宏定义和函数有何区别？"></a>13、宏定义和函数有何区别？</h4><ul>
<li>宏在预处理阶段完成替换,相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数</li>
<li>宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值。</li>
<li>宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。</li>
<li>宏定义不要在最后加分号。</li>
</ul>
<h4 id="14、宏定义和typedef区别？"><a href="#14、宏定义和typedef区别？" class="headerlink" title="14、宏定义和typedef区别？"></a>14、宏定义和typedef区别？</h4><ul>
<li>宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。</li>
<li>宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。</li>
<li>宏不检查类型；typedef会检查数据类型。</li>
<li>宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。</li>
</ul>
<h4 id="15、变量声明和定义区别？"><a href="#15、变量声明和定义区别？" class="headerlink" title="15、变量声明和定义区别？"></a>15、变量声明和定义区别？</h4><ul>
<li>声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。</li>
<li>相同变量可以在多处声明（外部变量extern），但只能在一处定义</li>
</ul>
<h4 id="16、strlen和sizeof区别？"><a href="#16、strlen和sizeof区别？" class="headerlink" title="16、strlen和sizeof区别？"></a>16、strlen和sizeof区别？</h4><ul>
<li><p>sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。</p>
</li>
<li><p>sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是’\0’的字符串。</p>
</li>
<li><p>因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小</p>
</li>
</ul>
<h4 id="16-2、一个指针占多少字节？"><a href="#16-2、一个指针占多少字节？" class="headerlink" title="16.2、一个指针占多少字节？"></a>16.2、一个指针占多少字节？</h4><ul>
<li>64位的编译环境下的，指针的占用大小为8字节；而在32位环境下，指针占用大小为4字节。<strong>一个指针占内存的大小跟编译环境有关，而与机器的位数无关</strong></li>
</ul>
<h4 id="17、常量指针和指针常量区别？"><a href="#17、常量指针和指针常量区别？" class="headerlink" title="17、常量指针和指针常量区别？"></a>17、常量指针和指针常量区别？</h4><ul>
<li>指针常量是一个指针，读成常量的指针，指向一个只读变量，也就是后面所指明的int const 和 const int，都是一个常量，可以写作int const *p或const int *p。</li>
<li>常量指针是一个不能给改变指向的指针。指针是个常量，必须初始化，一旦初始化完成，它的值（也就是存放在指针中的地址）就不能在改变了，即不能中途改变指向，如int *const p。</li>
</ul>
<h4 id="18、a和-amp-a有什么区别？"><a href="#18、a和-amp-a有什么区别？" class="headerlink" title="18、a和&amp;a有什么区别？"></a>18、a和&amp;a有什么区别？</h4><p>假设数组int a[10]; int (*p)[10] &#x3D; &amp;a;其中：</p>
<ul>
<li>a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) &#x3D; a[1]。</li>
<li>&amp;a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是<strong>数组首地址加上整个数组的偏移</strong>（10个int型变量），值为数组a尾元素后一个元素的地址。</li>
<li>若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。</li>
</ul>
<h4 id="19、C-和Python的区别"><a href="#19、C-和Python的区别" class="headerlink" title="19、C++和Python的区别"></a>19、C++和Python的区别</h4><ul>
<li><p>Python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高。</p>
</li>
<li><p>Python使用缩进来区分不同的代码块，C++使用花括号来区分</p>
</li>
<li><p>C++中需要事先定义变量的类型，而Python不需要，Python的基本数据类型只有数字，布尔值，字符串，列表，元组等等</p>
</li>
<li><p>Python的库函数比C++的多，调用起来很方便</p>
</li>
</ul>
<h4 id="20、C-和C语言的区别"><a href="#20、C-和C语言的区别" class="headerlink" title="20、C++和C语言的区别"></a>20、C++和C语言的区别</h4><ul>
<li><p>C++中new和delete是对内存分配的运算符，取代了C中的malloc和free。</p>
</li>
<li><p>在C++中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别开来。而这在C语言中是不允许的。也就是<strong>C++可以重载，C语言不允许</strong>。</p>
</li>
<li><p>C++语言中，允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以；而C语言中，必须要在函数开头部分</p>
</li>
<li><p>在C++中，<strong>除了值和指针之外，新增了引用</strong>。引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的。</p>
</li>
</ul>
<h4 id="21、C-与Java的区别"><a href="#21、C-与Java的区别" class="headerlink" title="21、C++与Java的区别"></a>21、C++与Java的区别</h4><ul>
<li><p>Java语言给开发人员提供了更为简洁的语法；完全面向对象，由于JVM可以安装到任何的操作系统上，所以说它的可移植性强</p>
</li>
<li><p>Java语言中没有指针的概念，引入了真正的数组。不同于C++中利用指针实现的“伪数组”，Java引入了真正的数组，同时将容易造成麻烦的指针从语言中去掉，这将有利于防止在C++程序中常见的因为数组操作越界等指针操作而对系统数据进行非法读写带来的不安全问题</p>
</li>
<li><p>C++也可以在其他系统运行，但是需要不同的编码（这一点不如Java，只编写一次代码，到处运行），例如对一个数字，在windows下是大端存储，在unix中则为小端存储。Java程序一般都是生成字节码，在JVM里面运行得到结果</p>
</li>
<li><p>Java用接口(Interface)技术取代C++程序中的抽象类。接口与抽象类有同样的功能，但是省却了在实现和维护上的复杂性</p>
</li>
<li><p>C++用析构函数回收垃圾，写C和C++程序时一定要注意内存的申请和释放；Java语言不使用指针，内存的分配和回收都是自动进行的，程序员无须考虑内存碎片的问题</p>
</li>
<li><p>Java在桌面程序上不如C++实用，C++可以直接编译成exe文件，指针是c++的优势，可以直接对内存的操作，但同时具有危险性 。Java在Web 应用上具有C++ 无可比拟的优势，具有丰富多样的框架；对于底层程序的编程以及控制方面的编程，C++很灵活，因为有句柄的存在</p>
</li>
</ul>
<h4 id="22、C-中struct和class的区别"><a href="#22、C-中struct和class的区别" class="headerlink" title="22、C++中struct和class的区别"></a>22、C++中struct和class的区别</h4><ul>
<li><strong>相同点</strong>:两者都拥有成员函数、公有和私有部分；任何可以使用class完成的工作，同样可以使用struct完成</li>
<li><strong>不同点</strong>：两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的；class默认是private继承， 而struct默认是public继承</li>
</ul>
<h4 id="C-和C的struct区别："><a href="#C-和C的struct区别：" class="headerlink" title="C++和C的struct区别："></a>C++和C的struct区别：</h4><ul>
<li>struct是用户自定义数据类型（UDT）；C++中struct是抽象数据类型（ADT），支持成员函数的定义，（<strong>C++中的struct能继承，能实现多态</strong>）</li>
<li><strong>C中struct是没有权限的设置的，且struct中只能是一些变量的集合体</strong>，可以封装数据却不可以隐藏数据，而且成员<strong>不可以是函数</strong>；C++中，struct增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public</li>
</ul>
<h4 id="23、define宏定义和const的区别"><a href="#23、define宏定义和const的区别" class="headerlink" title="23、define宏定义和const的区别"></a>23、define宏定义和const的区别</h4><ul>
<li>define是在编译的<strong>预处理</strong>阶段起作用，而c<strong>onst是在编译、运行的时候</strong>起作用</li>
<li><strong>define只做替换，不做类型检查和计算</strong>，也不求解，容易产生错误，在内存中会产生多分相同的备份；const常量有数据类型，编译器可以对其进行<strong>类型安全检查</strong>，只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表</li>
<li>宏定义的数据没有<strong>分配内存空间，只是插入替换掉</strong>；const定义的变量只是值不能改变，但要分配内存空间</li>
</ul>
<h4 id="24、C-中const和static的作用"><a href="#24、C-中const和static的作用" class="headerlink" title="24、C++中const和static的作用"></a>24、C++中const和static的作用</h4><ul>
<li>static不考虑类的情况：<ul>
<li>隐藏，所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用；</li>
<li>默认初始化为0，包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区</li>
<li>静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用</li>
</ul>
</li>
<li>static考虑类的情况<ul>
<li>static成员变量：只与类关联，不与类的对象关联。定义时要分配空间，不能在类声明中初始化，<strong>必须在类定义体外部初始化，初始化时不需要标示为static</strong>；可以被非static成员函数任意访问。</li>
<li>static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；<strong>不能被声明为const、虚函数和volatile</strong>；可以被非static成员函数任意访问</li>
</ul>
</li>
<li><strong>const</strong>不考虑类的情况<ul>
<li><strong>const常量在定义时必须初始化，之后无法更改</strong></li>
<li>const形参可以接收const和非const类型的实参</li>
</ul>
</li>
<li>const考虑类的情况<ul>
<li>const成员变量：<strong>不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数</strong>；不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化</li>
<li>const成员函数：<strong>const对象不可以调用非const成员函数；非const对象都可以调用</strong>；不可以改变非mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值</li>
</ul>
</li>
</ul>
<h4 id="25、C-的顶层const和底层const"><a href="#25、C-的顶层const和底层const" class="headerlink" title="25、C++的顶层const和底层const"></a>25、C++的顶层const和底层const</h4><ul>
<li><strong>顶层</strong>const：指的是const修饰的变量<strong>本身</strong>是一个常量，无法修改，指的是指针，就是const在 * 号的右边（int* const b1）</li>
<li><strong>底层</strong>const：指的是const修饰的变量<strong>所指向的对象</strong>是一个常量，指的是所指变量，就是const在 * 号的左边（const int* b2）</li>
<li>执行对象拷贝时有限制，<strong>常量的底层const不能赋值给非常量的底层const</strong></li>
<li>使用命名的强制类型转换函数const_cast时，<strong>只能改变运算对象的底层const</strong></li>
</ul>
<h4 id="26、数组名和指针（这里为指向数组首元素的指针）区别？"><a href="#26、数组名和指针（这里为指向数组首元素的指针）区别？" class="headerlink" title="26、数组名和指针（这里为指向数组首元素的指针）区别？"></a>26、数组名和指针（这里为指向数组首元素的指针）区别？</h4><ul>
<li>二者均可通过增减偏移量来访问数组中的元素。</li>
<li>数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。</li>
<li><strong>当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。</strong></li>
</ul>
<h4 id="27、final和override关键字"><a href="#27、final和override关键字" class="headerlink" title="27、final和override关键字"></a>27、final和override关键字</h4><ul>
<li><strong>override</strong>用于当在父类中使用了虚函数时候，需要在某个子类中对这个虚函数进行重写，保证进行了重写，否则会报错</li>
<li><strong>final</strong>：当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错</li>
</ul>
<h4 id="28、拷贝初始化和直接初始化"><a href="#28、拷贝初始化和直接初始化" class="headerlink" title="28、拷贝初始化和直接初始化"></a>28、拷贝初始化和直接初始化</h4><ul>
<li><p>当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。举例如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="title function_">str1</span><span class="params">(<span class="string">&quot;I am a string&quot;</span>)</span>;<span class="comment">//语句1 直接初始化</span></span><br><span class="line"><span class="built_in">string</span> <span class="title function_">str2</span><span class="params">(str1)</span>;<span class="comment">//语句2 直接初始化，str1是已经存在的对象，直接调用拷贝构造函数对str2进行初始化</span></span><br><span class="line"><span class="built_in">string</span> str3 = <span class="string">&quot;I am a string&quot;</span>;<span class="comment">//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3</span></span><br><span class="line"><span class="built_in">string</span> str4 = str1;<span class="comment">//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为了提高效率，允许编译器跳过创建临时对象这一步，<strong>直接调用构造函数构造要创建的对象，这样就完全等价于</strong>直接初始化了（语句1和语句3等价），但是需要辨别两种情况:</p>
<ul>
<li>当拷贝构造函数为private时：语句3和语句4在编译时会报错</li>
<li>使用explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错</li>
</ul>
</li>
</ul>
<h4 id="29、初始化和赋值的区别"><a href="#29、初始化和赋值的区别" class="headerlink" title="29、初始化和赋值的区别"></a>29、初始化和赋值的区别</h4><ul>
<li><p>对于简单类型来说，初始化和赋值没什么区别</p>
</li>
<li><p>对于类和复杂数据类型来说，赋值会调用赋值运算符，初始化调用构造函数</p>
</li>
</ul>
<h4 id="30、extern”C”的用法"><a href="#30、extern”C”的用法" class="headerlink" title="30、extern”C”的用法"></a>30、extern”C”的用法</h4><ul>
<li><p>为了能够<strong>正确的在C++代码中调用C语言</strong>的代码：在程序中加上extern “C”后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++；</p>
<p>这些情况下使用extern “C”：</p>
<p>（1）C++代码中调用C语言代码；</p>
<p>（2）在C++中的头文件中使用；</p>
<p>（3）在多个人协同开发时，可能有人擅长C语言，而有人擅长C++；</p>
</li>
</ul>
<h4 id="31、野指针和悬空指针"><a href="#31、野指针和悬空指针" class="headerlink" title="31、野指针和悬空指针"></a>31、野指针和悬空指针</h4><ul>
<li><p>都是是指向无效内存区域(这里的无效指的是”不安全不可控”)的指针，访问行为将会导致未定义行为。</p>
</li>
<li><p>野指针，指的是没有被初始化过的指针；悬空指针，指针最初指向的内存已经被释放了的一种指针。</p>
</li>
<li><p><strong>产生原因及解决办法：</strong></p>
<p>野指针：指针变量未及时初始化 &#x3D;&gt; 定义指针变量及时初始化，要么置空。</p>
<p>悬空指针：指针free或delete之后没有及时置空 &#x3D;&gt; 释放操作后立即置空。</p>
</li>
</ul>
<h4 id="32、C和C-的类型安全"><a href="#32、C和C-的类型安全" class="headerlink" title="32、C和C++的类型安全"></a>32、C和C++的类型安全</h4><ul>
<li><p>类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。“类型安全”常被用来形容编程语言，其根据在于该门编程语言是否提供保障类型安全的机制；有的时候也用“类型安全”形容某个程序，判别的标准在于该程序是否隐含类型错误。</p>
</li>
<li><p>C中相当多的操作是不安全的，比如printf和malloc中的情况；</p>
</li>
<li><p>C++提供了一些新的机制保障类型安全：</p>
<ul>
<li><p>操作符new返回的指针类型严格与对象匹配，而不是void*</p>
</li>
<li><p>C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；</p>
</li>
<li><p>引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换</p>
</li>
<li><p>一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全</p>
</li>
<li><p>C++提供了<strong>dynamic_cast</strong>关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。</p>
</li>
</ul>
</li>
</ul>
<h4 id="33、C-中的重载、重写（覆盖）和隐藏的区别"><a href="#33、C-中的重载、重写（覆盖）和隐藏的区别" class="headerlink" title="33、C++中的重载、重写（覆盖）和隐藏的区别"></a>33、C++中的重载、重写（覆盖）和隐藏的区别</h4><ul>
<li><p>重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是函数名相同，参数类型和数目有所不同，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。重载和函数成员是否是虚函数无关</p>
</li>
<li><p>重写指的是在派生类中覆盖基类中的同名函数，<strong>重写就是重写函数体</strong>，<strong>要求基类函数必须是虚函数</strong>且与基类的虚函数有相同的参数个数,相同的参数类型,相同的返回值类型</p>
</li>
<li><p>重载与重写的区别：</p>
<ul>
<li>重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系</li>
<li>重写要求参数列表相同，重载则要求参数列表不同，返回值不要求</li>
<li>重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体</li>
</ul>
</li>
<li><p>隐藏指的是某些情况下，<strong>派生类中的函数屏蔽了基类中的同名函数</strong>，包括以下情况：</p>
<ul>
<li>两个函数参数相同，但是基类函数不是虚函数。和重写的区别在于基类函数是否是虚函数</li>
<li>两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中</li>
</ul>
</li>
</ul>
<h4 id="34、C-有哪几种的构造函数"><a href="#34、C-有哪几种的构造函数" class="headerlink" title="34、C++有哪几种的构造函数"></a>34、C++有哪几种的构造函数</h4><ul>
<li>默认构造函数；初始化构造函数（有参数）；拷贝构造函数；移动构造函数（move和右值引用）；委托构造函数；转换构造函数</li>
<li>默认构造函数和初始化构造函数在定义类的对象，完成对象的初始化工作</li>
<li>复制构造函数用于复制本类的对象</li>
<li>转换构造函数用于将其他类型的变量，隐式转换为本类对象</li>
</ul>
<h4 id="35、浅拷贝和深拷贝的区别"><a href="#35、浅拷贝和深拷贝的区别" class="headerlink" title="35、浅拷贝和深拷贝的区别"></a>35、浅拷贝和深拷贝的区别</h4><ul>
<li>浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误</li>
<li>深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。</li>
</ul>
<h4 id="36、内联函数和宏定义的区别"><a href="#36、内联函数和宏定义的区别" class="headerlink" title="36、内联函数和宏定义的区别"></a>36、内联函数和宏定义的区别</h4><ul>
<li>在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。</li>
<li>内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载。</li>
<li>宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义</li>
<li>内联函数有类型检测、语法判断等功能，而宏没有</li>
</ul>
<h4 id="37、public，protected和private访问和继承权限的区别？"><a href="#37、public，protected和private访问和继承权限的区别？" class="headerlink" title="37、public，protected和private访问和继承权限的区别？"></a>37、public，protected和private访问和继承权限的区别？</h4><ul>
<li>public的变量和函数在类的内部外部都可以访问。</li>
<li>protected的变量和函数只能在类的内部和其派生类中访问。</li>
<li>private修饰的元素只能在类内访问。</li>
</ul>
<p>注意外部访问并不是真正的外部访问，而是在通过派生类的对象对基类成员的访问。</p>
<ul>
<li>public、protected、private 的访问权限范围关系：public &gt; protected &gt; private</li>
<li>派生类对基类成员的访问权限取决于两点：一、继承方式；二、基类成员在基类中的访问权限</li>
<li>派生类对基类成员的访问权限是取以上两点中的更小的访问范围（除了 private 的继承方式遇到 private 成员是不可见外）</li>
</ul>
<h4 id="38、如何用代码判断大小端存储？"><a href="#38、如何用代码判断大小端存储？" class="headerlink" title="38、如何用代码判断大小端存储？"></a>38、如何用代码判断大小端存储？</h4><ul>
<li><p>大端存储：字数据的高字节存储在低地址中；小端存储：字数据的低字节存储在低地址中；在Socket编程中，往往需要将操作系统所用的小端存储的IP地址转换为大端存储，这样才能进行网络传输</p>
<ul>
<li><p>方式一：使用强制类型转换，抓换为字符进行判断</p>
</li>
<li><p>方式二：巧用union联合体，union包含一个int和一个char</p>
</li>
</ul>
</li>
</ul>
<h4 id="39、volatile、mutable和explicit关键字的用法"><a href="#39、volatile、mutable和explicit关键字的用法" class="headerlink" title="39、volatile、mutable和explicit关键字的用法"></a>39、volatile、mutable和explicit关键字的用法</h4><ul>
<li><p>volatile 关键字是一种类型修饰符，<strong>用它声明的类型变量表示可以被某些编译器未知的因素更改</strong>，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</p>
</li>
<li><p>当要求使用 volatile 声明的变量的值的时候，<strong>系统总是重新从它所在的内存读取数据</strong>，即使它前面的指令刚刚从该处读取过数据。volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型</p>
</li>
<li><p>mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中；有些时候，我们需要<strong>在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置</strong></p>
</li>
<li><p>explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以<strong>显示的方式进行类型转换</strong>，注意以下几点：</p>
<ul>
<li>explicit 关键字只能用于类内部的构造函数声明上</li>
<li>explicit 关键字作用于单个参数的构造函数</li>
<li>被explicit修饰的构造函数的类，不能发生相应的隐式类型转换</li>
</ul>
</li>
</ul>
<h4 id="40、什么情况下会调用拷贝构造函数"><a href="#40、什么情况下会调用拷贝构造函数" class="headerlink" title="40、什么情况下会调用拷贝构造函数"></a>40、什么情况下会调用拷贝构造函数</h4><ul>
<li>用类的一个实例化对象去初始化另一个对象的时候</li>
<li>函数的参数是类的对象时（非引用传递）</li>
<li>函数的返回值是函数体内局部对象的类的对象时 ,此时虽然发生（Named return Value优化）NRV优化，但是由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数</li>
</ul>
<h4 id="41、C-中有几种类型的new"><a href="#41、C-中有几种类型的new" class="headerlink" title="41、C++中有几种类型的new"></a>41、C++中有几种类型的new</h4><ul>
<li>在C++中，new有三种典型的使用方法：plain new，nothrow new和placement new</li>
<li><strong>plain new</strong>言下之意就是普通的new，就是我们常用的new；在空间分配失败的情况下，抛出异常<strong>std::bad_alloc</strong>而不是返回NULL，因此通过判断返回值是否为NULL是徒劳的</li>
<li>nothrow new在空间分配失败的情况下是不抛出异常，而是返回NULL</li>
<li><strong>placement new</strong>允许在一块已经分配成功的内存上重新构造对象或对象数组。placement new不用担心内存分配失败，因为它根本不分配内存，它<strong>做的唯一一件事情就是调用对象的构造函数</strong>；使用placement new需要注意两点：<ul>
<li>palcement new的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组</li>
<li>placement new构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使用delete，这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误</li>
</ul>
</li>
</ul>
<h4 id="42、C-的异常处理的方法"><a href="#42、C-的异常处理的方法" class="headerlink" title="42、C++的异常处理的方法"></a>42、C++的异常处理的方法</h4><ul>
<li>try、throw和catch关键字：程序的执行流程是先执行try包裹的语句块，如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块，如果发生异常，则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class。<strong>catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(…)的方式捕获任何异常（不推荐）。</strong>当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常。</li>
<li>函数的异常声明列表：程序员在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表</li>
<li>C++ 标准库中有一些类代表异常，这些类都是从 exception 类派生而来的<ul>
<li>bad_typeid：使用typeid运算符，如果其操作数是一个多态类的指针，而该指针的值为 NULL，则会拋出此异常</li>
<li>bad_cast：在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常</li>
<li>bad_alloc：在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常</li>
<li>out_of_range:用 vector 或 string的at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常</li>
</ul>
</li>
</ul>
<h4 id="43、static的用法和作用？"><a href="#43、static的用法和作用？" class="headerlink" title="43、static的用法和作用？"></a>43、static的用法和作用？</h4><ul>
<li>隐藏。（static函数，static变量均可）当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。</li>
<li>保持变量内容的持久。（static变量中的记忆功能和全局生存期）存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化</li>
<li>默认初始化为0（static变量）</li>
<li>C++中的类成员声明static：<ol>
<li>函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；</li>
<li>在模块内的static全局变量可以被模块内所有函数访问，但不能被模块外其它函数访问</li>
<li>在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；</li>
<li>在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；</li>
<li>在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。</li>
<li>static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化；</li>
<li>static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，this-&gt;vptr-&gt;ctable-&gt;virtual function</li>
</ol>
</li>
</ul>
<h4 id="44、指针和const的用法"><a href="#44、指针和const的用法" class="headerlink" title="44、指针和const的用法"></a>44、指针和const的用法</h4><ul>
<li>当const修饰指针时，由于const的位置不同，它的修饰对象会有所不同。</li>
<li>int *const p2中const修饰p2的值,所以理解为p2的值不可以改变，即p2只能指向固定的一个变量地址，但可以通过*p2读写这个变量的值。顶层指针表示指针本身是一个常量</li>
<li>int const *p1或者const int *p1两种情况中const修饰*p1，所以理解为*p1的值不可以改变，即不可以给*p1赋值改变p1指向变量的值，但可以通过给p赋值不同的地址改变这个指针指向。底层指针表示指针所指向的变量是一个常量</li>
</ul>
<h4 id="45、形参与实参的区别？"><a href="#45、形参与实参的区别？" class="headerlink" title="45、形参与实参的区别？"></a>45、形参与实参的区别？</h4><ul>
<li>形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量</li>
<li>实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值，会产生一个临时变量。</li>
<li>实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。</li>
<li>函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化</li>
<li>当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变</li>
</ul>
<h4 id="46、值传递、指针传递、引用传递的区别和效率"><a href="#46、值传递、指针传递、引用传递的区别和效率" class="headerlink" title="46、值传递、指针传递、引用传递的区别和效率"></a>46、值传递、指针传递、引用传递的区别和效率</h4><ul>
<li>值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象 或是大的结构体对象，将耗费一定的时间和空间。（传值）</li>
<li>指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。（传值，传递的是地址值）</li>
<li>引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（传地址）</li>
<li>效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰</li>
</ul>
<h4 id="47、静态变量什么时候初始化"><a href="#47、静态变量什么时候初始化" class="headerlink" title="47、静态变量什么时候初始化"></a>47、静态变量什么时候初始化</h4><ul>
<li><p>静态局部变量和全局变量一样，数据都存放在全局区域，<strong>所以在主程序之前，编译器已经为其分配好了内存</strong>，但在C和C++中静态局部变量的初始化节点又有点不太一样。</p>
</li>
<li><p>在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，所以在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，变量所处的全局内存会被全部回收。</p>
</li>
<li><p>而在C++中，初始化时在执行相关代码时才会进行初始化，主要是由于C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以C++标准定为全局或静态对象是有首次用到时才会进行构造，并通过atexit()来管理。在程序结束，按照构造顺序反方向进行逐个析构。所以在C++中是可以使用变量对静态局部变量进行初始化的</p>
</li>
<li><p>48、const关键字的作用有哪些?</p>
<ol>
<li>阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；</li>
<li>对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；</li>
<li>在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；</li>
<li>对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量，类的常对象只能访问类的常成员函数；有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。</li>
<li>const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；</li>
<li>一个没有明确声明为const的成员函数被看作是将要修改对象中数据成员的函数，而且编译器不允许它为一个const对象所调用。因此const对象只能调用const成员函数。</li>
<li>const类型变量可以通过类型转换符const_cast将const类型转换为非const类型；</li>
<li>const类型变量必须定义的时候进行初始化，因此也导致如果类的成员变量有const类型的变量，那么该变量必须在<strong>类的初始化列表中进行初始化</strong>；</li>
<li>对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进函数的，函数内只能改变临时变量，但无法改变实参。则这个时候无论加不加const对实参不会产生任何影响。但是在引用或指针传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的变量，这时const 才是实实在在地保护了实参所指向的变量。因为在编译阶段编译器对调用函数的选择是根据实参进行的，所以，只有引用传递和指针传递可以用是否加const来重载。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来</li>
</ol>
</li>
</ul>
<h4 id="49、什么是类的继承？"><a href="#49、什么是类的继承？" class="headerlink" title="49、什么是类的继承？"></a>49、什么是类的继承？</h4><ul>
<li>所谓的继承就是一个类继承了另一个类的属性和方法，这个新的类包含了上一个类的属性和方法，被称为子类或者派生类，被继承的类称为父类或者基类</li>
<li>子类拥有父类的所有属性和方法，子类可以拥有父类没有的属性和方法，<strong>子类对象可以当做父类对象使用</strong>；</li>
</ul>
<h4 id="50、从汇编层去解释一下引用"><a href="#50、从汇编层去解释一下引用" class="headerlink" title="50、从汇编层去解释一下引用"></a>50、从汇编层去解释一下引用</h4><ul>
<li>int &amp;b &#x3D; x;会被汇编为将x的地址存入变量b中，所以从汇编层次来看，的确引用是通过指针来实现的</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span>:      <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="number">00401048</span>  mov     dword ptr [ebp<span class="number">-4</span>],<span class="number">1</span></span><br><span class="line"><span class="number">10</span>:     <span class="type">int</span> &amp;b = x;</span><br><span class="line"><span class="number">0040104F</span>   lea     eax,[ebp<span class="number">-4</span>]</span><br><span class="line"><span class="number">00401052</span>  mov     dword ptr [ebp<span class="number">-8</span>],eax</span><br></pre></td></tr></table></figure>

<p>x的地址为ebp-4，b的地址为ebp-8，因为栈内的变量内存是从高往低进行分配的，所以b的地址比x的低。</p>
<p>lea eax,[ebp-4] 这条语句将x的地址ebp-4放入eax寄存器</p>
<p>mov dword ptr [ebp-8],eax 这条语句将eax的值放入b的地址</p>
<p>ebp-8中上面两条汇编的作用即：将x的地址存入变量b中，这不和将某个变量的地址存入指针变量是一样的吗？所以从汇编层次来看，的确引用是通过指针来实现的。</p>
<h4 id="53、delete-p、delete-p、allocator都有什么作用？"><a href="#53、delete-p、delete-p、allocator都有什么作用？" class="headerlink" title="53、delete p、delete [] p、allocator都有什么作用？"></a>53、delete p、delete [] p、allocator都有什么作用？</h4><ul>
<li>动态数组管理new一个数组时，[]中必须是一个整数，但是不一定是常量整数，普通数组必须是一个常量整数；new动态数组返回的并不是数组类型，而是一个元素类型的指针；</li>
<li>delete[]时，数组中的元素按逆序的顺序进行销毁；</li>
<li>new在内存分配上面有一些局限性，new的机制是将内存分配和对象构造组合在一起，同样的，delete也是将对象析构和内存释放组合在一起的。allocator将这两部分分开进行，allocator申请一部分内存，不进行初始化对象，只有当需要的时候才进行初始化操作</li>
</ul>
<h4 id="54、new和delete的实现原理，-delete是如何知道释放内存的大小的？"><a href="#54、new和delete的实现原理，-delete是如何知道释放内存的大小的？" class="headerlink" title="54、new和delete的实现原理， delete是如何知道释放内存的大小的？"></a>54、new和delete的实现原理， delete是如何知道释放内存的大小的？</h4><ul>
<li><p>new简单类型直接调用operator new分配内存；而对于复杂结构，先调用operator new分配内存，然后在分配的内存上调用构造函数；</p>
</li>
<li><p>对于简单类型，new[]计算好大小后调用operator new；对于复杂数据结构，new[]先调用operator new[]分配内存，然后在p的前四个字节写入数组大小n，然后调用n次构造函数，针对复杂类型，new[]会额外存储数组大小；</p>
<p>① new表达式调用一个名为operator new(operator new[])函数，分配一块足够大的、原始的、未命名的内存空间；</p>
<p>② 编译器运行相应的构造函数以构造这些对象，并为其传入初始值；</p>
<p>③ 对象被分配了空间并构造完成，返回一个指向该对象的指针。</p>
</li>
<li><p>delete简单数据类型默认只是调用free函数；复杂数据类型先调用析构函数再调用operator delete；针对简单类型，delete和delete[]等同。假设指针p指向new[]分配的内存。因为要4字节存储数组大小，实际分配的内存地址为[p-4]，系统记录的也是这个地址。delete[]实际释放的就是p-4指向的内存。而delete会直接释放p指向的内存，这个内存根本没有被系统记录，所以会崩溃。</p>
</li>
<li><p>需要在 new [] 一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配了 4 个字节的大小，专门保存数组的大小，在 delete [] 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了。</p>
</li>
</ul>
<h4 id="55、malloc申请的存储空间能用delete释放吗"><a href="#55、malloc申请的存储空间能用delete释放吗" class="headerlink" title="55、malloc申请的存储空间能用delete释放吗?"></a>55、malloc申请的存储空间能用delete释放吗?</h4><ul>
<li>不能，malloc &#x2F;free主要为了兼容C，new和delete 完全可以取代malloc &#x2F;free的。</li>
<li>malloc &#x2F;free的操作对象都是必须明确大小的，而且不能用在动态类上。new 和delete会自动进行类型检查和大小，malloc&#x2F;free不能执行构造函数与析构函数，所以动态对象它是不行的。</li>
<li>当然从理论上说使用malloc申请的内存是可以通过delete释放的。不过一般不这样写的。而且也不能保证每个C++的运行时都能正常</li>
</ul>
<h4 id="56、malloc与free的实现原理？"><a href="#56、malloc与free的实现原理？" class="headerlink" title="56、malloc与free的实现原理？"></a>56、malloc与free的实现原理？</h4><ul>
<li>标准C库中，提供了malloc&#x2F;free函数分配释放内存，这两个函数底层是由brk、mmap、munmap这些系统调用实现的</li>
<li>brk是将数据段(.data)的最高地址指针_edata往高地址推</li>
<li>mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存</li>
<li>这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系</li>
<li>malloc小于128k的内存，使用brk分配内存，将_edata往高地址推；malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配；brk分配的内存需要等到高地址内存释放以后才能释放，而mmap分配的内存可以单独释放。当最高地址空间的空闲内存超过128K时，执行内存紧缩操作</li>
<li>malloc是从堆里面申请内存，也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序</li>
</ul>
<h4 id="57、malloc、realloc、calloc的区别"><a href="#57、malloc、realloc、calloc的区别" class="headerlink" title="57、malloc、realloc、calloc的区别"></a>57、malloc、realloc、calloc的区别</h4><ul>
<li><code>void* malloc(unsigned int num_size);</code></li>
<li><code>void* malloc(unsigned int num_size);</code>省去了人为空间计算；malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的</li>
<li><code>void realloc(void *p, size_t new_size);</code>给动态分配的空间分配额外的空间，用于扩充容量</li>
</ul>
<h4 id="58、类成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些"><a href="#58、类成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些" class="headerlink" title="58、类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些"></a>58、类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些</h4><ul>
<li><p>赋值初始化，通过在函数体内进行赋值初始化；列表初始化，在冒号后使用初始化列表进行初始化</p>
</li>
<li><p>这两种方式的主要区别在于：</p>
<ul>
<li><p>对于在函数体中初始化,是在所有的数据成员被分配内存空间后才进行的。</p>
</li>
<li><p><strong>列表初始化是给数据成员分配内存空间时就进行初始化</strong>,就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式),那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行</p>
</li>
</ul>
</li>
<li><p>一个派生类构造函数的执行顺序如下：</p>
<p>① 虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）。</p>
<p>② 基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。</p>
<p>③ 类类型的成员对象的构造函数（按照初始化顺序）</p>
<p>④ 派生类自己的构造函数。</p>
</li>
<li><p>为什么用成员初始化列表会快一些：<strong>赋值初始化是在构造函数当中做赋值的操作，C++的赋值操作是会产生临时对象的，临时对象的出现会降低程序的效率</strong></p>
</li>
</ul>
<h4 id="59、有哪些情况必须用到成员列表初始化？作用是什么？"><a href="#59、有哪些情况必须用到成员列表初始化？作用是什么？" class="headerlink" title="59、有哪些情况必须用到成员列表初始化？作用是什么？"></a>59、有哪些情况必须用到成员列表初始化？作用是什么？</h4><ul>
<li><p>必须使用成员初始化的四种情况：</p>
<p>① 当初始化一个引用成员时；</p>
<p>② 当初始化一个常量成员时；</p>
<p>③ 当调用一个基类的构造函数，而它拥有一组参数时；</p>
<p>④ 当调用一个成员类的构造函数，而它拥有一组参数时；</p>
</li>
<li><p>成员初始化列表做了什么：</p>
<p>① 编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前；</p>
<p>② list中的项目顺序是由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的</p>
</li>
</ul>
<h4 id="60、C-中新增了string，它与C语言中的-char-有什么区别吗？它是如何实现的？"><a href="#60、C-中新增了string，它与C语言中的-char-有什么区别吗？它是如何实现的？" class="headerlink" title="60、C++中新增了string，它与C语言中的 char *有什么区别吗？它是如何实现的？"></a>60、C++中新增了string，它与C语言中的 char *有什么区别吗？它是如何实现的？</h4><ul>
<li>string继承自basic_string,其实是对char*进行了封装，封装的string包含了char*数组，容量，长度等等属性。</li>
<li>string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^n），然后将原字符串拷贝过去，并加上新增的内容。</li>
</ul>
<h4 id="61、什么是内存泄露，如何检测与避免"><a href="#61、什么是内存泄露，如何检测与避免" class="headerlink" title="61、什么是内存泄露，如何检测与避免"></a>61、什么是内存泄露，如何检测与避免</h4><ul>
<li><p>一般我们常说的内存泄漏是指<strong>堆内存的泄漏</strong>。堆内存是指程序从堆中分配的，大小任意的(内存块的大小可以在程序运行期决定)内存块，使用完后必须显式释放的内存。应用程序般使用malloc、realloc、new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了</p>
</li>
<li><p><strong>避免内存泄露的几种方式</strong>：</p>
<ul>
<li><p>计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露</p>
</li>
<li><p>一定要将基类的析构函数声明为<strong>虚函数</strong></p>
</li>
<li><p>对象数组的释放一定要用<strong>delete []</strong></p>
</li>
<li><p>有new就有delete，有malloc就有free，保证它们一定成对出现</p>
</li>
<li><p><strong>检测工具</strong>：Linux下可以使用<strong>Valgrind工具</strong>；Windows下可以使用<strong>CRT库</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="62、对象复用的了解，零拷贝的了解"><a href="#62、对象复用的了解，零拷贝的了解" class="headerlink" title="62、对象复用的了解，零拷贝的了解"></a>62、对象复用的了解，零拷贝的了解</h4><ul>
<li>对象复用其本质是一种设计模式：Flyweight享元模式。通过将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源</li>
<li>零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。零拷贝技术可以减少数据拷贝和共享总线操作的次数。</li>
<li>在C++中，vector的一个成员函数<strong>emplace_back()<strong>很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部，区别在于：</strong>使用push_back()函数需要调用拷贝构造函数和转移构造函数，而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造和转移构造</strong>，效率更高。</li>
</ul>
<h4 id="63、介绍面向对象的三大特性，并且举例说明"><a href="#63、介绍面向对象的三大特性，并且举例说明" class="headerlink" title="63、介绍面向对象的三大特性，并且举例说明"></a>63、介绍面向对象的三大特性，并且举例说明</h4><p>三大特性：继承、封装和多态</p>
<p><strong>（1）继承</strong>：<strong>让某种类型对象获得另一个类型对象的属性和方法。</strong>它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展</p>
<ul>
<li><p>常见的继承有三种方式：</p>
<ol>
<li>实现继承：指使用基类的属性和方法而无需额外编码的能力</li>
<li>接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力</li>
<li>可视继承：指子窗体（类）使用基窗体（类）的外观和实现代码的能力</li>
</ol>
<p>例如，将人定义为一个抽象类，拥有姓名、性别、年龄等公共属性，吃饭、睡觉、走路等公共方法，在定义一个具体的人时，就可以继承这个抽象类，既保留了公共属性和方法，也可以在此基础上扩展跳舞、唱歌等特有方法</p>
</li>
</ul>
<p><strong>（2）封装</strong>：数据和代码捆绑在一起，避免外界干扰和不确定性访问。封装，也就是<strong>把客观事物封装成抽象的类</strong>，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰</p>
<p><strong>（3）多态</strong>：同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为<strong>（重载实现编译时多态，虚函数实现运行时多态）</strong>。</p>
<ul>
<li><p>多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。<strong>简单一句话：允许将子类类型的指针赋值给父类类型的指针</strong></p>
</li>
<li><p>实现多态有二种方式：覆盖（override），重载（overload）。</p>
<ul>
<li>覆盖：是指子类重新定义父类的虚函数的做法。</li>
<li>重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。</li>
</ul>
<p>例如：基类是一个抽象对象——人，那教师、运动员也是人，而使用这个抽象对象既可以表示教师、也可以表示运动员</p>
</li>
</ul>
<h4 id="64、成员初始化列表的概念，为什么用它会快一些？"><a href="#64、成员初始化列表的概念，为什么用它会快一些？" class="headerlink" title="64、成员初始化列表的概念，为什么用它会快一些？"></a>64、成员初始化列表的概念，为什么用它会快一些？</h4><ul>
<li>在类的构造函数中，不在函数体内对成员变量赋值，而是在构造函数的花括号前面使用冒号和初始化列表赋值</li>
<li><strong>效率</strong>:用初始化列表会快一些的原因是，对于类型，它少了一次调用构造函数的过程，而在函数体中赋值则会多一次调用。而对于内置数据类型则没有差别</li>
<li>由于对象成员变量的初始化动作发生在进入构造函数之前，对于内置类型没什么影响，但<strong>如果有些成员是类</strong>，那么在进入构造函数之前，会先调用一次默认构造函数，进入构造函数后所做的事其实是一次赋值操作(对象已存在)，所以<strong>如果是在构造函数体内进行赋值的话，等于是一次默认构造加一次赋值，而初始化列表只做一次赋值操作</strong></li>
</ul>
<h4 id="C-的四种强制转换reinterpret-cast-x2F-const-cast-x2F-static-cast-x2F-dynamic-cast"><a href="#C-的四种强制转换reinterpret-cast-x2F-const-cast-x2F-static-cast-x2F-dynamic-cast" class="headerlink" title="C++的四种强制转换reinterpret_cast &#x2F; const_cast &#x2F; static_cast &#x2F; dynamic_cast"></a>C++的四种强制转换reinterpret_cast &#x2F; const_cast &#x2F; static_cast &#x2F; dynamic_cast</h4><ul>
<li><p>reinterpret_cast<type-id> (expression)：type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转换</p>
</li>
<li><p>const_cast<type_id> (expression)：该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的</p>
</li>
<li><p>static_cast &lt; type-id &gt; (expression)：该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：</p>
<ul>
<li>用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换</li>
<li>进行上行转换（把派生类的指针或引用转换成基类表示）是安全的</li>
<li>进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的</li>
<li>用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。</li>
<li>把空指针转换成目标类型的空指针</li>
<li>把任何类型的表达式转换成void类型</li>
</ul>
<p>注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。</p>
</li>
<li><p>dynamic_cast <type-id> (expression)：该运算符把expression转换成type-id类型的对象。type-id 必须是类的指针、类的引用或者void*；如果 type-id 是类指针类型，那么expression也必须是一个指针，如果 type-id 是一个引用，那么 expression 也必须是一个引用</p>
<ul>
<li>dynamic_cast运算符可以在执行期决定真正的类型，也就是说expression必须是多态类型。如果下行转换是安全的（也就说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回适当转型过的指针。如果下行转换不安全，这个运算符会传回空指针（也就是说，基类指针或者引用没有指向一个派生类对象）</li>
<li>dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换</li>
<li>在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全</li>
</ul>
</li>
</ul>
<h4 id="66、C-函数调用的压栈过程"><a href="#66、C-函数调用的压栈过程" class="headerlink" title="66、C++函数调用的压栈过程"></a>66、C++函数调用的压栈过程</h4><ul>
<li><p>函数的调用过程：</p>
<p>1）从栈空间分配存储空间</p>
<p>2）从实参的存储空间复制值到形参栈空间</p>
<p>3）进行运算</p>
</li>
<li><p>形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。</p>
</li>
<li><p>数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。</p>
</li>
<li><p>当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址&#x2F;指针传递</p>
</li>
</ul>
<h4 id="67、写C-代码时有一类错误是-coredump-，很常见，你遇到过吗？怎么调试这个错误？"><a href="#67、写C-代码时有一类错误是-coredump-，很常见，你遇到过吗？怎么调试这个错误？" class="headerlink" title="67、写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？"></a>67、写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？</h4><ul>
<li>coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息</li>
<li>使用gdb命令对core文件进行调试<code>gdb [可执行文件名] [core文件名]</code></li>
</ul>
<h4 id="68、说说移动构造函数"><a href="#68、说说移动构造函数" class="headerlink" title="68、说说移动构造函数"></a>68、说说移动构造函数</h4><ul>
<li>我们用对象a初始化对象b，后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；</li>
<li>拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制。浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将第一个指针（比如a-&gt;value）置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a-&gt;value指向的空间；</li>
<li>移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。意味着，移动构造函数的参数是一个右值或者将亡值的引用。也就是说，只用用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。而那个move语句，就是将一个左值变成一个将亡值。</li>
</ul>
<h4 id="69、C-中将临时变量作为返回值时的处理过程"><a href="#69、C-中将临时变量作为返回值时的处理过程" class="headerlink" title="69、C++中将临时变量作为返回值时的处理过程"></a>69、C++中将临时变量作为返回值时的处理过程</h4><ul>
<li>当函数退出时，临时变量出栈，即临时变量已经被销毁，临时变量占用的内存空间没有被清空，但是可以被分配给其他变量，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了</li>
<li>函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系；如果我们需要返回值，一般使用赋值语句就可以了</li>
</ul>
<h4 id="70、如何获得结构成员相对于结构开头的字节偏移量"><a href="#70、如何获得结构成员相对于结构开头的字节偏移量" class="headerlink" title="70、如何获得结构成员相对于结构开头的字节偏移量"></a>70、如何获得结构成员相对于结构开头的字节偏移量</h4><ul>
<li>使用&lt;stddef.h&gt;头文件中的，offsetof宏</li>
<li>#pragma pack(4) 指定4字节对齐方式</li>
</ul>
<h4 id="71、静态类型和动态类型，静态绑定和动态绑定的介绍"><a href="#71、静态类型和动态类型，静态绑定和动态绑定的介绍" class="headerlink" title="71、静态类型和动态类型，静态绑定和动态绑定的介绍"></a>71、静态类型和动态类型，静态绑定和动态绑定的介绍</h4><ul>
<li><p>静态类型：对象在声明时采用的类型，在编译期既已确定；</p>
</li>
<li><p>动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；</p>
</li>
<li><p>静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；</p>
</li>
<li><p>动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；</p>
</li>
<li><p>非虚函数一般都是静态绑定，而虚函数都是动态绑定（如此才可实现多态性）；空指针也能够直接调用no-virtual函数而不报错，因此静态绑定不能实现多态</p>
</li>
<li><p>静态绑定和动态绑定的区别：</p>
<ul>
<li>静态绑定发生在编译期，动态绑定发生在运行期；</li>
<li>对象的动态类型可以更改，但是静态类型无法更改；</li>
<li>要想实现动态，必须使用动态绑定；</li>
<li>在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定</li>
</ul>
</li>
<li><p>绝对不要重新定义继承而来的非虚(non-virtual)函数，因为这样导致函数调用由对象声明时的静态类型确定了，而和对象本身脱离了关系，没有多态，也这将给程序留下不可预知的隐患和莫名其妙的BUG；另外，在动态绑定也即在virtual函数中，要注意默认参数的使用。当缺省参数和virtual函数一起使用的时候一定要谨慎，不然出了问题怕是很难排查</p>
</li>
</ul>
<h4 id="72、引用是否能实现动态绑定，为什么可以实现？"><a href="#72、引用是否能实现动态绑定，为什么可以实现？" class="headerlink" title="72、引用是否能实现动态绑定，为什么可以实现？"></a>72、引用是否能实现动态绑定，为什么可以实现？</h4><ul>
<li>可以。引用在创建的时候必须初始化，在访问虚函数时，编译器会根据其所绑定的对象类型决定要调用哪个函数。注意只能调用虚函数</li>
</ul>
<h4 id="73、全局变量和局部变量有什么区别？"><a href="#73、全局变量和局部变量有什么区别？" class="headerlink" title="73、全局变量和局部变量有什么区别？"></a>73、全局变量和局部变量有什么区别？</h4><ul>
<li>生命周期不同：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；</li>
<li>使用方式不同：通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈区，只能在局部使用。</li>
<li>操作系统和编译器通过内存分配的位置可以区分两者，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面</li>
</ul>
<h4 id="74、指针加减计算要注意什么？"><a href="#74、指针加减计算要注意什么？" class="headerlink" title="74、指针加减计算要注意什么？"></a>74、指针加减计算要注意什么？</h4><ul>
<li>指针加减本质是对其所指地址的移动，移动的步长跟指针的类型是有关系的，因此在涉及到指针加减运算需要十分小心，加多或者减多都会导致指针指向一块未知的内存地址，如果再进行操作就会很危险</li>
<li>遇到指针的计算，需要明确的是指针每移动一位，它实际跨越的内存间隔是指针类型的长度，建议都转成10进制计算，计算结果除以类型长度取得结果</li>
</ul>
<h4 id="75、-怎样判断两个浮点数是否相等？"><a href="#75、-怎样判断两个浮点数是否相等？" class="headerlink" title="75、 怎样判断两个浮点数是否相等？"></a>75、 怎样判断两个浮点数是否相等？</h4><ul>
<li>对两个浮点数判断大小和是否相等不能直接用&#x3D;&#x3D;来判断，会出错</li>
<li>对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！浮点数与0的比较也应该注意,与浮点数的表示方式有关</li>
</ul>
<h4 id="76、方法调用的原理（栈，汇编）"><a href="#76、方法调用的原理（栈，汇编）" class="headerlink" title="76、方法调用的原理（栈，汇编）"></a>76、方法调用的原理（栈，汇编）</h4><ul>
<li><p>机器用栈来传递过程参数、存储返回信息、保存寄存器用于以后恢复，以及本地存储。而为单个过程分配的那部分栈称为帧栈；帧栈可以认为是程序栈的一段，它有两个端点，一个标识起始地址，一个标识着结束地址，两个指针结束地址指针esp，开始地址指针ebp;</p>
</li>
<li><p>这些栈帧对应一个过程，而且每一个栈指针+4的位置存储函数返回地址；每一个栈帧都建立在调用者的下方，当被调用者执行完毕时，这一段栈帧会被释放</p>
</li>
<li><p>由于栈帧是向地址递减的方向延伸，因此如果我们将栈指针减去一定的值，就相当于给栈帧分配了一定空间的内存。如果将栈指针加上一定的值，也就是向上移动，那么就相当于压缩了栈帧的长度，也就是说内存被释放</p>
</li>
<li><p>过程实现：</p>
<p>① 备份原来的帧指针，调整当前的栈帧指针到栈指针位置；</p>
<p>② 建立起来的栈帧就是为被调用者准备的，当被调用者使用栈帧时，需要给临时变量分配预留内存；</p>
<p>③ 使用建立好的栈帧，比如读取和写入，一般使用mov，push以及pop指令等等。</p>
<p>④ 恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了</p>
<p>⑤ 释放被调用者的栈帧，释放就意味着将栈指针加大，而具体的做法一般是直接将栈指针指向帧指针。</p>
<p>⑥ 恢复调用者的栈帧，恢复其实就是调整栈帧两端，使得当前栈帧的区域又回到了原始的位置。</p>
<p>⑦ 弹出返回地址，跳出当前过程，继续执行调用者的代码。</p>
</li>
</ul>
<h4 id="77、C-中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"><a href="#77、C-中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？" class="headerlink" title="77、C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"></a>77、C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？</h4><ul>
<li>指针参数传递本质上是值传递，它所传递的是一个地址值<ul>
<li>值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本</li>
<li>值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）</li>
</ul>
</li>
<li>引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址；被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。</li>
<li>引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量；而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用</li>
<li>从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。<ul>
<li>指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。</li>
<li>符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改</li>
</ul>
</li>
</ul>
<h4 id="78、类如何实现只能静态分配和只能动态分配"><a href="#78、类如何实现只能静态分配和只能动态分配" class="headerlink" title="78、类如何实现只能静态分配和只能动态分配"></a>78、类如何实现只能静态分配和只能动态分配</h4><ul>
<li>只能静态分配是把new、delete运算符重载为private属性。</li>
<li>只能动态分配是把构造、析构函数设为protected属性，再用子类来动态创建</li>
</ul>
<h4 id="79、如果想将某个类用作基类，为什么该类必须定义而非声明？"><a href="#79、如果想将某个类用作基类，为什么该类必须定义而非声明？" class="headerlink" title="79、如果想将某个类用作基类，为什么该类必须定义而非声明？"></a>79、如果想将某个类用作基类，为什么该类必须定义而非声明？</h4><ul>
<li>派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么。所以必须定义而非声明</li>
</ul>
<h4 id="80、-继承机制中对象之间如何转换？指针和引用之间如何转换？"><a href="#80、-继承机制中对象之间如何转换？指针和引用之间如何转换？" class="headerlink" title="80、 继承机制中对象之间如何转换？指针和引用之间如何转换？"></a>80、 继承机制中对象之间如何转换？指针和引用之间如何转换？</h4><ul>
<li>向上类型转换：将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会自动进行，而且向上类型转换是安全的。</li>
<li>向下类型转换：将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动态类型识别技术。RTTI技术，用dynamic_cast进行向下类型转换。</li>
</ul>
<h4 id="81、知道C-中的组合吗？它与继承相比有什么优缺点吗？"><a href="#81、知道C-中的组合吗？它与继承相比有什么优缺点吗？" class="headerlink" title="81、知道C++中的组合吗？它与继承相比有什么优缺点吗？"></a>81、知道C++中的组合吗？它与继承相比有什么优缺点吗？</h4><ul>
<li><p>组合也就是设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。</p>
</li>
<li><p>组合的优点：</p>
<p>①：当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的内部细节对当前对象时不可见的，而继承父类的内部细节对子类是可见的。</p>
<p>②：当前对象与包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码；而继承父类的方法做了修改的话，子类的方法必须做出相应的修改，子类与父类是一种高耦合，违背了面向对象思想。</p>
<p>③：当前对象可以在运行时动态的绑定所包含的对象。可以通过set方法给所包含对象赋值；而继承子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为。</p>
</li>
<li><p>组合的缺点：①：容易产生过多的对象。②：为了能组合多个对象，必须仔细对接口进行定义</p>
</li>
</ul>
<h4 id="82、什么是函数指针"><a href="#82、什么是函数指针" class="headerlink" title="82、什么是函数指针?"></a>82、什么是函数指针?</h4><ul>
<li>函数指针指向的是特殊的数据类型，函数的类型是由其返回的数据类型和其参数列表共同决定的，而函数的名称则不是其类型的一部分。一个具体函数的名字，如果后面不跟调用符号(即括号)，则该名字就是该函数的指针</li>
<li>函数指针的声明方法：int (*pf)(const int&amp;, const int&amp;); </li>
<li>为什么有函数指针：函数与数据项相似，函数也有地址，希望在同一个函数中通过使用相同的形参在不同的时间使用产生不同的效果。</li>
<li>一个函数名就是一个指针，它指向函数的代码。一个函数地址是该函数的进入点，也就是调用函数的地址。函数的调用可以通过函数名，也可以通过指向函数的指针来调用。函数指针还允许将函数作为变元传递给其他函数</li>
</ul>
<h4 id="83、说一说你理解的内存对齐以及原因"><a href="#83、说一说你理解的内存对齐以及原因" class="headerlink" title="83、说一说你理解的内存对齐以及原因"></a>83、说一说你理解的内存对齐以及原因</h4><ul>
<li><p><strong>分配内存的顺序是按照声明的顺序</strong>。</p>
</li>
<li><p>每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍空出内存，直到偏移量是整数倍为止。</p>
</li>
<li><p>最后整个结构体的大小必须是里面变量类型最大值的整数倍。</p>
</li>
<li><p>添加了#pragma pack(n)后规则就变成了下面这样：</p>
<p>1、 偏移量要是n和当前变量大小中较小值的整数倍</p>
<p>2、 整体大小要是n和最大变量大小中较小值的整数倍</p>
<p>3、 n值必须为1,2,4,8…，为其他值时就按照默认的分配规则</p>
</li>
</ul>
<h4 id="84、-结构体变量比较是否相等"><a href="#84、-结构体变量比较是否相等" class="headerlink" title="84、 结构体变量比较是否相等"></a>84、 结构体变量比较是否相等</h4><ul>
<li>看是否重载了 “&#x3D;&#x3D;” 操作符，元素的话，一个个比，指针直接比较，如果保存的是同一个实例地址，则(p1&#x3D;&#x3D;p2)为真</li>
</ul>
<h4 id="85、-函数调用过程栈的变化，返回值和参数变量哪个先入栈？"><a href="#85、-函数调用过程栈的变化，返回值和参数变量哪个先入栈？" class="headerlink" title="85、 函数调用过程栈的变化，返回值和参数变量哪个先入栈？"></a>85、 函数调用过程栈的变化，返回值和参数变量哪个先入栈？</h4><ul>
<li>调用者函数把被调函数所需要的参数按照与被调函数的形参顺序相反的顺序压入栈中,即:从右向左依次把被调函数所需要的参数压入栈;</li>
<li>调用者函数使用call指令调用被调函数,并把call指令的下一条指令的地址当成返回地址压入栈中</li>
<li>在被调函数中,被调函数会先保存调用者函数的栈底地址(push ebp),然后再保存调用者函数的栈顶地址</li>
<li>在被调函数中,从ebp的位置处开始存放被调函数中的局部变量和临时变量,并且这些变量的地址按照定义时的顺序依次减小,即:这些变量的地址是按照栈的延伸方向排列的,先定义的变量先入栈,后定义的变量后入栈</li>
</ul>
<h4 id="86、define、const、typedef、inline的使用方法？他们之间有什么区别？"><a href="#86、define、const、typedef、inline的使用方法？他们之间有什么区别？" class="headerlink" title="86、define、const、typedef、inline的使用方法？他们之间有什么区别？"></a>86、define、const、typedef、inline的使用方法？他们之间有什么区别？</h4><ul>
<li><p>const与#define的区别：</p>
<ul>
<li>const定义的常量是变量带类型，而#define定义的只是个常数不带类型；</li>
<li>define只在预处理阶段起作用，简单的文本替换，而const在编译、链接过程中起作用；</li>
<li>define只是简单的字符串替换没有类型检查。而const是有数据类型的，是要进行判断的，可以避免一些低级错误；</li>
<li>define预处理后，占用代码段空间，const占用数据段空间；</li>
<li>const不能重定义，而define可以通过#undef取消某个符号的定义，进行重定义；</li>
<li>define独特功能，比如可以用来防止文件重复引用。</li>
</ul>
</li>
<li><p>#define和别名typedef的区别:</p>
</li>
<li><p>执行时间不同，typedef在编译阶段有效，typedef有类型检查的功能；#define是宏定义，发生在预处理阶段，不进行类型检查；</p>
</li>
<li><p>功能差异，typedef用来定义类型的别名，定义与平台无关的数据类型，与struct的结合使用等。#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</p>
</li>
<li><p>作用域不同，#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。而typedef有自己的作用域。</p>
</li>
<li><p>define与inline的区别</p>
</li>
<li><p>#define是关键字，inline是函数；</p>
</li>
<li><p>宏定义在预处理阶段进行文本替换，inline函数在编译阶段进行替换；</p>
</li>
<li><p>inline函数有类型检查，相比宏定义比较安全；</p>
</li>
</ul>
<h4 id="87、你知道printf函数的实现原理是什么吗"><a href="#87、你知道printf函数的实现原理是什么吗" class="headerlink" title="87、你知道printf函数的实现原理是什么吗"></a>87、你知道printf函数的实现原理是什么吗</h4><ul>
<li>printf的第一个被找到的参数就是那个字符指针，就是被双引号括起来的那一部分，函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移量了</li>
</ul>
<h4 id="88、为什么模板类一般都是放在一个h文件中"><a href="#88、为什么模板类一般都是放在一个h文件中" class="headerlink" title="88、为什么模板类一般都是放在一个h文件中"></a>88、为什么模板类一般都是放在一个h文件中</h4><ul>
<li>模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。</li>
<li>在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查找（当遇到未决符号时它会寄希望于连接器）。这种模式在没有模板的情况下运行良好，但遇到模板时就不行，因为模板仅在需要的时候才会实例化出来</li>
</ul>
<h4 id="89、C-中类成员的访问权限和继承权限问题"><a href="#89、C-中类成员的访问权限和继承权限问题" class="headerlink" title="89、C++中类成员的访问权限和继承权限问题"></a>89、C++中类成员的访问权限和继承权限问题</h4><ul>
<li>三种访问权限public、private、protect</li>
<li>三种继承方式public、private、protect</li>
</ul>
<h4 id="90、cout和printf有什么区别？"><a href="#90、cout和printf有什么区别？" class="headerlink" title="90、cout和printf有什么区别？"></a>90、cout和printf有什么区别？</h4><ul>
<li>cout&lt;&lt;是一个函数，cout&lt;&lt;后可以跟不同的类型是因为cout&lt;&lt;已存在针对各种类型数据的重载，所以会自动识别数据的类型。输出过程会首先将输出字符放入缓冲区，然后输出到屏幕</li>
<li>printf是行缓冲输出，不是无缓冲输出</li>
</ul>
<h4 id="91、你知道重载运算符吗？"><a href="#91、你知道重载运算符吗？" class="headerlink" title="91、你知道重载运算符吗？"></a>91、你知道重载运算符吗？</h4><ul>
<li>只能重载已有的运算符，而无权发明新的运算符；对于一个重载的运算符，其优先级和结合律与内置类型一致才可以；不能改变运算符操作数个数；</li>
<li>两种重载方式：成员运算符和非成员运算符，成员运算符比非成员运算符少一个参数；下标运算符、箭头运算符必须是成员运算符；</li>
<li>引入运算符重载，是为了实现类的多态性；</li>
<li>当重载的运算符是成员函数时，this绑定到左侧运算符对象。成员运算符函数的参数数量比运算符对象的数量少一个；至少含有一个类类型的参数；</li>
<li>从参数的个数推断到底定义的是哪种运算符，当运算符既是一元运算符又是二元运算符（+，-，*，&amp;）；</li>
<li>下标运算符必须是成员函数，下标运算符通常以所访问元素的引用作为返回值，同时最好定义下标运算符的常量版本和非常量版本；</li>
<li>箭头运算符必须是类的成员，解引用通常也是类的成员；重载的箭头运算符必须返回类的指针</li>
</ul>
<h4 id="92、当程序中有函数重载时，函数的匹配原则和顺序是什么？"><a href="#92、当程序中有函数重载时，函数的匹配原则和顺序是什么？" class="headerlink" title="92、当程序中有函数重载时，函数的匹配原则和顺序是什么？"></a>92、当程序中有函数重载时，函数的匹配原则和顺序是什么？</h4><ol>
<li>名字查找</li>
<li>确定候选函数</li>
<li>寻找最佳匹配</li>
</ol>
<h4 id="93、定义和声明的区别"><a href="#93、定义和声明的区别" class="headerlink" title="93、定义和声明的区别"></a>93、定义和声明的区别</h4><ul>
<li><strong>如果是指变量的声明和定义：</strong> 从编译原理上来说，声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。而定义就是分配了内存。</li>
<li><strong>如果是指函数的声明和定义：</strong> 声明：一般在头文件里，对编译器说：这里我有一个函数叫function() 让编译器知道这个函数的存在。 定义：一般在源文件里，具体就是函数的实现过程 写明函数体。</li>
</ul>
<h4 id="94、全局变量和static变量的区别"><a href="#94、全局变量和static变量的区别" class="headerlink" title="94、全局变量和static变量的区别"></a>94、全局变量和static变量的区别</h4><ul>
<li>全局变量（外部变量）的说明之前再冠以static就构成了静态的全局变量。全局变量本身就是静态存储方式，静态全局变量也是静态存储方式。这两者在存储方式上并无不同</li>
<li>这两者的区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个原文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。</li>
<li>static全局变量与普通的全局变量的区别是<ul>
<li><strong>static全局变量只初始化一次，防止在其他文件单元被引用</strong>；</li>
<li>static函数与普通的函数作用域不同。仅在本文件中。只在当前源文件中使用的函数应该说明为内部函数（static），内部函数应该在当前源文件中说明和定义。</li>
<li>对于可在当前源文件以外使用的函数应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件。 static函数与普通函数最主要区别是static函数在内存中只有一份，普通静态函数在每个被调用中维持一份拷贝程序的局部变量存在于（堆栈）中，全局变量存在于（静态区）中，动态申请数据存在于（堆）</li>
</ul>
</li>
</ul>
<h4 id="95、-静态成员与普通成员的区别是什么？"><a href="#95、-静态成员与普通成员的区别是什么？" class="headerlink" title="95、 静态成员与普通成员的区别是什么？"></a>95、 静态成员与普通成员的区别是什么？</h4><ul>
<li>生命周期：静态成员变量从类被加载开始到类被卸载，一直存在；普通成员变量只有在类创建对象后才开始存在，对象结束，它的生命期结束；</li>
<li>共享方式：静态成员变量是全类共享；普通成员变量是每个对象单独享用的；</li>
<li>定义位置：普通成员变量存储在栈或堆中，而静态成员变量存储在静态全局区；</li>
<li>初始化位置：普通成员变量在类中初始化；静态成员变量在类外初始化；</li>
<li>默认实参：可以使用静态成员变量作为默认实参</li>
</ul>
<h4 id="96、说一下你理解的-ifdef-endif代表着什么？"><a href="#96、说一下你理解的-ifdef-endif代表着什么？" class="headerlink" title="96、说一下你理解的 ifdef endif代表着什么？"></a>96、说一下你理解的 ifdef endif代表着什么？</h4><ul>
<li>一般情况下，源程序中所有的行都参加编译。但是有时希望对其中一部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件，这就是“条件编译”。有时，希望当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。</li>
<li>它的作用是：当标识符已经被定义过(一般是用#define命令定义)，则对程序段1进行编译，否则编译程序段2。 其中#else部分也可以没有</li>
<li>在一个大的软件工程里面，可能会有多个文件同时包含一个头文件，当这些文件编译链接成一个可执行文件上时，就会出现大量“重定义”错误。在头文件中使用#define、#ifndef、#ifdef、#endif能避免头文件重定义</li>
</ul>
<h4 id="97、隐式转换，如何消除隐式转换？"><a href="#97、隐式转换，如何消除隐式转换？" class="headerlink" title="97、隐式转换，如何消除隐式转换？"></a>97、隐式转换，如何消除隐式转换？</h4><ul>
<li>C++的基本类型中并非完全的对立，部分数据类型之间是可以进行隐式转换的。所谓隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为。很多时候用户可能都不知道进行了哪些转换</li>
<li>C++面向对象的多态特性，就是通过父类的类型实现对子类的封装。通过隐式转换，你可以直接将一个子类的对象使用父类的类型进行返回。在比如，数值和布尔类型的转换，整数和浮点数的转换等。某些方面来说，隐式转换给C++程序开发者带来了不小的便捷。C++是一门强类型语言，类型的检查是非常严格的。</li>
<li>基本数据类型 基本数据类型的转换以取值范围的作为转换基础（保证精度不丢失）。隐式转换发生在从小-&gt;大的转换中。比如从char转换为int。从int-&gt;long。自定义对象 子类对象可以隐式的转换为父类对象</li>
<li>如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制。可以通过将构造函数声明为explicit加以制止隐式类型转换，关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit</li>
</ul>
<h4 id="98、C-如何处理多个异常的？"><a href="#98、C-如何处理多个异常的？" class="headerlink" title="98、C++如何处理多个异常的？"></a>98、C++如何处理多个异常的？</h4><ul>
<li>C++中的异常情况： <ul>
<li>语法错误（编译错误）：比如变量未定义、括号不匹配、关键字拼写错误等等编译器在编译时能发现的错误，这类错误可以及时被编译器发现，而且可以及时知道出错的位置及原因，方便改正。 </li>
<li><strong>运行时错误：比如数组下标越界、系统内存不足等等</strong>。这类错误不易被程序员发现，它能通过编译且能进入运行，但运行时会出错，导致程序崩溃。为了有效处理程序运行时错误，C++中引入异常处理机制来解决此问题。</li>
</ul>
</li>
<li>C++异常处理机制： <ul>
<li>异常处理基本思想：执行一个函数的过程中发现异常，可以不用在本函数内立即进行处理， 而是抛出该异常，让函数的调用者直接或间接处理这个问题。</li>
<li>C++异常处理机制由3个模块组成：try(检查)、throw(抛出)、catch(捕获) 抛出异常的语句格式为：throw 表达式；如果try块中程序段发现了异常则抛出异常。</li>
</ul>
</li>
</ul>
<h4 id="100、你知道strcpy和memcpy的区别是什么吗？"><a href="#100、你知道strcpy和memcpy的区别是什么吗？" class="headerlink" title="100、你知道strcpy和memcpy的区别是什么吗？"></a>100、你知道strcpy和memcpy的区别是什么吗？</h4><ul>
<li>复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。 </li>
<li>复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。 </li>
<li>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</li>
</ul>
<h4 id="101、程序在执行int-main-int-argc-char-argv-时的内存结构，你了解吗？"><a href="#101、程序在执行int-main-int-argc-char-argv-时的内存结构，你了解吗？" class="headerlink" title="101、程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？"></a>101、程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？</h4><ul>
<li>参数的含义是程序在命令行下运行的时候，需要输入argc 个参数，每个参数是以char 类型输入的，依次存在数组里面，数组是 argv[]，所有的参数在指针</li>
<li>char * 指向的内存中，数组的中元素的个数为 argc 个，第一个参数为程序的名称</li>
</ul>
<h4 id="102、volatile关键字的作用？"><a href="#102、volatile关键字的作用？" class="headerlink" title="102、volatile关键字的作用？"></a>102、volatile关键字的作用？</h4><ul>
<li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</li>
<li>声明时语法：int volatile vInt; 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。</li>
<li>volatile用在如下的几个地方：</li>
</ul>
<ol>
<li>中断服务程序中修改的供其它程序检测的变量需要加volatile；</li>
<li>多任务环境下各任务间共享的标志应该加volatile；</li>
<li>存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；</li>
</ol>
<h4 id="104、C-中标准库是什么？"><a href="#104、C-中标准库是什么？" class="headerlink" title="104、C++中标准库是什么？"></a>104、C++中标准库是什么？</h4><ul>
<li>C++ 标准库可以分为两部分：<ul>
<li>标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言</li>
<li>面向对象类库： 这个库是类及其相关函数的集合。</li>
</ul>
</li>
<li>输入&#x2F;输出 I&#x2F;O、字符串和字符处理、数学、时间、日期和本地化、动态分配、其他、宽字符函数</li>
<li>标准的 C++ I&#x2F;O 类、String 类、数值类、STL 容器类、STL 算法、STL 函数对象、STL 迭代器、STL 分配器、本地化库、异常处理类、杂项支持库</li>
</ul>
<h4 id="105、你知道const-char-与string之间的关系是什么吗？"><a href="#105、你知道const-char-与string之间的关系是什么吗？" class="headerlink" title="105、你知道const char* 与string之间的关系是什么吗？"></a>105、你知道const char* 与string之间的关系是什么吗？</h4><ul>
<li>string 是c++标准库里面其中一个，封装了对字符串的操作，实际操作过程我们可以用const char*给string类初始化</li>
</ul>
<h4 id="106、你什么情况用指针当参数，什么时候用引用，为什么？"><a href="#106、你什么情况用指针当参数，什么时候用引用，为什么？" class="headerlink" title="106、你什么情况用指针当参数，什么时候用引用，为什么？"></a>106、你什么情况用指针当参数，什么时候用引用，为什么？</h4><ul>
<li><p>使用引用参数的主要原因有两个：</p>
<ul>
<li>程序员能修改调用函数中的数据对象</li>
<li>通过传递引用而不是整个数据–对象，可以提高程序的运行速度</li>
</ul>
</li>
<li><p>一般的原则： 对于使用引用的值而不做修改的函数：</p>
<ul>
<li>如果数据对象很小，如内置数据类型或者小型结构，则按照值传递；</li>
<li>如果数据对象是数组，则使用指针（唯一的选择），并且指针声明为指向const的指针；</li>
<li>如果数据对象是较大的结构，则使用const指针或者引用，已提高程序的效率。这样可以节省结构所需的时间和空间；</li>
<li>如果数据对象是类对象，则使用const引用（传递类对象参数的标准方式是按照引用传递）；</li>
</ul>
</li>
<li><p>对于修改函数中数据的函数：</p>
<ul>
<li>如果数据是内置数据类型，则使用指针</li>
<li>如果数据对象是结构，则使用引用或者指针</li>
<li>如果数据是类对象，则使用引用</li>
</ul>
</li>
</ul>
<h4 id="107、你知道静态绑定和动态绑定吗？讲讲？"><a href="#107、你知道静态绑定和动态绑定吗？讲讲？" class="headerlink" title="107、你知道静态绑定和动态绑定吗？讲讲？"></a>107、你知道静态绑定和动态绑定吗？讲讲？</h4><ul>
<li><p>对象的静态类型：对象在声明时采用的类型。是在编译期确定的。</p>
</li>
<li><p>对象的动态类型：目前所指对象的类型。是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。</p>
</li>
<li><p>静态绑定：绑定的是对象的静态类型，某特性（比如函数依赖于对象的静态类型，发生在编译期。)</p>
</li>
<li><p>动态绑定：绑定的是对象的动态类型，某特性（比如函数依赖于对象的动态类型，发生在运行期。)</p>
</li>
</ul>
<h4 id="108、如何设计一个计算仅单个子类的对象个数？"><a href="#108、如何设计一个计算仅单个子类的对象个数？" class="headerlink" title="108、如何设计一个计算仅单个子类的对象个数？"></a>108、如何设计一个计算仅单个子类的对象个数？</h4><ul>
<li>为类设计一个static静态变量count作为计数器；</li>
<li>类定义结束后初始化count;</li>
<li>在构造函数中对count进行+1;</li>
<li>设计拷贝构造函数，在进行拷贝构造函数中进行count +1，操作；</li>
<li>设计复制构造函数，在进行复制函数中对count+1操作；</li>
<li>在析构函数中对count进行-1；</li>
</ul>
<h4 id="109、怎么快速定位错误出现的地方"><a href="#109、怎么快速定位错误出现的地方" class="headerlink" title="109、怎么快速定位错误出现的地方?"></a>109、怎么快速定位错误出现的地方?</h4><ul>
<li>如果是简单的错误，可以直接双击错误列表里的错误项或者生成输出的错误信息中带行号的地方就可以让编辑窗口定位到错误的位置上。</li>
<li>对于复杂的模板错误，最好使用生成输出窗口。</li>
<li>多数情况下出发错误的位置是最靠后的引用位置。如果这样确定不了错误，就需要先把自己写的代码里的引用位置找出来，然后逐个分析了。</li>
</ul>
<h4 id="110、成员初始化列表会在什么时候用到？它的调用过程是什么？"><a href="#110、成员初始化列表会在什么时候用到？它的调用过程是什么？" class="headerlink" title="110、成员初始化列表会在什么时候用到？它的调用过程是什么？"></a>110、成员初始化列表会在什么时候用到？它的调用过程是什么？</h4><ul>
<li>当初始化一个引用成员变量时；</li>
<li>初始化一个const成员变量时；</li>
<li>当调用一个基类的构造函数，而构造函数拥有一组参数时；</li>
<li>当调用一个成员类的构造函数，而他拥有一组参数；</li>
<li>编译器会一一操作初始化列表，以适当顺序在构造函数之内安插初始化操作，并且在任何显示用户代码前。list中的项目顺序是由类中的成员声明顺序决定的，不是初始化列表中的排列顺序决定的</li>
</ul>
<h4 id="111、在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？"><a href="#111、在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？" class="headerlink" title="111、在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？"></a>111、在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？</h4><ul>
<li><p>对比值传递，引用传参的好处：</p>
<ul>
<li>在函数内部可以对此参数进行修改</li>
<li>提高函数调用和运行的效率（因为没有了传值和生成副本的时间和空间消耗）</li>
</ul>
</li>
<li><p>如果函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过“形参&#x3D;实参”来对形参赋值达到传值目的，产生了一个实参的副本。即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。</p>
</li>
<li><p>使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用”*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰</p>
</li>
<li><p>用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。但是有以下的限制：</p>
<ul>
<li>不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁</li>
<li>不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak</li>
<li>可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性</li>
</ul>
</li>
</ul>
<h4 id="112、说一说strcpy、sprintf与memcpy这三个函数的不同之处"><a href="#112、说一说strcpy、sprintf与memcpy这三个函数的不同之处" class="headerlink" title="112、说一说strcpy、sprintf与memcpy这三个函数的不同之处"></a>112、说一说strcpy、sprintf与memcpy这三个函数的不同之处</h4><ul>
<li>操作对象不同</li>
</ul>
<p>① strcpy的两个操作对象均为字符串</p>
<p>② sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串</p>
<p>③ memcpy的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。</p>
<ul>
<li>执行效率不同</li>
</ul>
<p>memcpy最高，strcpy次之，sprintf的效率最低。</p>
<ul>
<li>实现功能不同</li>
</ul>
<p>① strcpy主要实现字符串变量间的拷贝</p>
<p>② sprintf主要实现其他数据类型格式到字符串的转化</p>
<p>③ memcpy主要是内存块间的拷贝</p>
<h4 id="114、你知道数组和指针的区别吗？"><a href="#114、你知道数组和指针的区别吗？" class="headerlink" title="114、你知道数组和指针的区别吗？"></a>114、你知道数组和指针的区别吗？</h4><ul>
<li>数组在内存中是连续存放的，开辟一块连续的内存空间；数组所占存储空间：sizeof（数组名）；数组大小：sizeof(数组名)&#x2F;sizeof(数组元素数据类型)；sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。</li>
<li>编译器为了简化对数组的支持，实际上是利用指针实现了对数组的支持。具体来说，就是将表达式中的数组元素引用转换为指针加偏移量的引用。</li>
<li>在向函数传递参数的时候，如果实参是一个数组，那用于接受的形参为对应的指针。也就是传递过去是数组的首地址而不是整个数组，能够提高效率；</li>
<li>在使用下标的时候，两者的用法相同，都是原地址加上下标值，不过数组的原地址就是数组首元素的地址是固定的，指针的原地址就不是固定的</li>
</ul>
<h4 id="115、如何阻止一个类被实例化？有哪些方法？"><a href="#115、如何阻止一个类被实例化？有哪些方法？" class="headerlink" title="115、如何阻止一个类被实例化？有哪些方法？"></a>115、如何阻止一个类被实例化？有哪些方法？</h4><ul>
<li>将类定义为抽象基类或者将构造函数声明为private；</li>
<li>不允许类外部创建类对象，只能在类内部创建对象</li>
</ul>
<h4 id="116、-如何禁止程序自动生成拷贝构造函数？"><a href="#116、-如何禁止程序自动生成拷贝构造函数？" class="headerlink" title="116、 如何禁止程序自动生成拷贝构造函数？"></a>116、 如何禁止程序自动生成拷贝构造函数？</h4><ul>
<li>手动去重写这两个函数，某些情况﻿下，为了避免调用拷贝构造函数和﻿拷贝赋值函数，我们需要将他们设置成private，防止被调用。</li>
<li>类的成员函数和friend函数还是可以调用private函数，如果这个private函数只声明不定义，则会产生一个连接错误；</li>
<li>针对上述两种情况，可以定一个base类，在base类中将拷贝构造函数和拷贝赋值函数设置成private,那么<strong>派生类中编译器将不会自动生成这两个函数，且由于base类中该函数是私有的，因此，派生类将阻止编译器执行相关的操作</strong>。</li>
</ul>
<h4 id="117、你知道Debug和Release的区别是什么吗？"><a href="#117、你知道Debug和Release的区别是什么吗？" class="headerlink" title="117、你知道Debug和Release的区别是什么吗？"></a>117、你知道Debug和Release的区别是什么吗？</h4><ul>
<li>调试版本，包含调试信息，所以容量比Release大很多，并且不进行任何优化（优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂），便于程序员调试。Debug模式下生成两个文件，除了.exe或.dll文件外，还有一个.pdb文件，该文件记录了代码中断点等调试信息；</li>
<li>发布版本，不对源代码进行调试，编译时对应用程序的速度进行优化，使得程序在代码大小和运行速度上都是最优的。（调试信息可在单独的PDB文件中生成）。Release模式下生成一个文件.exe或.dll文件。</li>
<li>实际上，Debug 和 Release 并没有本质的界限，他们只是一组编译选项的集合，编译器只是按照预定的选项行动。事实上，我们甚至可以修改这些选项，从而得到优化过的调试版本或是带跟踪语句的发布版本</li>
</ul>
<h4 id="118、main函数的返回值有什么值得考究之处吗？"><a href="#118、main函数的返回值有什么值得考究之处吗？" class="headerlink" title="118、main函数的返回值有什么值得考究之处吗？"></a>118、main函数的返回值有什么值得考究之处吗？</h4><ul>
<li>程序运行过程入口点main函数，main（）函数返回值类型必须是int，这样返回值才能传递给程序激活者（如操作系统）表示程序正常退出。</li>
<li>main（int args, char **argv） 参数的传递。参数的处理，一般会调用getopt（）函数处理，但实践中，这仅仅是一部分，不会经常用到的技能点。</li>
</ul>
<h4 id="120、strcpy函数和strncpy函数的区别？哪个函数更安全？"><a href="#120、strcpy函数和strncpy函数的区别？哪个函数更安全？" class="headerlink" title="120、strcpy函数和strncpy函数的区别？哪个函数更安全？"></a>120、strcpy函数和strncpy函数的区别？哪个函数更安全？</h4><ul>
<li>函数原型</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strcpy</span><span class="params">(<span class="type">char</span>* strDest, <span class="type">const</span> <span class="type">char</span>* strSrc)</span></span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>strcpy函数: 如果参数 dest 所指的内存空间不够大，可能会造成缓冲溢出(buffer Overflow)的错误情况，在编写程序时请特别留意，或者用strncpy()来取代；strncpy函数：用来复制源字符串的前n个字符，src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置n个字符。<ul>
<li>如果目标长&gt;指定长&gt;源长，则将源长全部拷贝到目标长，自动加上’\0’</li>
<li>如果指定长&lt;源长，则将源长中按指定长度拷贝到目标字符串，不包括’\0’</li>
<li>如果指定长&gt;目标长，运行时错误 ；</li>
</ul>
</li>
</ul>
<h4 id="121、static-cast比C语言中的转换强在哪里？"><a href="#121、static-cast比C语言中的转换强在哪里？" class="headerlink" title="121、static_cast比C语言中的转换强在哪里？"></a>121、static_cast比C语言中的转换强在哪里？</h4><ul>
<li>更加安全；</li>
<li>更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误；可清楚地辨别代码中每个显式的强制转；可读性更好，能体现程序员的意图</li>
</ul>
<h4 id="122、成员函数里memset-this-0-sizeof-this-会发生什么"><a href="#122、成员函数里memset-this-0-sizeof-this-会发生什么" class="headerlink" title="122、成员函数里memset(this,0,sizeof(*this))会发生什么"></a>122、成员函数里memset(this,0,sizeof(*this))会发生什么</h4><ul>
<li>有时候类里面定义了很多int,char,struct等c语言里的那些类型的变量，习惯在构造函数中将它们初始化为0，但是一句句的写太麻烦，所以直接就memset(this, 0, sizeof *this);将整个对象的内存全部置为0。对于这种情形可以很好的工作，但是下面几种情形是不可以这么使用的；<ul>
<li>类含有虚函数表：这么做会破坏虚函数表，后续对虚函数的调用都将出现异常；</li>
<li>类中含有C++类型的对象：例如，类中定义了一个list的对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，那么我们这么一做就破坏了list对象的内存</li>
</ul>
</li>
</ul>
<h4 id="123、你知道回调函数吗？它的作用？"><a href="#123、你知道回调函数吗？它的作用？" class="headerlink" title="123、你知道回调函数吗？它的作用？"></a>123、你知道回调函数吗？它的作用？</h4><ul>
<li>当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数；</li>
<li>回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。为此需要做三件事：1，声明；2，定义；3，设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用；</li>
<li>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数；</li>
<li>因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数</li>
</ul>
<h4 id="125、C-从代码到可执行程序经历了什么？"><a href="#125、C-从代码到可执行程序经历了什么？" class="headerlink" title="125、C++从代码到可执行程序经历了什么？"></a>125、C++从代码到可执行程序经历了什么？</h4><ul>
<li>预处理阶段：处理以 # 开头的预处理命令；删除所有的注释等</li>
<li>编译阶段：翻译成汇编文件（词法分析、语法分析、语义分析及优化）；</li>
<li>汇编阶段：将汇编文件翻译成可重定位目标文件（机器可以执行的指令(机器码文件)）；</li>
<li>链接阶段：将可重定位目标文件和 .o 等单独预编译好的目标文件（不同的源文件产生的目标文件）进行合并，得到最终的可执行目标文件</li>
</ul>
<h4 id="126、为什么友元函数（友元工厂）必须在类内部声明？"><a href="#126、为什么友元函数（友元工厂）必须在类内部声明？" class="headerlink" title="126、为什么友元函数（友元工厂）必须在类内部声明？"></a>126、为什么友元函数（友元工厂）必须在类内部声明？</h4><ul>
<li>因为编译器必须能够读取这个结构的声明以理解这个数据类型的大、行为等方面的所有规则。有一条规则在任何关系中都很重要，那就是谁可以访问我的私有部分。</li>
<li>友元函数不一定要在类内声明，普通的友元函数可以在类外声明，也可以在类内声明。只有友元工厂才必须用到类内声明友元函数。</li>
</ul>
<h4 id="127、友元函数和友元类的基本情况"><a href="#127、友元函数和友元类的基本情况" class="headerlink" title="127、友元函数和友元类的基本情况"></a>127、友元函数和友元类的基本情况</h4><ul>
<li>友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。</li>
<li>友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。</li>
<li>友元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中声明所有可以访问它的友元函数。一个函数可以是多个类的友元函数，但是每个类中都要声明这个函数。</li>
<li>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。但是另一个类里面也要相应的进行声明</li>
<li>使用友元类时注意：<ul>
<li>友元关系不能被继承。</li>
<li>友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。</li>
<li>友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</li>
</ul>
</li>
</ul>
<h4 id="129、动态编译与静态编译"><a href="#129、动态编译与静态编译" class="headerlink" title="129、动态编译与静态编译"></a>129、动态编译与静态编译</h4><ul>
<li><p>静态编译，编译器在编译可执行文件时，把需要用到的对应动态链接库中的部分提取出来，连接到可执行文件中去，使可执行文件在运行时不需要依赖于动态链接库；</p>
</li>
<li><p>动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库的命令。所以其优点一方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。缺点是哪怕是很简单的程序，只用到了链接库的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行</p>
</li>
</ul>
<h4 id="132、delete和delete-区别？"><a href="#132、delete和delete-区别？" class="headerlink" title="132、delete和delete[]区别？"></a>132、delete和delete[]区别？</h4><ul>
<li>delete只会调用一次析构函数。</li>
<li>delete[]会调用数组中每个元素的析构函数。</li>
</ul>
<h4 id="133、为什么不能把所有的函数写成内联函数"><a href="#133、为什么不能把所有的函数写成内联函数" class="headerlink" title="133、为什么不能把所有的函数写成内联函数?"></a>133、为什么不能把所有的函数写成内联函数?</h4><ul>
<li><p>内联函数以代码复杂为代价，它以省去函数调用的开销来提高执行效率。所以一方面如果内联函数体内代码执行时间相比函数调用开销较大，则没有太大的意义；另一方面每一处内联函数的调用都要复制代码，消耗更多的内存空间，因此以下情况不宜使用内联函数：</p>
</li>
<li><p>函数体内的代码比较长，将导致内存消耗代价</p>
</li>
<li><p>函数体内有循环，函数执行时间要比函数调用开销大</p>
</li>
</ul>
<h4 id="134、为什么C-没有垃圾回收机制？这点跟Java不太一样。"><a href="#134、为什么C-没有垃圾回收机制？这点跟Java不太一样。" class="headerlink" title="134、为什么C++没有垃圾回收机制？这点跟Java不太一样。"></a>134、为什么C++没有垃圾回收机制？这点跟Java不太一样。</h4><ul>
<li>首先，实现一个垃圾回收器会带来额外的空间和时间开销。你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要单独开辟一个线程在空闲的时候进行free操作。</li>
<li>垃圾回收会使得C++不适合进行很多底层的操作。</li>
</ul>
<h3 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++ 内存管理"></a>C++ 内存管理</h3><h4 id="1、类的对象存储空间？"><a href="#1、类的对象存储空间？" class="headerlink" title="1、类的对象存储空间？"></a>1、类的对象存储空间？</h4><ul>
<li>非静态成员的数据类型大小之和。</li>
<li>编译器加入的额外成员变量（如指向虚函数表的指针）。</li>
<li>为了边缘对齐优化加入的padding。</li>
</ul>
<p>空类(无非静态数据成员)的对象的size为1, 当作为基类时, size为0</p>
<h4 id="2、简要说明C-的内存分区（可以说一下你了解的C-得内存管理吗？）"><a href="#2、简要说明C-的内存分区（可以说一下你了解的C-得内存管理吗？）" class="headerlink" title="2、简要说明C++的内存分区（可以说一下你了解的C++得内存管理吗？）"></a>2、简要说明C++的内存分区（可以说一下你了解的C++得内存管理吗？）</h4><ul>
<li><p>C++中的内存分区，分别是堆、栈、自由存储区、全局&#x2F;静态存储区、常量存储区和代码区</p>
</li>
<li><p><strong>栈</strong>：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，<strong>效率很高，但是分配的内存容量有限</strong></p>
</li>
<li><p><strong>堆</strong>：就是那些由 <code>new</code>分配的内存块，他们的释放编译器不去管，由应用程序去控制，一般一个<code>new</code>就要对应一个 <code>delete</code>。如果程序员没有释放掉，会导致内存泄漏（操作系统最终释放）</p>
</li>
<li><p><strong>自由存储区</strong>：如果说堆是操作系统维护的一块内存，那么自由存储区就是C++中通过new和delete动态分配和释放对象的抽象概念。需要注意的是，<strong>自由存储区和堆比较像，但不等价</strong>。</p>
</li>
<li><p><strong>全局&#x2F;静态存储区</strong>：全局变量和静态变量被分配到同一块内存中，在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0</p>
</li>
<li><p><strong>常量存储区</strong>：这是一块比较特殊的存储区，这里面存放的是常量，不允许修改</p>
</li>
<li><p><strong>代码区</strong>：存放函数体的二进制代码</p>
</li>
</ul>
<h4 id="3、什么是内存池，如何实现"><a href="#3、什么是内存池，如何实现" class="headerlink" title="3、什么是内存池，如何实现"></a>3、什么是内存池，如何实现</h4><ul>
<li>内存池（Memory Pool） 是一种<strong>内存分配</strong>方式。直接使用new、malloc 等申请内存的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块， 若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。</li>
<li><strong>allocate 包装 malloc，deallocate包装free</strong>，一般是一次20*2个的申请，先用一半，留着一半；allocator就是用来分配内存的，最重要的两个函数是allocate和deallocate，就是用来申请内存和回收内存的；内部实现，目前的所有编译器都是直接调用的::operator new()和::operator delete()，和直接使用new运算符的效果是一样的</li>
<li><strong>其实最开始GC2.9之前</strong>，new和 operator new 的区别：new 是个运算符，编辑器会调用 operator new(0)，operator new()里面有调用malloc的操作，那同样的 operator delete()里面有调用的free的操作；GC2.9下的alloc函数的一个比较好的分配器的实现规则如下：<ul>
<li>维护一条0-15号的一共16条链表，其中 0 号表示8 bytes ，1 号表示 16 bytes，而15 号表示 16* 8 &#x3D; 128 bytes</li>
<li>如果在申请内存时，申请内存的大小并不是8的倍数，那就找刚好能满足内存大小的链表。比如想申请 12 个大小，那就按照 16 来处理，也就是找 1 号链表了；想申请 20 ，距离它最近的就是 24 了，那就找 2 号链表。只许比所要申请的内容大，不许小</li>
</ul>
</li>
</ul>
<h4 id="5、C-中类的数据成员和成员函数内存分布情况"><a href="#5、C-中类的数据成员和成员函数内存分布情况" class="headerlink" title="5、C++中类的数据成员和成员函数内存分布情况"></a>5、C++中类的数据成员和成员函数内存分布情况</h4><ul>
<li>C++类是由结构体发展得来的，所以他们的成员变量（C语言的结构体只有成员变量）的内存分配机制是一样的。类分为成员变量和成员函数</li>
<li>一个类对象的地址就是类所包含的这一片内存空间的首地址，这个首地址也就对应具体某一个成员变量的地址。（在定义类对象的同时这些成员变量也就被定义了）</li>
<li>对象的大小和对象中数据成员的大小是一致的，也就是说，成员函数不占用对象的内存。这是因为所有的函数都是存放在代码区的，不管是全局函数，还是成员函数。<ul>
<li><strong>静态成员函数与一般成员函数的唯一区别就是没有this指针</strong>，因此不能访问非静态数据成员。所有函数都存放在代码区，静态函数也不例外</li>
</ul>
</li>
</ul>
<h4 id="6、关于this指针你知道什么？全说出来"><a href="#6、关于this指针你知道什么？全说出来" class="headerlink" title="6、关于this指针你知道什么？全说出来"></a>6、关于this指针你知道什么？全说出来</h4><ul>
<li><p>this指针是类的指针，指向对象的首地址。</p>
</li>
<li><p>this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。</p>
</li>
<li><p>this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。</p>
</li>
<li><p>一个对象的this指针并不是对象本身的一部分，不会影响 sizeof(对象) 的结果。this作用域是在类内部，当在类的<strong>非静态成员函数</strong>中访问类的<strong>非静态成员</strong>的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。即使没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行</p>
</li>
<li><p><strong>this指针的使用</strong></p>
<ul>
<li>一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；</li>
<li>另外一种情况是当形参数与成员变量名相同时用于区分，如this-&gt;n &#x3D; n （不能写成n &#x3D; n）</li>
</ul>
</li>
<li><p><strong>类的this指针有以下特点</strong></p>
<ul>
<li><strong>this</strong>只能在成员函数中使用，全局函数、静态函数都不能使用this。实际上，<strong>传入参数为当前对象地址，成员函数第一个参数为</strong>为<strong>T * const this</strong></li>
<li><strong>this</strong>在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。</li>
<li>编译器通常会对this指针做一些优化，因此，this指针的传递效率比较高，例如VC通常是通过ecx（计数寄存器）传递this参数的</li>
</ul>
</li>
</ul>
<h4 id="7、A-this指针是什么时候创建的？"><a href="#7、A-this指针是什么时候创建的？" class="headerlink" title="7、A. this指针是什么时候创建的？"></a>7、A. this指针是什么时候创建的？</h4><ul>
<li>this在成员函数的开始执行前构造，在成员的执行结束后清除。</li>
<li>但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。采用TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址</li>
</ul>
<h4 id="B-this指针存放在何处？堆、栈、全局变量，还是其他？"><a href="#B-this指针存放在何处？堆、栈、全局变量，还是其他？" class="headerlink" title="B. this指针存放在何处？堆、栈、全局变量，还是其他？"></a>B. this指针存放在何处？堆、栈、全局变量，还是其他？</h4><p>this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的</p>
<h4 id="C-this指针是如何传递类中的函数的？this指针又是如何找到“类实例后函数的”？"><a href="#C-this指针是如何传递类中的函数的？this指针又是如何找到“类实例后函数的”？" class="headerlink" title="C. this指针是如何传递类中的函数的？this指针又是如何找到“类实例后函数的”？"></a>C. this指针是如何传递类中的函数的？this指针又是如何找到“类实例后函数的”？</h4><ul>
<li>大多数编译器通过ecx（寄数寄存器）寄存器传递this指针。事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。</li>
<li>在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的</li>
</ul>
<h4 id="D-this指针是如何访问类中的变量的？"><a href="#D-this指针是如何访问类中的变量的？" class="headerlink" title="D. this指针是如何访问类中的变量的？"></a>D. this指针是如何访问类中的变量的？</h4><ul>
<li>如果不是类，而是结构体的话，那么，如何通过结构指针来访问结构中的变量呢？</li>
<li>在C++中，类和结构是只有一个区别的：类的成员默认是private，而结构是public。</li>
<li>this是类的指针，如果换成结构体，那this就是结构的指针了。</li>
</ul>
<h4 id="E-我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？"><a href="#E-我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？" class="headerlink" title="E.我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？"></a>E.我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？</h4><ul>
<li><p><strong>this指针只有在成员函数中才有定义。</strong>因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里是可以知道this指针的位置的（可以通过&amp;this获得），也可以直接使用它</p>
</li>
<li><p>标准情况下this为右值，无法通过&amp;符号获取地址</p>
</li>
</ul>
<h4 id="F-每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？"><a href="#F-每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？" class="headerlink" title="F.每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？"></a>F.每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？</h4><ul>
<li>普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。</li>
<li>但是即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰。</li>
</ul>
<h4 id="8、-内存泄漏的后果？如何监测？解决方法？"><a href="#8、-内存泄漏的后果？如何监测？解决方法？" class="headerlink" title="8、 内存泄漏的后果？如何监测？解决方法？"></a>8、 内存泄漏的后果？如何监测？解决方法？</h4><ul>
<li>内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制；</li>
<li>只发生一次小的内存泄漏可能不被注意，但泄漏大量内存的程序将会出现各种证照：性能下降到内存逐渐用完，导致另一个程序失败；</li>
<li>如何排除：使用工具软件BoundsChecker，BoundsChecker是一个运行时错误检测工具，它主要定位程序运行时期发生的各种错误；</li>
<li>解决方法：智能指针</li>
<li>检查、定位内存泄漏：检查方法：在main函数最后面一行，加上一句_CrtDumpMemoryLeaks()。调试程序，自然关闭程序让其退出，查看输出</li>
</ul>
<h4 id="9、在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？"><a href="#9、在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？" class="headerlink" title="9、在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"></a>9、在成员函数中调用delete this会出现什么问题？对象还可以使用吗？</h4><ul>
<li>在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。</li>
<li>当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。</li>
</ul>
<h4 id="10、为什么是不可预期的问题？"><a href="#10、为什么是不可预期的问题？" class="headerlink" title="10、为什么是不可预期的问题？"></a>10、为什么是不可预期的问题？</h4><ul>
<li>delete this之后释放了类对象的内存空间，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题；这个问题牵涉到操作系统的内存管理策略。</li>
<li>delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃</li>
</ul>
<h4 id="11、-如果在类的析构函数中调用delete-this，会发生什么？"><a href="#11、-如果在类的析构函数中调用delete-this，会发生什么？" class="headerlink" title="11、 如果在类的析构函数中调用delete this，会发生什么？"></a>11、 如果在类的析构函数中调用delete this，会发生什么？</h4><ul>
<li>会导致堆栈溢出。delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”</li>
<li>delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃</li>
</ul>
<h4 id="12、你知道空类的大小是多少吗？"><a href="#12、你知道空类的大小是多少吗？" class="headerlink" title="12、你知道空类的大小是多少吗？"></a>12、你知道空类的大小是多少吗？</h4><ul>
<li><p>C++空类的大小不为0，不同编译器设置不一样，vs设置为1；</p>
</li>
<li><p>C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址；</p>
</li>
<li><p>带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定；</p>
</li>
<li><p>C++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配一个字节大小，这样便保证了每个实例均有独一无二的内存地址</p>
</li>
<li><p>当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化；</p>
</li>
<li><p>空类的实例大小就是类的大小，所以sizeof(a)&#x3D;1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节；静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小</p>
</li>
</ul>
<h4 id="14、this指针调用成员变量时，堆栈会发生什么变化？"><a href="#14、this指针调用成员变量时，堆栈会发生什么变化？" class="headerlink" title="14、this指针调用成员变量时，堆栈会发生什么变化？"></a>14、this指针调用成员变量时，堆栈会发生什么变化？</h4><ul>
<li>当在类的非静态成员函数访问类的非静态成员时，编译器会自动将对象的地址传给作为隐含参数传递给函数，这个隐含参数就是this指针。</li>
<li>即使没有写this指针，编译器在链接时也会加上this的，对各成员的访问都是通过this的。</li>
<li>建立了类的多个对象时，在调用类的成员函数时，你并不知道具体是哪个对象在调用，此时你可以通过查看this指针来查看具体是哪个对象在调用。<strong>This指针首先入栈，然后成员函数的参数从右向左进行入栈，最后函数返回地址入栈。</strong></li>
</ul>
<h4 id="15、类对象的大小受哪些因素影响？"><a href="#15、类对象的大小受哪些因素影响？" class="headerlink" title="15、类对象的大小受哪些因素影响？"></a>15、类对象的大小受哪些因素影响？</h4><ul>
<li>类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；</li>
<li>内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；</li>
<li>虚函数的话，会在类对象插入vptr指针，加上指针大小；</li>
<li>当该类是某类的派生类，那么派<strong>生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展</strong>。</li>
</ul>
<h3 id="C-11新标准"><a href="#C-11新标准" class="headerlink" title="C++11新标准"></a>C++11新标准</h3><h4 id="1、C-11有哪些新特性？"><a href="#1、C-11有哪些新特性？" class="headerlink" title="1、C++ 11有哪些新特性？"></a>1、C++ 11有哪些新特性？</h4><ul>
<li>nullptr替代 NULL</li>
<li>引入了 auto 和 decltype 这两个关键字实现了类型推导</li>
<li>基于范围的 for 循环for(auto&amp; i : res){}</li>
<li>类和结构体的中初始化列表</li>
<li>Lambda 表达式（匿名函数）</li>
<li>std::forward_list（单向链表）</li>
<li>右值引用和move语义</li>
</ul>
<h4 id="2、auto、decltype和decltype-auto-的用法"><a href="#2、auto、decltype和decltype-auto-的用法" class="headerlink" title="2、auto、decltype和decltype(auto)的用法"></a>2、auto、decltype和decltype(auto)的用法</h4><ul>
<li><p>C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应某种特定的类型说明符(例如 int)不同，<strong>auto 让编译器通过初始值来进行类型推演。从而获得定义变量的类型，所以说 auto 定义的变量必须有初始值。</strong></p>
</li>
<li><p>decltype：希望从表达式中推断出要定义变量的类型，但却不想用表达式的值去初始化变量。<strong>还有可能是函数的返回类型为某表达式的值类型。在这些时候auto显得就无力了，所以C++11又引入了第二种类型说明符decltype，</strong>它的作用是选择并返回操作数的数据类型。在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值。</p>
</li>
<li><p>decltype(auto)：decltype(auto)是C++14新增的类型指示符，可以用来声明变量以及指示函数返回类型。在使用时，会将“&#x3D;”号左边的表达式替换掉auto，再根据decltype的语法规则来确定类型</p>
</li>
</ul>
<h4 id="3、C-中NULL和nullptr区别"><a href="#3、C-中NULL和nullptr区别" class="headerlink" title="3、C++中NULL和nullptr区别"></a>3、C++中NULL和nullptr区别</h4><ul>
<li><p>为了与C语言进行兼容而定义，NULL来自C语言，一般由宏定义实现，而 nullptr 则是C++11的新增关键字。<strong>在C语言中，NULL被定义为(void*)0,而在C++语言中，NULL则被定义为整数0</strong>。在C++中指针必须有明确的类型定义。但是将NULL定义为0带来的另一个问题是无法与整数的0区分，因为C++中允许有函数重载</p>
</li>
<li><p>nullptr在C++11被引入用于解决这一问题，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。通过模板类和运算符重载的方式来对不同类型的指针进行实例化从而解决了(void*)指针带来参数类型不明的问题，<strong>另外由于nullptr是明确的指针类型，所以不会与整形变量相混淆。</strong></p>
</li>
<li><p>但nullptr仍然存在一定问题：存在对不同指针类型的函数重载，此时如果传入nullptr指针则仍然存在无法区分应实际调用哪个函数，这种情况下必须显示的指明参数类型</p>
</li>
</ul>
<h4 id="4、智能指针的原理、常用的智能指针及实现"><a href="#4、智能指针的原理、常用的智能指针及实现" class="headerlink" title="4、智能指针的原理、常用的智能指针及实现"></a>4、智能指针的原理、常用的智能指针及实现</h4><ul>
<li><strong>原理</strong>：智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源</li>
<li><strong>常用的智能指针</strong>：<ul>
<li>shared_ptr：采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。<ul>
<li>智能指针将一个计数器与类指向的对象相关联，引用计数器跟踪共有多少个类对象共享同一指针</li>
<li>每次创建类的新对象时，初始化指针并将引用计数置为1</li>
<li>当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数</li>
<li>对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数</li>
<li>调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）</li>
</ul>
</li>
<li><strong>unique_ptr</strong>：unique_ptr采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源。<ul>
<li>转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；所以unique_ptr不支持普通的拷贝和赋值操作，不能用在STL标准容器中；局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）；</li>
<li>如果你拷贝一个unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃。</li>
</ul>
</li>
<li><strong>weak_ptr</strong>：弱引用。 引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。需要使用weak_ptr打破环形引用。weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。</li>
<li><strong>auto_ptr</strong>：主要是为了解决“有异常抛出时发生内存泄漏”的问题 。因为发生异常而无法正常释放内存。<ul>
<li>auto_ptr有拷贝语义，拷贝后源对象变得无效，这可能引发很严重的问题；而unique_ptr则无拷贝语义，但提供了移动语义，这样的错误不再可能发生，因为很明显必须使用std::move()进行转移。</li>
<li>auto_ptr不支持拷贝和赋值操作，不能用在STL标准容器中。STL容器中的元素经常要支持拷贝、赋值操作，在这过程中auto_ptr会传递所有权，所以不能在STL中使用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5、说一说你了解的关于lambda函数的全部知识"><a href="#5、说一说你了解的关于lambda函数的全部知识" class="headerlink" title="5、说一说你了解的关于lambda函数的全部知识"></a>5、说一说你了解的关于lambda函数的全部知识</h4><ul>
<li>利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象；</li>
<li>每当定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符），称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，其实一个右值。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为lambda捕捉块。</li>
<li>lambda表达式的语法定义如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture] （parameters） <span class="keyword">mutable</span> -&gt;<span class="keyword">return</span>-type &#123;statement&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>lambda必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体；</li>
</ul>
<h4 id="7、说说你了解的auto-ptr作用"><a href="#7、说说你了解的auto-ptr作用" class="headerlink" title="7、说说你了解的auto_ptr作用"></a>7、说说你了解的auto_ptr作用</h4><ul>
<li>auto_ptr的出现，主要是为了解决“有异常抛出时发生内存泄漏”的问题；抛出异常，将导致指针p所指向的空间得不到释放而导致内存泄漏；</li>
<li>auto_ptr构造时取得某个对象的控制权，在析构时释放该对象。实际上是创建一个auto_ptr<Type>类型的局部对象，该局部对象析构时，会将自身所拥有的指针空间释放，所以不会有内存泄漏；</li>
<li>auto_ptr的构造函数是explicit，阻止了一般指针隐式转换为 auto_ptr的构造，所以不能直接将一般类型的指针赋值给auto_ptr类型的对象，必须用auto_ptr的构造函数创建对象；</li>
<li>由于auto_ptr对象析构时会删除它所拥有的指针，所以使用时避免多个auto_ptr对象管理同一个指针；</li>
</ul>
<h4 id="8、智能指针的循环引用"><a href="#8、智能指针的循环引用" class="headerlink" title="8、智能指针的循环引用"></a>8、智能指针的循环引用</h4><ul>
<li>循环引用是指使用多个智能指针share_ptr时，出现了指针之间相互指向，从而形成环的情况，有点类似于死锁的情况，这种情况下，智能指针往往不能正常调用对象的析构函数，从而造成内存泄漏。</li>
<li>只有当引用计数减减之后等于0，析构时才会释放对象，sp1等着sp2先释放，sp2等着sp1先释放,二者互不相让，导致最终都没能释放，内存泄漏。</li>
<li>在实际编程过程中，应该尽量避免出现智能指针之前相互指向的情况，如果不可避免，可以使用使用弱指针——weak_ptr，它不增加引用计数，只要出了作用域就会自动析构。</li>
</ul>
<h4 id="9、手写实现智能指针类需要实现哪些函数？"><a href="#9、手写实现智能指针类需要实现哪些函数？" class="headerlink" title="9、手写实现智能指针类需要实现哪些函数？"></a>9、手写实现智能指针类需要实现哪些函数？</h4><ul>
<li>智能指针是一个数据类型，一般用模板实现，模拟指针行为的同时还提供自动垃圾回收机制。它会自动记录SmartPointer&lt;T*&gt;对象的引用计数，一旦T类型对象的引用计数为0，就释放该对象</li>
<li>除了指针对象外，还需要一个引用计数的指针设定对象的值，并将引用计数计为1，需要一个构造函数。新增对象还需要一个构造函数，析构函数负责引用计数减少和释放内存。</li>
<li>通过覆写赋值运算符，才能将一个旧的智能指针赋值给另一个指针，同时旧的引用计数减1，新的引用计数加1</li>
<li>一个构造函数、拷贝构造函数、复制构造函数、析构函数、移动函数</li>
</ul>
<h3 id="C-之STL模板库"><a href="#C-之STL模板库" class="headerlink" title="C++之STL模板库"></a>C++之STL模板库</h3><h4 id="1、什么是STL？"><a href="#1、什么是STL？" class="headerlink" title="1、什么是STL？"></a>1、什么是STL？</h4><p>C++ STL从广义来讲包括了三类：算法，容器和迭代器。</p>
<ul>
<li>算法包括排序，复制等常用算法，以及不同容器特定的算法。</li>
<li>容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。</li>
<li>迭代器就是在不暴露容器内部结构的情况下对容器的遍历</li>
</ul>
<h4 id="2、解释一下什么是trivial-destructor"><a href="#2、解释一下什么是trivial-destructor" class="headerlink" title="2、解释一下什么是trivial destructor"></a>2、解释一下什么是trivial destructor</h4><ul>
<li>“trivial destructor”一般是指用户没有自定义析构函数，而由系统生成的</li>
<li>反之，用户自定义了析构函数，则称之为“non-trivial destructor”，这种析构函数<strong>如果申请了新的空间一定要显式的释放，否则会造成内存泄露</strong></li>
<li>对于trivial destructor，如果每次都进行调用，显然对效率是一种伤害，首先利用value_type()获取所指对象的型别，再利用__type_traits<T>判断该型别的析构函数是否trivial，若是(__true_type)，则什么也不做，若为(__false_type)，则去调用destory()函数。</li>
</ul>
<h4 id="3、使用智能指针管理内存资源，RAII是怎么回事？"><a href="#3、使用智能指针管理内存资源，RAII是怎么回事？" class="headerlink" title="3、使用智能指针管理内存资源，RAII是怎么回事？"></a>3、使用智能指针管理内存资源，RAII是怎么回事？</h4><ul>
<li>RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们<strong>应该使用类来管理资源，将资源和对象的生命周期绑定</strong>。</li>
<li><strong>智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现</strong>，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。有了智能指针，代码中几乎不需要再出现delete了</li>
</ul>
<h4 id="4、迭代器：-it、it-哪个好，为什么"><a href="#4、迭代器：-it、it-哪个好，为什么" class="headerlink" title="4、迭代器：++it、it++哪个好，为什么"></a>4、迭代器：++it、it++哪个好，为什么</h4><ul>
<li>前置返回一个引用，后置返回一个对象</li>
<li>前置不会产生临时对象，后置必须产生临时对象，临时对象会导致效率降低</li>
</ul>
<h4 id="5、说一下C-左值引用和右值引用"><a href="#5、说一下C-左值引用和右值引用" class="headerlink" title="5、说一下C++左值引用和右值引用"></a>5、说一下C++左值引用和右值引用</h4><ul>
<li><p>左值引用：传统的C++中引用被称为左值引用</p>
</li>
<li><p>右值引用：C++11中增加了右值引用，右值引用关联到右值时，右值被存储到特定位置，右值引用指向该特定位置，也就是说，右值虽然无法获取地址，但是右值引用是可以获取地址的，该地址表示临时对象的存储位置</p>
</li>
<li><p>C++11正是通过引入右值引用来优化性能，具体来说是<strong>通过移动语义来避免无谓拷贝的问题</strong>，通过<strong>move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去</strong>，通过<strong>完美转发来解决不能按照参数实际类型来转发的问题</strong>（同时，完美转发获得的一个好处是可以实现移动语义）</p>
</li>
<li><p>在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。举个例子，int a &#x3D; b+c, a 就是左值，其有变量名为a，通过&amp;a可以获取该变量的地址；表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。</p>
<ul>
<li>纯右值的概念指的是临时变量和不跟对象关联的字面量值；</li>
<li>将亡值则是C++11新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象（移为他用），比如返回右值引用T&amp;&amp;的函数返回值、std::move的返回值，或者转换为T&amp;&amp;的类型转换函数的返回值。将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。</li>
</ul>
</li>
<li><p>左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而<strong>右值引用则是不具名（匿名）变量的别名</strong>。左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值。</p>
</li>
<li><p>右值引用的特点：</p>
<ul>
<li>通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去</li>
<li>右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值</li>
<li>T&amp;&amp; t在发生自动类型推断的时候，它是左值还是右值取决于它的初始化。</li>
</ul>
</li>
</ul>
<h4 id="6、STL中hashtable的实现？"><a href="#6、STL中hashtable的实现？" class="headerlink" title="6、STL中hashtable的实现？"></a>6、STL中hashtable的实现？</h4><ul>
<li>STL中的hashtable使用的是<strong>开链法</strong>解决hash冲突问题</li>
<li>hashtable中的bucket所维护的list既不是list也不是slist，而是其自己定义的由hashtable_node数据结构组成的linked-list，而<strong>bucket聚合体本身使用vector进行存储</strong>。<strong>hashtable的迭代器只提供前进操作，不提供后退操作</strong></li>
</ul>
<h4 id="7、简单说一下traits技法"><a href="#7、简单说一下traits技法" class="headerlink" title="7、简单说一下traits技法"></a>7、简单说一下traits技法</h4><ul>
<li><p>traits技法利用“内嵌型别“的编程技巧与<strong>编译器的template参数推导功能</strong>，增强C++未能提供的关于型别认证方面的能力。常用的有iterator_traits和type_traits。</p>
</li>
<li><p><strong>iterator_traits</strong>被称为<strong>特性萃取机</strong>，能够方便的让外界获取以下5种型别：</p>
<ul>
<li>value_type：迭代器所指对象的型别</li>
<li>difference_type：两个迭代器之间的距离</li>
<li>pointer：迭代器所指向的型别</li>
<li>reference：迭代器所引用的型别</li>
<li>iterator_category：三两句说不清楚，建议看书</li>
</ul>
</li>
<li><p><strong>type_traits</strong>：关注的是型别的<strong>特性</strong>，例如这个型别是否具备non-trivial defalt ctor（默认构造函数）、non-trivial copy ctor（拷贝构造函数）、non-trivial assignment operator（赋值运算符） 和non-trivial dtor（析构函数），如果答案是否定的，可以采取直接操作内存的方式提高效率</p>
</li>
</ul>
<h4 id="8、STL的两级空间配置器"><a href="#8、STL的两级空间配置器" class="headerlink" title="8、STL的两级空间配置器"></a>8、STL的两级空间配置器</h4><ul>
<li><p>为什么需要二级空间配置器？</p>
<ul>
<li>动态开辟内存时，要在堆上申请，但若需要频繁的在堆开辟释放内存，则就会<strong>在堆上造成很多外部碎片</strong>，浪费了内存空间；每次都要进行调用<strong>malloc、free</strong>函数等操作，使空间就会增加一些附加信息，降低了空间利用率；随着外部碎片增多，内存分配器在找不到合适内存情况下需要合并空闲块，浪费了时间，大大降低了效率。</li>
<li>于是就设置了二级空间配置器，<strong>当开辟内存&lt;&#x3D;128bytes时，即视为开辟小块内存，则调用二级空间配置器。</strong>关于STL中一级空间配置器和二级空间配置器的选择上，一般默认<strong>选择的为二级空间配置器</strong>。 如果大于128字节再转去一级配置器器。</li>
</ul>
</li>
<li><p>一级配置器：<strong>一级空间配置器</strong>中重要的函数就是allocate、deallocate、reallocate 。 一级空间配置器是以malloc()，free()，realloc()等C函数执行实际的内存配置 。大致过程是：</p>
<p>1、直接allocate分配内存，其实就是malloc来分配内存，成功则直接返回，失败就调用处理函数</p>
<p>2、如果用户自定义了内存分配失败的处理函数就调用，没有的话就返回异常</p>
<p>3、如果自定义了处理函数就进行处理，完事再继续分配试试</p>
</li>
<li><p>二级配置器：首先判断落在第几号链表，定位到了，先判断链表是不是空，如果是空就需要充值，（调节到8的倍数，默认一次申请20个区块，当然了也要判断20个是不是能够申请到，如果只申请到一个那就直接返回好了，不止一个的话，把第2到第n个挨个挂到当前链表上，第一个返回回去给容器用,n是不大于20的，当然了如果不在1-20之间，那就是内存碎片了，那就先把碎片挂到某一条链表上，然后再重新malloc了，malloc 2*20个块）去内存池去拿或者重新分配</p>
</li>
</ul>
<h4 id="9、-vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"><a href="#9、-vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素" class="headerlink" title="9、 vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"></a>9、 vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素</h4><ul>
<li><p>vector的随机访问效率高，但在插入和删除时（不包括尾部）需要挪动数据，不易操作。</p>
</li>
<li><p>list的访问要遍历整个链表，它的随机访问效率低。但对数据的插入和删除操作等都比较方便，改变指针的指向即可。</p>
</li>
<li><p>从遍历上来说，list是单向的，vector是双向的。</p>
</li>
<li><p>vector中的迭代器在使用后就失效了，而list的迭代器在使用之后还可以继续使用。</p>
</li>
<li><p>int mySize &#x3D; vec.size();vec.at(mySize -2); list不提供随机访问，所以不能用下标直接访问到某个位置的元素，要访问list里的元素只能遍历，不过你要是只需要访问list的最后N个元素的话，可以用反向迭代器来遍历</p>
</li>
</ul>
<h4 id="10、STL-中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"><a href="#10、STL-中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？" class="headerlink" title="10、STL 中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"></a>10、STL 中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？</h4><ul>
<li>size()函数返回的是已用空间大小，capacity()返回的是总空间大小，capacity()-size()则是剩余的可用空间大小。当size()和capacity()相等，说明vector目前的空间已被用完，如果再添加新元素，则会引起vector空间的动态增长。</li>
<li>由于动态增长会引起重新分配内存空间、拷贝原空间、释放原空间，这些过程会降低程序效率。因此，可以使用reserve(n)预先分配一块较大的指定大小的内存空间，这样当指定大小的内存空间未使用完时，是不会重新分配内存空间的，这样便提升了效率。只有当n&gt;capacity()时，调用reserve(n)才会改变vector容量。</li>
<li>resize()成员函数改变元素的数目，至于空间的的变化需要看具体情况去分析</li>
<li>不同的编译器，vector有不同的扩容大小。在vs下是1.5倍，在GCC下是2倍；空间和时间的权衡。简单来说， 空间分配的多，平摊时间复杂度低，但浪费空间也多。使用k&#x3D;2增长因子的问题在于，每次扩展的新尺寸必然刚好大于之前分配的总和，也就是说，之前分配的内存空间不可能被使用。这样对内存不友好，最好把增长因子设为(1, 2)，也就是1-2之间的某个数值。对比可以发现采用采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容</li>
</ul>
<h4 id="11、Vector如何释放空间"><a href="#11、Vector如何释放空间" class="headerlink" title="11、Vector如何释放空间?"></a>11、Vector如何释放空间?</h4><ul>
<li>由于vector的内存占用空间只增不减，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。所有内存空间是在vector析构时候才能被系统回收。empty()用来检测容器是否为空的，clear()可以清空所有元素。<strong>但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。</strong></li>
<li>如果需要空间动态缩小，可以考虑使用deque。如果vector，可以用swap()来帮助你释放内存。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>(Vec).<span class="built_in">swap</span>(Vec); <span class="comment">//将Vec的内存清除； </span></span><br><span class="line"><span class="built_in">vector</span>().<span class="built_in">swap</span>(Vec); <span class="comment">//清空Vec的内存；</span></span><br></pre></td></tr></table></figure>

<h4 id="12、容器内部删除一个元素"><a href="#12、容器内部删除一个元素" class="headerlink" title="12、容器内部删除一个元素"></a>12、容器内部删除一个元素</h4><ul>
<li>顺序容器（序列式容器，比如vector、deque）<ul>
<li>erase迭代器不仅使所指向被删除的迭代器失效，而且使被删元素之后的所有迭代器失效(list除外)，所以不能使用erase(it++)的方式，但是erase的返回值是下一个有效迭代器；</li>
</ul>
</li>
<li>关联容器(关联式容器，比如map、set、multimap、multiset等)<ul>
<li>erase迭代器只是被删除元素的迭代器失效，但是返回值是void，所以要采用erase(it++)的方式删除迭代器；</li>
</ul>
</li>
</ul>
<h4 id="13、STL迭代器如何实现"><a href="#13、STL迭代器如何实现" class="headerlink" title="13、STL迭代器如何实现"></a>13、STL迭代器如何实现</h4><ul>
<li>迭代器是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器，除此之外，STL中迭代器一个最重要的作用就是作为容器与STL算法的粘合剂。</li>
<li>迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器内部必须保存一个与容器相关联的指针，然后重载各种运算操作来遍历，其中最重要的是*运算符与-&gt;运算符，以及++、–等可能需要重载的运算符重载。这和C++中的智能指针很像，智能指针也是将一个指针封装，然后通过引用计数或是其他方法完成自动释放内存的功能。</li>
<li>最常用的迭代器的相应型别有五种：value type、difference type、pointer、reference、iterator catagoly</li>
</ul>
<h4 id="14、map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？-为什么使用红黑树？"><a href="#14、map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？-为什么使用红黑树？" class="headerlink" title="14、map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？"></a>14、map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？</h4><ul>
<li>他们的底层都是以红黑树的结构实现，因此插入删除等操作都在O(logn）时间内完成，因此可以完成高效的插入删除；</li>
<li>定义了一个模版参数，如果它是key那么它就是set，如果它是map，那么它就是map；底层是红黑树，实现map的红黑树的节点数据类型是key+value，而实现set的节点数据类型是value</li>
<li>因为map和set要求是自动排序的，红黑树能够实现这一功能，而且时间复杂度比较低。</li>
</ul>
<h4 id="15、如何在共享内存上使用STL标准库？"><a href="#15、如何在共享内存上使用STL标准库？" class="headerlink" title="15、如何在共享内存上使用STL标准库？"></a>15、如何在共享内存上使用STL标准库？</h4><ul>
<li><p>想像一下把STL容器，例如map, vector, list等等，放入共享内存中，IPC一旦有了这些强大的通用数据结构做辅助，无疑进程间通信的能力一下子强大了很多。没必要再为共享内存设计其他额外的数据结构，另外，STL的高度可扩展性将为IPC所驱使。STL容器被良好的封装，默认情况下有它们自己的内存管理方案。</p>
</li>
<li><p>当一个元素被插入到一个STL列表(list)中时，列表容器自动为其分配内存，保存数据。考虑到要将STL容器放到共享内存中，而容器却自己在堆上分配内存。一个最笨拙的办法是在堆上构造STL容器，然后把容器复制到共享内存，并且确保所有容器的内部分配的内存指向共享内存中的相应区域，这基本是个不可能完成的任务。</p>
</li>
<li><p>假设进程A在共享内存中放入了数个容器，进程B如何找到这些容器呢？</p>
<p>一个方法就是进程A把容器放在共享内存中的确定地址上（fixed offsets），则进程B可以从该已知地址上获取容器。另外一个改进点的办法是，进程A先在共享内存某块确定地址上放置一个map容器，然后进程A再创建其他容器，然后给其取个名字和地址一并保存到这个map容器里；进程B知道如何获取该保存了地址映射的map容器，然后同样再根据名字取得其他容器的地址</p>
</li>
</ul>
<h4 id="16、map插入方式有哪几种？"><a href="#16、map插入方式有哪几种？" class="headerlink" title="16、map插入方式有哪几种？"></a>16、map插入方式有哪几种？</h4><ul>
<li>用insert函数插入pair数据</li>
<li>用insert函数插入value_type数据</li>
<li>在insert函数中使用make_pair()函数</li>
<li>用数组方式插入数据</li>
</ul>
<h4 id="17、STL中unordered-map-hash-map-和map的区别，hash-map如何解决冲突以及扩容"><a href="#17、STL中unordered-map-hash-map-和map的区别，hash-map如何解决冲突以及扩容" class="headerlink" title="17、STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容"></a>17、STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容</h4><ul>
<li>unordered_map和map类似，都是存储的key-value的值，可以通过key快速索引到value。</li>
<li>不同的是unordered_map不会根据key的大小进行排序，存储时是根据key的hash值判断元素是否相同，即unordered_map内部元素是无序的，而map中的元素是按照二叉搜索树存储，进行中序遍历会得到有序遍历。所以使用时map的key需要定义operator&lt;。而unordered_map需要定义hash_value函数并且重载operator&#x3D;&#x3D;。但是很多系统内置的数据类型都自带这些，那么如果是自定义类型，那么就需要自己重载operator&lt;或者hash_value()了。如果需要内部元素自动排序，使用map，不需要排序使用unordered_map</li>
<li>unordered_map的底层实现是hash_table;hash_map底层使用的是hash_table，而hash_table使用的开链法进行冲突避免，所有hash_map采用开链法进行冲突解决。</li>
<li><strong>什么时候扩容：</strong>当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值—即当前数组的长度乘以加载因子的值的时候，就要自动扩容啦。**扩容(resize)**就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素</li>
</ul>
<h4 id="18、vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？"><a href="#18、vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？" class="headerlink" title="18、vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？"></a>18、vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？</h4><ul>
<li>通过下标访问vector中的元素时会做边界检查，但该处的实现方式要看具体IDE，不同IDE的实现方式不一样，确保不可访问越界地址。</li>
<li>map的下标运算符[]的作用是：将key作为下标去执行查找，并返回相应的值；如果不存在这个key，就将一个具有该key和value的某人值插入这个map。</li>
<li>erase()函数，只能删除内容，不能改变容量大小;erase成员函数，它删除了itVect迭代器指向的元素，并且返回要被删除的itVect之后的迭代器，迭代器相当于一个智能指针;clear()函数，只能清空内容，不能改变容量大小;如果要想在删除内容的同时释放内存，可以选择deque容器。</li>
</ul>
<h4 id="19、map中-与find的区别？"><a href="#19、map中-与find的区别？" class="headerlink" title="19、map中[]与find的区别？"></a>19、map中[]与find的区别？</h4><ul>
<li>map的下标运算符[]的作用是：将关键码作为下标去执行查找，并返回对应的值；如果不存在这个关键码，就将一个具有该关键码和值类型的默认值的项插入这个map。</li>
<li>map的find函数：用关键码执行查找，找到了返回该位置的迭代器；如果不存在这个关键码，就返回尾迭代器</li>
</ul>
<h4 id="20、-STL中list与deque之间的区别"><a href="#20、-STL中list与deque之间的区别" class="headerlink" title="20、 STL中list与deque之间的区别"></a>20、 STL中list与deque之间的区别</h4><ul>
<li>list不再能够像vector一样以普通指针作为迭代器，因为其节点不保证在存储空间中连续存在；</li>
<li>list插入操作和结合才做都不会造成原有的list迭代器失效;</li>
<li>list不仅是一个双向链表，而且还是一个环状双向链表，所以它只需要一个指针；</li>
<li>list不像vector那样有可能在空间不足时做重新配置、数据移动的操作，所以插入前的所有迭代器在插入操作之后都仍然有效；</li>
<li>deque是一种双向开口的连续线性空间，所谓双向开口，意思是可以在头尾两端分别做元素的插入和删除操作；可以在头尾两端分别做元素的插入和删除操作；</li>
<li>deque和vector最大的差异，一在于deque允许常数时间内对起头端进行元素的插入或移除操作，二在于deque没有所谓容量概念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，deque没有所谓的空间保留功能</li>
</ul>
<h4 id="21、STL中的allocator、deallocator"><a href="#21、STL中的allocator、deallocator" class="headerlink" title="21、STL中的allocator、deallocator"></a>21、STL中的allocator、deallocator</h4><ul>
<li>第一级配置器直接使用malloc()、free()和relloc()，第二级配置器视情况采用不同的策略：当配置区块超过128bytes时，视之为足够大，便调用第一级配置器；当配置器区块小于128bytes时，为了降低额外负担，使用复杂的内存池整理方式，而不再用一级配置器；第二级配置器主动将任何小额区块的内存需求量上调至8的倍数，并维护16个free-list，各自管理大小为8~128bytes的小额区块；</li>
<li>空间配置函数allocate()，首先判断区块大小，大于128就直接调用第一级配置器，小于128时就检查对应的free-list。如果free-list之内有可用区块，就直接拿来用，如果没有可用区块，就将区块大小调整至8的倍数，然后调用refill()，为free-list重新分配空间；</li>
<li>空间释放函数deallocate()，该函数首先判断区块大小，大于128bytes时，直接调用一级配置器，小于128bytes就找到对应的free-list然后释放内存。</li>
</ul>
<h4 id="22、STL中hash-table扩容发生什么？"><a href="#22、STL中hash-table扩容发生什么？" class="headerlink" title="22、STL中hash table扩容发生什么？"></a>22、STL中hash table扩容发生什么？</h4><ul>
<li>hash table表格内的元素称为桶（bucket),而由桶所链接的元素称为节点（node),其中存入桶元素的容器为stl本身很重要的一种序列式容器——vector容器。之所以选择vector为存放桶元素的基础容器，主要是因为vector容器本身具有动态扩容能力，无需人工干预。</li>
</ul>
<h4 id="23、常见容器性质总结？"><a href="#23、常见容器性质总结？" class="headerlink" title="23、常见容器性质总结？"></a>23、常见容器性质总结？</h4><ul>
<li>vector 底层数据结构为数组 ，支持快速随机访问</li>
<li>list 底层数据结构为双向链表，支持快速增删</li>
<li>deque 底层数据结构为一个中央控制器和多个缓冲区，支持首尾（中间不能）快速增删，也支持随机访问;deque是一个双端队列(double-ended queue)，也是在堆中保存内容的；每个堆保存好几个元素,然后堆和堆之间有指针指向,看起来像是list和vector的结合品.</li>
<li>stack 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时</li>
<li>queue 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时（stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）</li>
<li>priority_queue 的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现</li>
<li>set 底层数据结构为红黑树，有序，不重复</li>
<li>multiset 底层数据结构为红黑树，有序，可重复</li>
<li>map 底层数据结构为红黑树，有序，不重复</li>
<li>multimap 底层数据结构为红黑树，有序，可重复</li>
<li>unordered_set 底层数据结构为hash表，无序，不重复</li>
<li>unordered_multiset 底层数据结构为hash表，无序，可重复</li>
<li>unordered_map 底层数据结构为hash表，无序，不重复</li>
<li>unordered_multimap 底层数据结构为hash表，无序，可重复</li>
</ul>
<h4 id="24、vector的增加删除都是怎么做的？为什么是1-5或者是2倍？"><a href="#24、vector的增加删除都是怎么做的？为什么是1-5或者是2倍？" class="headerlink" title="24、vector的增加删除都是怎么做的？为什么是1.5或者是2倍？"></a>24、vector的增加删除都是怎么做的？为什么是1.5或者是2倍？</h4><ul>
<li>新增元素：vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素；</li>
<li>对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了 ；</li>
<li>初始时刻vector的capacity为0，塞入第一个元素后capacity增加为1；</li>
<li>不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。</li>
<li>对比可以发现采用采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容。</li>
<li>考虑可能产生的堆空间浪费，成倍增长倍数不能太大，使用较为广泛的扩容方式有两种，以2二倍的方式扩容，或者以1.5倍的方式扩容。以2倍的方式扩容，导致下一次申请的内存必然大于之前分配内存的总和，导致之前分配的内存不能再被使用，所以最好倍增长因子设置为(1,2)之间：</li>
<li>向量容器vector的成员函数pop_back()可以删除最后一个元素；而函数erase()可以删除由一个iterator指出的元素，也可以删除一个指定范围的元素。还可以采用通用算法remove()来删除vector容器中的元素。不同的是：采用remove一般情况下不会改变容器的大小，而pop_back()与erase()等成员函数会改变容器的大小。</li>
</ul>
<h4 id="25、说一下STL每种容器对应的迭代器"><a href="#25、说一下STL每种容器对应的迭代器" class="headerlink" title="25、说一下STL每种容器对应的迭代器"></a>25、说一下STL每种容器对应的迭代器</h4><ul>
<li>vector、deque：随机访问迭代器</li>
<li>stack、queue、priority_queue：无</li>
<li>list、(multi)set&#x2F;map：双向迭代器</li>
<li>unordered_(multi)set&#x2F;map、forward_list：前向迭代器</li>
</ul>
<h4 id="26、STL中迭代器失效的情况有哪些？"><a href="#26、STL中迭代器失效的情况有哪些？" class="headerlink" title="26、STL中迭代器失效的情况有哪些？"></a>26、STL中迭代器失效的情况有哪些？</h4><ul>
<li>以vector为例：<ul>
<li><strong>插入元素：</strong><ul>
<li>尾后插入：size &lt; capacity时，首迭代器不失效尾迭代失效（未重新分配空间），size &#x3D;&#x3D; capacity时，所有迭代器均失效（需要重新分配空间）。</li>
<li>中间插入：中间插入：size &lt; capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size &#x3D;&#x3D; capacity时，所有迭代器均失效。</li>
</ul>
</li>
<li><strong>删除元素：</strong><ul>
<li>尾后删除：只有尾迭代失效。</li>
<li>中间删除：删除位置之后所有迭代失效。</li>
</ul>
</li>
</ul>
</li>
<li>deque 和 vector 的情况类似,</li>
<li>而list双向链表每一个节点内存不连续, 删除节点仅当前迭代器失效,erase返回下一个有效迭代器;</li>
<li>map&#x2F;set等关联容器底层是红黑树删除节点不会影响其他节点的迭代器, 使用递增方法获取下一个迭代器 mmp.erase(iter++);</li>
<li>unordered_(hash) 迭代器意义不大, rehash之后, 迭代器应该也是全部失效</li>
</ul>
<h4 id="27、STL中vector的实现"><a href="#27、STL中vector的实现" class="headerlink" title="27、STL中vector的实现"></a>27、STL中vector的实现</h4><ul>
<li>vector是一种序列式容器，其数据安排以及操作方式与array非常类似，两者的唯一差别就是对于空间运用的灵活性<ul>
<li>array占用的是静态空间，一旦配置了就不可以改变大小，如果遇到空间不足的情况还要自行创建更大的空间，并手动将数据拷贝到新的空间中，再把原来的空间释放。</li>
<li>vector则使用灵活的动态空间配置，维护一块<strong>连续的线性空间</strong>，在空间不足时，可以自动扩展空间容纳新元素，做到按需供给。其在扩充空间的过程中仍然需要经历：<strong>重新配置空间，移动数据，释放原空间</strong>等操作。</li>
<li>动态扩容的规则：以原大小的两倍配置另外一块较大的空间（或者旧长度+新增元素的个数）</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> size_type len  = old_size + <span class="built_in">max</span>(old_size, n);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Vector扩容倍数与平台有关，在Win + VS 下是 1.5倍，在 Linux + GCC 下是 2 倍</p>
</li>
<li><p>频繁对vector调用push_back()对性能是有影响的，这是因为每插入一个元素，如果空间够用的话还能直接插入，若空间不够用，则需要重新配置空间，移动数据，释放原空间等操作，对程序性能会造成一定的影响</p>
</li>
</ul>
<h4 id="28、STL中slist的实现"><a href="#28、STL中slist的实现" class="headerlink" title="28、STL中slist的实现"></a>28、STL中slist的实现</h4><ul>
<li>list是双向链表，而slist（single linked list）是单向链表，它们的主要区别在于：前者的迭代器是双向的Bidirectional iterator，后者的迭代器属于单向的Forward iterator。虽然slist的很多功能不如list灵活，但是其所耗用的空间更小，操作更快。</li>
<li>根据STL的习惯，插入操作会将新元素插入到指定位置之前，而非之后，然而slist是不能回头的，只能往后走，因此在slist的其他位置插入或者移除元素是十分不明智的，但是在slist开头却是可取的，slist特别提供了insert_after()和erase_after供灵活应用。考虑到效率问题，slist只提供push_front()操作，元素插入到slist后，存储的次序和输入的次序是相反的</li>
</ul>
<h4 id="29、STL中list的实现"><a href="#29、STL中list的实现" class="headerlink" title="29、STL中list的实现"></a>29、STL中list的实现</h4><ul>
<li>相比于vector的连续线型空间，list显得复杂许多，但是它的好处在于插入或删除都只作用于一个元素空间，因此list对空间的运用是十分精准的，对任何位置元素的插入和删除都是常数时间。</li>
<li>list不能保证节点在存储空间中连续存储，也拥有迭代器，迭代器的“++”、“–”操作对于的是指针的操作，list提供的迭代器类型是双向迭代器：Bidirectional iterators。</li>
<li>list与vector的另一个区别是，在插入和接合操作之后，都不会造成原迭代器失效，而vector可能因为空间重新配置导致迭代器失效。</li>
<li>此外list也是一个环形链表，因此只要一个指针便能完整表现整个链表。list中node节点指针始终指向尾端的一个空白节点，因此是一种“前闭后开”的区间结构;由于list的双向特性，其支持在头部（front)和尾部（back)两个方向进行push和pop操作，当然还支持erase，splice，sort，merge，reverse，sort等操作</li>
<li>list的空间管理默认采用alloc作为空间配置器，为了方便的以节点大小为配置单位，还定义一个list_node_allocator函数可一次性配置多个节点空间</li>
</ul>
<h4 id="30、STL中的deque的实现"><a href="#30、STL中的deque的实现" class="headerlink" title="30、STL中的deque的实现"></a>30、STL中的deque的实现</h4><ul>
<li><p>vector是单向开口（尾部）的连续线性空间，deque则是一种双向开口的连续线性空间，虽然vector也可以在头尾进行元素操作，但是其头部操作的效率十分低下（主要是涉及到整体的移动）</p>
</li>
<li><p>deque和vector的最大差异一个是deque运行在常数时间内对头端进行元素操作，二是deque没有容量的概念，它是动态地以分段连续空间组合而成，可以随时增加一段新的空间并链接起来</p>
</li>
<li><p><strong>deque虽然也提供随机访问的迭代器，但是其迭代器并不是普通的指针，其复杂程度比vector高很多</strong>，因此除非必要，否则一般使用vector而非deque。如果需要对deque排序，可以先将deque中的元素复制到vector中，利用sort对vector排序，再将结果复制回deque</p>
</li>
<li><p>deque由一段一段的定量连续空间组成，一旦需要增加新的空间，只要配置一段定量连续空间拼接在头部或尾部即可，因此deque的最大任务是如何维护这个整体的连续性</p>
</li>
<li><p>deque内部有一个指针指向map，map是一小块连续空间，其中的每个元素称为一个节点，node，每个node都是一个指针，指向另一段较大的连续空间，称为缓冲区，这里就是deque中实际存放数据的区域，默认大小512bytes。</p>
</li>
<li><p>deque迭代器的“++”、“–”操作是远比vector迭代器繁琐，其主要工作在于缓冲区边界，如何从当前缓冲区跳到另一个缓冲区，当然deque内部在插入元素时，如果map中node数量全部使用完，且node指向的缓冲区也没有多余的空间，这时会配置新的map（2倍于当前+2的数量）来容纳更多的node，也就是可以指向更多的缓冲区。在deque删除元素时，也提供了元素的析构和空闲缓冲区空间的释放等机制。</p>
</li>
</ul>
<h4 id="31、STL中stack和queue的实现"><a href="#31、STL中stack和queue的实现" class="headerlink" title="31、STL中stack和queue的实现"></a>31、STL中stack和queue的实现</h4><ul>
<li>stack（栈）是一种先进后出（First In Last Out）的数据结构，只有一个入口和出口，那就是栈顶，除了获取栈顶元素外，没有其他方法可以获取到内部的其他元素</li>
<li>stack这种单向开口的数据结构很容易由<strong>双向开口的deque和list</strong>形成，只需要根据stack的性质对应移除某些接口即可实现，stack这种“修改某种接口，形成另一种风貌”的行为，成为adapter(配接器)。常将其归类为container adapter而非container</li>
<li>stack除了默认使用deque作为其底层容器之外，也可以使用双向开口的list，只需要在初始化stack时，将list作为第二个参数即可。由于stack只能操作顶端的元素，因此其内部元素无法被访问，也不提供迭代器。</li>
<li>queue（队列）是一种先进先出（First In First Out）的数据结构，只有一个入口和一个出口，分别位于最底端和最顶端，出口元素外，没有其他方法可以获取到内部的其他元素</li>
<li>queue这种“先进先出”的数据结构很容易由双向开口的deque和list形成，只需要根据queue的性质对应移除某些接口即可实现，queue也是一类container adapter。同样，queue也可以使用list作为底层容器，不具有遍历功能，没有迭代器。</li>
</ul>
<h4 id="32、STL中的heap的实现"><a href="#32、STL中的heap的实现" class="headerlink" title="32、STL中的heap的实现"></a>32、STL中的heap的实现</h4><ul>
<li>heap（堆）并不是STL的容器组件，是priority queue（优先队列）的底层实现机制，因为binary max heap（大根堆）总是最大值位于堆的根部，优先级最高。</li>
<li>priority_queue，优先队列，是一个拥有权值观念的queue，它跟queue一样是顶部入口，底部出口，在插入元素时，元素并非按照插入次序排列，它会自动根据权值（通常是元素的实值）排列，权值最高，排在最前面</li>
<li>默认情况下，priority_queue使用一个max-heap完成，底层容器使用的是一般为vector为底层容器，堆heap为处理规则来管理底层容器实现 。priority_queue的这种实现机制导致其不被归为容器，而是一种容器配接器。</li>
<li>priority_queue的所有元素，进出都有一定的规则，只有queue顶端的元素（权值最高者），才有机会被外界取用，它没有遍历功能，也不提供迭代器</li>
</ul>
<h4 id="34、STL中set的实现？"><a href="#34、STL中set的实现？" class="headerlink" title="34、STL中set的实现？"></a>34、STL中set的实现？</h4><ul>
<li><p>STL中的容器可分为序列式容器（sequence）和关联式容器（associative），set属于关联式容器。set的特性是，所有元素都会根据元素的值自动被排序（默认升序），set元素的键值就是实值，实值就是键值，set不允许有两个相同的键值</p>
</li>
<li><p>set不允许迭代器修改元素的值，其迭代器是一种constance iterators</p>
</li>
<li><p>标准的STL set以RB-tree（红黑树）作为底层机制，几乎所有的set操作行为都是转调用RB-tree的操作行为，这里补充一下红黑树的特性：</p>
<ul>
<li>每个节点不是红色就是黑色</li>
<li>根结点为黑色</li>
<li>如果节点为红色，其子节点必为黑</li>
<li>任一节点至（NULL）树尾端的任何路径，所含的黑节点数量必相同</li>
</ul>
</li>
<li><p>关联式容器尽量使用其自身提供的find()函数查找指定的元素，效率更高，因为STL提供的find()函数是一种顺序搜索算法</p>
</li>
</ul>
<h4 id="35、STL中map的实现"><a href="#35、STL中map的实现" class="headerlink" title="35、STL中map的实现"></a>35、STL中map的实现</h4><ul>
<li>map的特性是所有元素会根据键值进行自动排序。map中所有的元素都是pair，拥有键值(key)和实值(value)两个部分，并且不允许元素有相同的key</li>
<li>一旦map的key确定了，那么是无法修改的，但是可以修改这个key对应的value，因此map的迭代器既不是constant iterator，也不是mutable iterator</li>
<li>标准STL map的底层机制是RB-tree（红黑树），另一种以hash table为底层机制实现的称为hash_map。</li>
<li>map的在构造时缺省采用递增排序key，也使用alloc配置器配置空间大小，需要注意的是在插入元素时，调用的是红黑树中的insert_unique()方法，而非insert_euqal()（multimap使用）</li>
<li>需要注意的是subscript（下标）操作既可以作为左值运用（修改内容）也可以作为右值运用（获取实值）。无论如何，subscript操作符都会先根据键值找出实值，代码运行过程是：首先根据键值和实值做出一个元素，这个元素的实值未知，因此产生一个与实值型别相同的临时对象替代,再将这个对象插入到map中，并返回一个pair<ul>
<li>pair第一个元素是迭代器，指向当前插入的新元素，如果插入成功返回true，此时对应左值运用，根据键值插入实值。插入失败（重复插入）返回false，此时返回的是已经存在的元素，则可以取到它的实值</li>
<li>由于这个实值是以引用方式传递，因此作为左值或者右值都可以</li>
</ul>
</li>
</ul>
<h4 id="36、set和map的区别，multimap和multiset的区别"><a href="#36、set和map的区别，multimap和multiset的区别" class="headerlink" title="36、set和map的区别，multimap和multiset的区别"></a>36、set和map的区别，multimap和multiset的区别</h4><ul>
<li>set只提供一种数据类型的接口，但是会将这一个元素分配到key和value上，而且它的compare_function用的是 identity()函数，这个函数是输入什么输出什么，这样就实现了set机制，set的key和value其实是一样的了。其实他保存的是两份元素，而不是只保存一份元素</li>
<li>map则提供两种数据类型的接口，分别放在key和value的位置上，他的比较function采用的是红黑树的comparefunction（），保存的确实是两份元素。</li>
<li>他们两个的insert都是采用红黑树的insert_unique() 独一无二的插入 。</li>
<li>multimap和map的唯一区别就是：multimap调用的是红黑树的insert_equal(),可以重复插入而map调用的则是独一无二的插入insert_unique()，multiset和set也一样，底层实现都是一样的，只是在插入的时候调用的方法不一样。</li>
</ul>
<h4 id="37、STL中unordered-map和map的区别和应用场景"><a href="#37、STL中unordered-map和map的区别和应用场景" class="headerlink" title="37、STL中unordered_map和map的区别和应用场景"></a>37、STL中unordered_map和map的区别和应用场景</h4><ul>
<li>map支持键值的自动排序，底层机制是红黑树，红黑树的查询和维护时间复杂度均为O(logn)，但是空间占用比较大，因为每个节点要保持父节点、孩子节点及颜色的信息</li>
<li>unordered_map是C++ 11新添加的容器，底层机制是哈希表，通过hash函数计算元素位置，其查询时间复杂度为O(1)，维护时间与bucket桶所维护的list长度有关，但是建立hash表耗时较大</li>
<li>从两者的底层机制和特点可以看出：map适用于有序数据的应用场景，unordered_map适用于高效查询的应用场景</li>
</ul>
<h4 id="38、hashtable中解决冲突有哪些方法？"><a href="#38、hashtable中解决冲突有哪些方法？" class="headerlink" title="38、hashtable中解决冲突有哪些方法？"></a>38、hashtable中解决冲突有哪些方法？</h4><ul>
<li><p>线性探测:使用hash函数计算出的位置如果已经有元素占用了，则向后依次寻找，找到表尾则回到表头，直到找到一个空位</p>
</li>
<li><p>每个表格维护一个list，如果hash函数计算出的格子相同，则按顺序存在这个list中</p>
</li>
<li><p>发生冲突时使用另一种hash函数再计算一个地址，直到不冲突</p>
</li>
<li><p><strong>二次探测</strong>:使用hash函数计算出的位置如果已经有元素占用了，按照步长依次寻找，如果步长是随机数序列，则称之为伪随机探测</p>
</li>
<li><p><strong>公共溢出区</strong>:一旦hash函数计算的结果相同，就放入公共溢出区</p>
</li>
</ul>
<h3 id="C-之其余问题"><a href="#C-之其余问题" class="headerlink" title="C++之其余问题"></a>C++之其余问题</h3><h4 id="1、C-的多态如何实现"><a href="#1、C-的多态如何实现" class="headerlink" title="1、C++的多态如何实现"></a>1、C++的多态如何实现</h4><ul>
<li>在基类的函数前加上<strong>virtual</strong>关键字，在派生类中重写该函数，运行时将会根据所指对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。</li>
<li>为什么会出现多态性，其底层的原理是什么？这里需要引出虚表和虚基表指针的概念。<ul>
<li>虚表：虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表</li>
<li>虚表指针：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的指向虚表的指针</li>
</ul>
</li>
<li>实现多态的过程：<ul>
<li>编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址</li>
<li><strong>编译器会在每个对象的前四个字节中保存一个虚表指针，即</strong>vptr，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数</li>
<li>所谓的合适时机，在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表</li>
<li>当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面</li>
<li>这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写情况动态的进行调用，从而实现多态性</li>
</ul>
</li>
</ul>
<h4 id="2、为什么析构函数一般写成虚函数"><a href="#2、为什么析构函数一般写成虚函数" class="headerlink" title="2、为什么析构函数一般写成虚函数"></a>2、为什么析构函数一般写成虚函数</h4><ul>
<li>由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。</li>
<li>如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。</li>
<li>所以将析构函数声明为虚函数是十分必要的。在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，要将基类的析构函数声明为虚函数。</li>
<li>但存在一种特例，在<code>CRTP</code>模板中，不应该将析构函数声明为虚函数，理论上所有的父类函数都不应 该声明为虚函数，因为这种继承方式，不需要虚函数表。</li>
</ul>
<h4 id="3、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"><a href="#3、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？" class="headerlink" title="3、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"></a>3、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？</h4><ul>
<li><p>析构函数：</p>
<ul>
<li>析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。</li>
<li>只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。</li>
<li><strong>析构函数可以是纯虚函数</strong>，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。</li>
</ul>
</li>
<li><p>构造函数：</p>
<ul>
<li>在构造函数中虽然可以调用虚函数，但是强烈建议不要这样做。因为基类的构造的过程中，虚函数不能算作是虚函数。若构造函数中调用虚函数，可能会导致不确定行为的发生.</li>
<li>虚函数对应一个vtable(虚函数表)，类中存储一个vptr指向这个vtable。如果构造函数是虚函数，就需要通过vtable调用，可是对象没有初始化就没有vptr，无法找到vtable，所以构造函数不能是虚函数</li>
</ul>
</li>
</ul>
<h4 id="4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"><a href="#4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间" class="headerlink" title="4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"></a>4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间</h4><ul>
<li><p>虚函数表的特征：</p>
<ul>
<li>虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成</li>
<li>虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即<strong>虚函数表不是函数，不是程序代码，不可能存储在代码段</strong></li>
<li>虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中</li>
</ul>
</li>
<li><p>虚函数表类似于类中静态成员变量.静态成员变量也是全局共享，大小确定，因此最有可能存在全局数据区，测试结果显示：</p>
<ul>
<li>虚函数表vtable在Linux&#x2F;Unix中存放在可执行文件的只读数据段中(rodata)</li>
<li>由于虚表指针vptr跟虚函数密不可分，对于有虚函数或者继承于拥有虚函数的基类，对该类进行实例化时，在构造函数执行时会对虚表指针进行初始化，并且存在对象内存布局的最前面。</li>
</ul>
</li>
<li><p>一般分为五个区域：栈区、堆区、函数区（存放函数体等二进制代码）、全局静态区、常量区；C++中<strong>虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区</strong></p>
</li>
</ul>
<h4 id="5、模板函数和模板类的特例化"><a href="#5、模板函数和模板类的特例化" class="headerlink" title="5、模板函数和模板类的特例化"></a>5、模板函数和模板类的特例化</h4><ul>
<li><strong>引入原因</strong>：编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化</li>
<li><strong>定义</strong>：对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上</li>
<li>模板函数特例化：必须为原函数模板的每个模板参数都提供实参，且使用关键字template后跟一个空尖括号对&lt;&gt;，表明将原模板的所有模板参数提供实参<ul>
<li><strong>本质</strong>：特例化的本质是实例化一个模板，而非重载它。特例化不影响参数匹配。参数匹配都以最佳匹配为原则。</li>
<li><strong>注意</strong>：模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。</li>
</ul>
</li>
<li>类模板特例化：原理类似函数模板，<strong>不过在类中，我们可以对模板进行特例化，也可以对类进行部分特例化。</strong></li>
<li>类模板的部分特例化：不必为所有模板参数提供实参，可以<strong>指定一部分而非所有模板参数</strong>，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参(特例化时类名一定要和原来的模板相同，只是参数类型不同，按最佳匹配原则，哪个最匹配，就用相应的模板)</li>
<li>可以特例化类中的部分成员函数而不是整个类</li>
</ul>
<h4 id="6、构造函数、析构函数、虚函数可否声明为内联函数"><a href="#6、构造函数、析构函数、虚函数可否声明为内联函数" class="headerlink" title="6、构造函数、析构函数、虚函数可否声明为内联函数"></a>6、构造函数、析构函数、虚函数可否声明为内联函数</h4><ul>
<li><p>将这些函数声明为内联函数，在语法上没有错误。因为inline同register一样，只是个建议，编译器并不一定真正的内联。</p>
<ul>
<li>register关键字：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率</li>
</ul>
</li>
<li><p>构造函数和析构函数声明为inline是没有什么意义的，即编译器并不真正对声明为inline的构造和析构函数进行内联操作，因为编译器会在构造和析构函数中添加额外的操作（申请&#x2F;释放内存，构造&#x2F;析构对象等），致使构造函数&#x2F;析构函数并不像看上去的那么精简。</p>
</li>
<li><p>class中的函数默认是inline型的，编译器也只是有选择性的inline，将构造函数和析构函数声明为内联函数是没有什么意义的。</p>
</li>
<li><p><strong>将虚函数声明为inline，要分情况讨论</strong></p>
<ul>
<li>如果虚函数在编译器就能够决定将要调用哪个函数时，就能够内联，当用对象调用虚函数（此时不具有多态性）时，就内联展开</li>
<li>当是指向派生类的指针（多态性）调用声明为inline的虚函数时，不会内联展开；当是对象本身调用虚函数时，会内联展开，当然前提依然是函数并不复杂的情况下。</li>
</ul>
</li>
</ul>
<h4 id="7、C-模板是什么，你知道底层怎么实现的？"><a href="#7、C-模板是什么，你知道底层怎么实现的？" class="headerlink" title="7、C++模板是什么，你知道底层怎么实现的？"></a>7、C++模板是什么，你知道底层怎么实现的？</h4><ul>
<li>编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产生不同的函数；编译器<strong>会对函数模板进行两次编译</strong>：<strong>在声明的地方对模板代码本身进行编译</strong>，<strong>在调用的地方对参数替换后的代码进行编译</strong>。</li>
<li>这是因为<strong>函数模板要被实例化后才能成为真正的函数</strong>，在使用函数模板的源文件中包含函数模板的头文件，<strong>如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。</strong></li>
</ul>
<h4 id="8、构造函数为什么不能为虚函数？析构函数为什么要虚函数？"><a href="#8、构造函数为什么不能为虚函数？析构函数为什么要虚函数？" class="headerlink" title="8、构造函数为什么不能为虚函数？析构函数为什么要虚函数？"></a>8、构造函数为什么不能为虚函数？析构函数为什么要虚函数？</h4><ul>
<li><p><strong>从存储空间角度，</strong>虚函数相应一个指向vtable虚函数表的指针,这个指向vtable的指针事实上是存储在对象的内存空间的。假设构造函数是虚的，就须要通过 vtable来调用，但是对象还没有实例化，也就是内存空间还没有，无法找vtable，所以构造函数不能是虚函数。</p>
</li>
<li><p><strong>从使用角度，</strong>虚函数主要用于在信息不全的情况下，能使重载的函数得到相应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数。而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。</p>
</li>
<li><p><strong>从实现上看，</strong>vbtl在构造函数调用后才建立，因而构造函数不可能成为虚函数从实际含义上看，在调用构造函数时还不能确定对象的真实类型（由于子类会调父类的构造函数）；并且构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，也没有必要成为虚函数。</p>
</li>
<li><p>C++中基类采用virtual虚析构函数是<strong>为了防止内存泄漏。</strong>如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。</p>
</li>
</ul>
<h4 id="9、析构函数的作用，如何起作用？"><a href="#9、析构函数的作用，如何起作用？" class="headerlink" title="9、析构函数的作用，如何起作用？"></a>9、析构函数的作用，如何起作用？</h4><ul>
<li>构造函数只是起初始化值的作用，但实例化一个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数里面，这样就使其他的函数里面有值了。只要实例化对象，系统自动回调用一个构造函数，就算没有自己定义，编译器也自动调用一次。</li>
<li>析构函数与构造函数的作用相反，用于撤销对象的一些特殊任务处理，可以是释放对象分配的内存空间；特点：析构函数与构造函数同名，但该函数前面加~。</li>
<li>析构函数没有参数，也没有返回值，而且不能重载，在一个类中只能有一个析构函数。 当撤销对象时，编译器也会自动调用析构函数。每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。一般析构函数定义为类的公有成员</li>
</ul>
<h4 id="10、构造函数和析构函数可以调用虚函数吗，为什么"><a href="#10、构造函数和析构函数可以调用虚函数吗，为什么" class="headerlink" title="10、构造函数和析构函数可以调用虚函数吗，为什么"></a>10、构造函数和析构函数可以调用虚函数吗，为什么</h4><ul>
<li>在C++中，提倡不在构造函数和析构函数中调用虚函数；</li>
<li>构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本；</li>
<li>因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编；</li>
<li>析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义</li>
</ul>
<h4 id="11、构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？"><a href="#11、构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？" class="headerlink" title="11、构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？"></a>11、构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？</h4><ul>
<li><strong>构造函数顺序</strong><ul>
<li>基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。</li>
<li>成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。</li>
<li>派生类构造函数。</li>
</ul>
</li>
<li><strong>析构函数顺序</strong><ul>
<li>调用派生类的析构函数；</li>
<li>调用成员类对象的析构函数；</li>
<li>调用基类的析构函数。</li>
</ul>
</li>
</ul>
<h4 id="13、构造函数析构函数可否抛出异常"><a href="#13、构造函数析构函数可否抛出异常" class="headerlink" title="13、构造函数析构函数可否抛出异常"></a>13、构造函数析构函数可否抛出异常</h4><ul>
<li>C++只会析构已经完成的对象，对象只有在其构造函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外。因此，在对象的构造函数中发生异常，对象的析构函数不会被调用。因此会造成内存泄漏。</li>
<li>用auto_ptr对象来取代指针类成员，便对构造函数做了强化，免除了抛出异常时发生资源泄漏的危机，不再需要在析构函数中手动释放资源；</li>
<li>如果控制权基于异常的因素离开析构函数，而此时正有另一个异常处于作用状态，C++会调用terminate函数让程序结束；</li>
<li>如果异常从析构函数抛出，而且没有在当地进行捕捉，那个析构函数便是执行不全的。如果析构函数执行不全，就是没有完成他应该执行的每一件事情</li>
</ul>
<h4 id="15、类什么时候会析构？"><a href="#15、类什么时候会析构？" class="headerlink" title="15、类什么时候会析构？"></a>15、类什么时候会析构？</h4><ul>
<li>对象生命周期结束，被销毁时；</li>
<li>delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时；</li>
<li>对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用</li>
</ul>
<h4 id="17、构造函数的几种关键字"><a href="#17、构造函数的几种关键字" class="headerlink" title="17、构造函数的几种关键字"></a>17、构造函数的几种关键字</h4><ul>
<li><strong>default</strong>：default关键字可以显式要求编译器生成合成构造函数，防止在调用时相关构造函数类型没有定义而报错</li>
<li><strong>delete</strong>：delete关键字可以删除构造函数、赋值运算符函数等，这样在使用的时候会得到友善的提示</li>
<li><strong>0</strong>：将虚函数定义为纯虚函数（纯虚函数无需定义，&#x3D; 0只能出现在类内部虚函数的声明语句处；当然，也可以为纯虚函数提供定义，函数体可以定义在类的外部也可以定义在内部。</li>
</ul>
<h4 id="18、构造函数、拷贝构造函数和赋值操作符的区别"><a href="#18、构造函数、拷贝构造函数和赋值操作符的区别" class="headerlink" title="18、构造函数、拷贝构造函数和赋值操作符的区别"></a>18、构造函数、拷贝构造函数和赋值操作符的区别</h4><ul>
<li><p><strong>构造函数</strong>：对象不存在，没用别的对象初始化，在创建一个新的对象时调用构造函数</p>
</li>
<li><p><strong>拷贝构造函数</strong>：对象不存在，但是使用别的已经存在的对象来进行初始化</p>
</li>
<li><p><strong>赋值运算符</strong>：对象存在，用别的对象给它赋值，这属于重载“&#x3D;”号运算符的范畴，“&#x3D;”号两侧的对象都是已存在的</p>
</li>
</ul>
<h4 id="19、拷贝构造函数和赋值运算符重载的区别？"><a href="#19、拷贝构造函数和赋值运算符重载的区别？" class="headerlink" title="19、拷贝构造函数和赋值运算符重载的区别？"></a>19、拷贝构造函数和赋值运算符重载的区别？</h4><ul>
<li><p>拷贝构造函数是函数，赋值运算符是运算符重载。</p>
</li>
<li><p>拷贝构造函数会生成新的类对象，赋值运算符不能。</p>
</li>
<li><p>拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。</p>
</li>
<li><p>形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现”&#x3D;”的地方都是使用赋值运算符</p>
</li>
</ul>
<h4 id="20、什么是虚拟继承"><a href="#20、什么是虚拟继承" class="headerlink" title="20、什么是虚拟继承"></a>20、什么是虚拟继承</h4><ul>
<li>由于C++支持多继承，除了public、protected和private三种继承方式外，还支持虚拟（virtual）继承，比如B和C虚拟继承A，D又公有继承B和C，这种方式是一种<strong>菱形继承或者钻石继承</strong></li>
<li><strong>虚拟继承的情况下，无论基类被继承多少次，只会存在一个实体。</strong>虚拟继承基类的子类中，子类会增加某种形式的指针，或者指向虚基类子对象，或者指向一个相关的表格；表格中存放的不是虚基类子对象的地址，就是其偏移量，此类指针被称为bptr，如上图所示。如果既存在vptr又存在bptr，某些编译器会将其优化，合并为一个指针。</li>
</ul>
<h4 id="21、什么情况会自动生成默认构造函数？"><a href="#21、什么情况会自动生成默认构造函数？" class="headerlink" title="21、什么情况会自动生成默认构造函数？"></a>21、什么情况会自动生成默认构造函数？</h4><ul>
<li>带有默认构造函数的类成员对象，如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，那么编译器就为该类合成出一个默认构造函数。<ul>
<li>不过这个合成操作只有在构造函数真正被需要的时候才会发生；</li>
<li>如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行；</li>
</ul>
</li>
<li>带有默认构造函数的基类，如果一个没有任务构造函数的派生类派生自一个带有默认构造函数基类，那么该派生类会合成一个构造函数调用上一层基类的默认构造函数；</li>
<li>带有一个虚函数的类，虚函数的引入需要进入虚表，指向虚表的指针，该指针是在构造函数中初始化的，所以没有构造函数的话该指针无法被初始化；</li>
<li>合成的默认构造函数中，只有基类子对象和成员类对象会被初始化。所有其他的非静态数据成员都不会被初始化。</li>
</ul>
<h4 id="22、抽象基类为什么不能创建对象？"><a href="#22、抽象基类为什么不能创建对象？" class="headerlink" title="22、抽象基类为什么不能创建对象？"></a>22、抽象基类为什么不能创建对象？</h4><ul>
<li>抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。</li>
<li>抽象类的定义： 称带有纯虚函数的类为抽象类。</li>
<li>抽象类的作用： 抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。</li>
<li>抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。</li>
<li>抽象类是不能定义对象的。一个纯虚函数不需要（但是可以）被定义。纯虚函数是一种特殊的虚函数；在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。</li>
<li>纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。</li>
<li>纯虚函数引入原因 <ul>
<li>为了方便使用多态特性，我们常常需要在基类中定义虚拟函数</li>
<li>在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数。若要使派生类为非抽象类，则编译器要求在派生类中，必须对纯虚函数予以重载以实现多态性。同时含有纯虚函数的类称为抽象类，它不能生成对象。</li>
</ul>
</li>
</ul>
<h4 id="23、模板类和模板函数的区别是什么？"><a href="#23、模板类和模板函数的区别是什么？" class="headerlink" title="23、模板类和模板函数的区别是什么？"></a>23、模板类和模板函数的区别是什么？</h4><ul>
<li>函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指定。即函数模板允许隐式调用和显式调用而类模板只能显示调用。</li>
<li>在使用时类模板必须加<T>，而函数模板不必</li>
</ul>
<h4 id="24、多继承的优缺点，作为一个开发者怎么看待多继承"><a href="#24、多继承的优缺点，作为一个开发者怎么看待多继承" class="headerlink" title="24、多继承的优缺点，作为一个开发者怎么看待多继承"></a>24、多继承的优缺点，作为一个开发者怎么看待多继承</h4><ul>
<li>C++允许为一个派生类指定多个基类，这样的继承结构被称做多重继承。</li>
<li>多重继承的优点很明显，就是对象可以调用多个基类中的接口；</li>
<li>如果派生类所继承的多个基类有相同的基类，而派生类对象需要调用这个祖先类的接口方法，就会容易出现二义性</li>
<li>加上全局符确定调用哪一份拷贝。比如pa.Author::eat()调用属于Author的拷贝。</li>
<li>使用虚拟继承，使得多重继承类Programmer_Author只拥有Person类的一份拷贝</li>
</ul>
<h4 id="25、模板和实现可不可以不写在一个文件里面？为什么？"><a href="#25、模板和实现可不可以不写在一个文件里面？为什么？" class="headerlink" title="25、模板和实现可不可以不写在一个文件里面？为什么？"></a>25、模板和实现可不可以不写在一个文件里面？为什么？</h4><ul>
<li>在编译时模板并不能生成真正的二进制代码，而是在编译调用模板类或函数的CPP文件时才会去找对应的模板声明和实现，在这种情况下编译器是不知道实现模板类或函数的CPP文件的存在，所以它只能找到模板类或函数的声明而找不到实现，而只好创建一个符号寄希望于链接程序找地址。</li>
<li>但模板类或函数的实现并不能被编译成二进制代码，结果链接程序找不到地址只好报错了。 </li>
<li>模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</li>
</ul>
<h4 id="26、将字符串“hello-world”从开始到打印到屏幕上的全过程"><a href="#26、将字符串“hello-world”从开始到打印到屏幕上的全过程" class="headerlink" title="26、将字符串“hello world”从开始到打印到屏幕上的全过程?"></a>26、将字符串“hello world”从开始到打印到屏幕上的全过程?</h4><ul>
<li>用户告诉操作系统执行HelloWorld程序（通过键盘输入等）</li>
<li>操作系统：<ul>
<li>找到helloworld程序的相关信息，检查其类型是否是可执行文件；</li>
<li>通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址。</li>
<li>创建一个新进程，将HelloWorld可执行文件映射到该进程结构，表示由该进程执行helloworld程序。</li>
<li>为helloworld程序设置cpu上下文环境，并跳到程序开始处。</li>
<li>执行helloworld程序的第一条指令，发生缺页异常</li>
<li>分配一页物理内存，并将代码从磁盘读入内存，然后继续执行helloworld程序</li>
<li>helloword程序执行puts函数（系统调用），在显示器上写一字符串</li>
<li>找到要将字符串送往的显示设备，通常设备是由一个进程控制的，所以，操作系统将要写的字符串送给该进程</li>
<li>控制设备的进程告诉设备的窗口系统，它要显示该字符串，窗口系统确定这是一个合法的操作，然后将字符串转换成像素，将像素写入设备的存储映像区</li>
</ul>
</li>
<li>视频硬件将像素转换成显示器可接收和一组控制数据信号</li>
<li>显示器解释信号，激发液晶屏</li>
</ul>
<h4 id="27、为什么拷贝构造函数必须传引用不能传值？"><a href="#27、为什么拷贝构造函数必须传引用不能传值？" class="headerlink" title="27、为什么拷贝构造函数必须传引用不能传值？"></a>27、为什么拷贝构造函数必须传引用不能传值？</h4><ul>
<li>拷贝构造函数的作用就是用来复制对象的，在使用这个对象的实例来初始化这个对象的一个新的实例。</li>
<li>参数传递过程到底发生了什么？ 将地址传递和值传递统一起来，归根结底还是传递的是”值”(地址也是值，只不过通过它可以找到另一个值)！ <ul>
<li>值传递: 对于内置数据类型的传递时，直接赋值拷贝给形参(注意形参是函数内局部变量)； 对于类类型的传递时，需要首先调用该类的拷贝构造函数来初始化形参(局部对象)；</li>
<li>引用传递: 无论对内置类型还是类类型，传递引用或指针最终都是传递的地址值！而地址总是指针类型(属于简单类型), 显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用(对于类类型).</li>
</ul>
</li>
<li>拷贝构造函数用来初始化一个非引用类类型对象，如果用传值的方式进行传参数，那么构造实参需要调用拷贝构造函数，而拷贝构造函数需要传递实参，所以会一直递归</li>
</ul>
<h4 id="28、静态函数能定义为虚函数吗？常函数呢？说说你的理解"><a href="#28、静态函数能定义为虚函数吗？常函数呢？说说你的理解" class="headerlink" title="28、静态函数能定义为虚函数吗？常函数呢？说说你的理解"></a>28、静态函数能定义为虚函数吗？常函数呢？说说你的理解</h4><ul>
<li>static成员不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的。</li>
<li>静态与非静态成员函数之间有一个主要的区别，那就是静态成员函数没有this指针。<ul>
<li>虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable.对于静态成员函数，它没有this指针，所以无法访问vptr。</li>
<li>虚函数的调用关系：this -&gt; vptr -&gt; vtable -&gt;virtual function。</li>
</ul>
</li>
</ul>
<h4 id="29、虚函数的代价是什么？"><a href="#29、虚函数的代价是什么？" class="headerlink" title="29、虚函数的代价是什么？"></a>29、虚函数的代价是什么？</h4><ul>
<li>带有虚函数的类，每一个类会产生一个虚函数表，用来存储指向虚成员函数的指针，增大类；</li>
<li>带有虚函数的类的每一个对象，都会有有一个指向虚表的指针，会增加对象的空间大小；</li>
<li>不能再是内联的函数，因为内联函数在编译阶段进行替代，而虚函数表示等待，在运行阶段才能确定到低是采用哪种函数，虚函数不能是内联函数</li>
</ul>
<h4 id="30、说一说你了解到的移动构造函数？"><a href="#30、说一说你了解到的移动构造函数？" class="headerlink" title="30、说一说你了解到的移动构造函数？"></a>30、说一说你了解到的移动构造函数？</h4><ul>
<li>有时候我们会遇到这样一种情况，我们用对象a初始化对象b后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；</li>
<li>拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制；</li>
<li>C++引入了移动构造函数，专门处理这种，用a初始化b后，就将a析构的情况；</li>
<li>与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，它的值可以被移动到目的对象。当使用一个临时变量对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作</li>
</ul>
<h4 id="32、那什么时候需要合成拷贝构造函数呢？"><a href="#32、那什么时候需要合成拷贝构造函数呢？" class="headerlink" title="32、那什么时候需要合成拷贝构造函数呢？"></a>32、那什么时候需要合成拷贝构造函数呢？</h4><ul>
<li><p>对一个对象做显示的初始化操作，X xx &#x3D; x;</p>
</li>
<li><p>当对象被当做参数交给某个函数时；</p>
</li>
<li><p>当函数传回一个类对象时：</p>
<ul>
<li>如果一个类没有拷贝构造函数，但是含有一个类类型的成员变量，该类型含有拷贝构造函数，此时编译器会为该类合成一个拷贝构造函数；</li>
<li>如果一个类没有拷贝构造函数，但是该类继承自含有拷贝构造函数的基类，此时编译器会为该类合成一个拷贝构造函数；</li>
<li>如果一个类没有拷贝构造函数，但是该类声明或继承了虚函数，此时编译器会为该类合成一个拷贝构造函数；</li>
<li>如果一个类没有拷贝构造函数，但是该类含有虚基类，此时编译器会为该类合成一个拷贝构造函数</li>
</ul>
</li>
</ul>
<h4 id="33、构造函数的执行顺序是什么？"><a href="#33、构造函数的执行顺序是什么？" class="headerlink" title="33、构造函数的执行顺序是什么？"></a>33、构造函数的执行顺序是什么？</h4><ol>
<li>在派生类构造函数中，所有的虚基类及上一层基类的构造函数调用；</li>
<li>对象的vptr被初始化；</li>
<li>如果有成员初始化列表，将在构造函数体内扩展开来，这必须在vptr被设定之后才做；</li>
<li>执行程序员所提供的代码</li>
</ol>
<h4 id="35、哪些函数不能是虚函数？把你知道的都说一说"><a href="#35、哪些函数不能是虚函数？把你知道的都说一说" class="headerlink" title="35、哪些函数不能是虚函数？把你知道的都说一说"></a>35、哪些函数不能是虚函数？把你知道的都说一说</h4><ul>
<li>构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化；</li>
<li>内联函数，内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数；</li>
<li>静态函数，静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。</li>
<li>友元函数，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。</li>
<li>普通函数，普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数</li>
</ul>
<h4 id="36、什么是纯虚函数，与虚函数的区别"><a href="#36、什么是纯虚函数，与虚函数的区别" class="headerlink" title="36、什么是纯虚函数，与虚函数的区别"></a>36、什么是纯虚函数，与虚函数的区别</h4><ul>
<li>虚函数是为了实现动态编联产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。</li>
<li>纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。纯虚函数首先是虚函数，其次它没有函数体，取而代之的是用“&#x3D;0”。既然是虚函数，它的函数指针会被存在虚函数表中，由于纯虚函数并没有具体的函数体，因此它在虚函数表中的值就为0，而具有函数体的虚函数则是函数的具体地址。一个类中如果有纯虚函数的话，称其为抽象类。抽象类不能用于实例化对象，否则会报错。抽象类一般用于定义一些公有的方法。子类继承抽象类也必须实现其中的纯虚函数才能实例化对象。</li>
</ul>
<h2 id="MySQL笔记整理"><a href="#MySQL笔记整理" class="headerlink" title="MySQL笔记整理"></a>MySQL笔记整理</h2><h4 id="1、关系型和非关系型数据库的区别你了解多少？"><a href="#1、关系型和非关系型数据库的区别你了解多少？" class="headerlink" title="1、关系型和非关系型数据库的区别你了解多少？"></a>1、关系型和非关系型数据库的区别你了解多少？</h4><ul>
<li>关系型数据库的优点<ul>
<li>容易理解。因为它采用了关系模型来组织数据。</li>
<li>可以保持数据的一致性。</li>
<li>数据更新的开销比较小。</li>
<li>支持复杂查询（带where子句的查询）</li>
</ul>
</li>
<li>非关系型数据库的优点<ul>
<li>不需要经过SQL层的解析，读写效率高。</li>
<li>基于键值对，数据的扩展性很好。</li>
<li>可以支持多种类型数据的存储，如图片，文档等等。</li>
</ul>
</li>
</ul>
<h4 id="2、什么是非关系型数据库？"><a href="#2、什么是非关系型数据库？" class="headerlink" title="2、什么是非关系型数据库？"></a>2、什么是非关系型数据库？</h4><ul>
<li>非关系型数据库也叫NOSQL，采用键值对的形式进行存储。它的读写性能很高，易于扩展，可分为内存性数据库以及文档型数据库，比如 Redis，Mongodb，HBase等等。</li>
<li>适合使用非关系型数据库的场景：日志系统、地理位置存储、数据量巨大、高可用</li>
</ul>
<h4 id="3、为什么使用索引？"><a href="#3、为什么使用索引？" class="headerlink" title="3、为什么使用索引？"></a>3、为什么使用索引？</h4><ul>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>帮助服务器避免排序和临时表</li>
<li>将随机IO变为顺序IO。</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
</ul>
<h4 id="4、Innodb为什么要用自增id作为主键？"><a href="#4、Innodb为什么要用自增id作为主键？" class="headerlink" title="4、Innodb为什么要用自增id作为主键？"></a>4、Innodb为什么要用自增id作为主键？</h4><ul>
<li>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。 </li>
<li>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置， 频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE（optimize table）来重建表并优化填充页面</li>
</ul>
<h4 id="5、MyISAM和InnoDB实现B树索引方式的区别是什么？"><a href="#5、MyISAM和InnoDB实现B树索引方式的区别是什么？" class="headerlink" title="5、MyISAM和InnoDB实现B树索引方式的区别是什么？"></a>5、MyISAM和InnoDB实现B树索引方式的区别是什么？</h4><ul>
<li><p>MyISAM，B+Tree叶节点的data域存放的是数据记录的地址，在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，这被称为“非聚簇索引”</p>
</li>
<li><p>InnoDB，其数据文件本身就是索引文件，相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的节点data域保存了完整的数据记录，这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引，这被称为“聚簇索引”或者聚集索引，而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。</p>
<p>在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。因此，在设计表的时候，不建议使用过长的字段为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>
</li>
</ul>
<h2 id="Redis笔记整理"><a href="#Redis笔记整理" class="headerlink" title="Redis笔记整理"></a>Redis笔记整理</h2><h4 id="1、听说过Redis吗？它是什么？"><a href="#1、听说过Redis吗？它是什么？" class="headerlink" title="1、听说过Redis吗？它是什么？"></a>1、听说过Redis吗？它是什么？</h4><ul>
<li>Redis是一个<strong>数据库</strong>，不过与传统数据库不同的是Redis的数据库是存在<strong>内存</strong>中，所以<strong>读写速度非常快</strong>，因此 Redis被广泛应用于<strong>缓存</strong>方向。</li>
<li>除此之外，Redis也经常用来做分布式锁，Redis提供了多种数据类型来支持不同的业务场景。除此之外，Redis 支持事务持久化、LUA脚本、LRU驱动事件、多种集群方案。</li>
</ul>
<h4 id="2、Redis的五种数据结构整理"><a href="#2、Redis的五种数据结构整理" class="headerlink" title="2、Redis的五种数据结构整理"></a>2、Redis的五种数据结构整理</h4><ul>
<li><p>简单动态字符串(Simple Dynamic String，SDS)</p>
<ul>
<li>Redis没有直接使用C语言传统的字符串，而是自己构建了一种名为简单动态字符串（Simple dynamic string，SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。</li>
<li>其实SDS等同于C语言中的char * ，但它可以存储任意二进制数据，不能像C语言字符串那样以字符’\0’来标识字符串的结 束，因此它必然有个长度字段。</li>
<li><strong>优点</strong>：获取字符串长度的复杂度为O(1)；杜绝缓冲区溢出；减少修改字符串长度时所需要的内存重分配次数；二进制安全；兼容部分C字符串函数。</li>
</ul>
</li>
<li><p>链表：当有一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的额字符串时，Redis就会使用链表作为列表建的底层实现。</p>
<ul>
<li>链表被广泛用于实现Redis的各种功能，比如列表建、发布与订阅、慢查询、监视器等。</li>
<li>每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表。</li>
<li>每个链表使用一个list结构表示，这个结构带有表头节点指针、表尾节点指针，以及链表长度等信息。</li>
<li>因为链表表头的前置节点和表尾节点的后置节点都指向NULL，所以Redis的链表实现是无环链表。</li>
<li>通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值。</li>
</ul>
</li>
<li><p>字典的底层是哈希表，类似 C++中的 map ，也就是键值对。</p>
<ul>
<li>字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键。</li>
<li>Redis中的字典使用哈希表作为底层结构实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用。</li>
<li>Redis使用MurmurHash2算法来计算键的哈希值。</li>
<li>哈希表使用链地址法来解决键冲突。</li>
</ul>
</li>
<li><p>跳表：</p>
<ul>
<li>跳跃表是有序集合的底层实现之一</li>
<li>Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点</li>
<li>每个跳跃表节点的层高都是1至32之间的随机数</li>
<li>在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。</li>
<li>跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。</li>
<li>跳表是一种实现起来很简单，单层多指针的链表，它查找效率很高，堪比优化过的二叉平衡树，且比平衡树的实现。</li>
</ul>
</li>
<li><p>压缩列表</p>
<ul>
<li>ziplist是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</li>
</ul>
</li>
</ul>
<h4 id="3、Redis常见数据结构以及使用场景分别是什么？"><a href="#3、Redis常见数据结构以及使用场景分别是什么？" class="headerlink" title="3、Redis常见数据结构以及使用场景分别是什么？"></a>3、Redis常见数据结构以及使用场景分别是什么？</h4><ul>
<li><p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key-value缓存应用； 常规计数：微博数，粉丝数等。</p>
</li>
<li><p>Hash 是一个 string 类型的 ﬁeld 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，你可以直接仅 仅修改这个对象中的某个字段的值。 比如我们可以Hash数据结构来存储用户信息，商品信息等。</p>
</li>
<li><p>list 就是链表，Redis list 的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表， 消息列表等功能都可以用Redis的 list 结构来实现。</p>
<ul>
<li>Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</li>
<li>另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功 能，基于 Redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。</li>
</ul>
</li>
<li><p>set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的</p>
<ul>
<li>当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在 一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。</li>
<li>比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常 方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程，具体命令如下：<code>sinterstore key1 key2 key3</code>将交集存在key1内。</li>
</ul>
</li>
<li><p><strong>sorted set：</strong>和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。</p>
<p>举例： 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维 度的消息排行榜）等信息，适合使用 Redis 中的 SortedSet 结构进行存储。</p>
</li>
</ul>
<h4 id="4、有MySQL不就够用了吗？为什么要用Redis这种新的数据库？"><a href="#4、有MySQL不就够用了吗？为什么要用Redis这种新的数据库？" class="headerlink" title="4、有MySQL不就够用了吗？为什么要用Redis这种新的数据库？"></a>4、有MySQL不就够用了吗？为什么要用Redis这种新的数据库？</h4><p>主要是因为 Redis 具备高性能和高并发两种特性。</p>
<ul>
<li><strong>高性能</strong>：假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</li>
<li><strong>高并发</strong>：直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库</li>
</ul>
<h4 id="5、C-中的Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存？"><a href="#5、C-中的Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存？" class="headerlink" title="5、C++中的Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存？"></a>5、C++中的Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存？</h4><ul>
<li>严格意义上来说缓存分为<strong>本地缓存</strong>和<strong>分布式缓存</strong>。</li>
<li>C++ STL 下自带的容器 map 只能实现本地缓存，它最主要的特点是轻量以及快速，但是其生命周期随着程序的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</li>
<li>使用 Redis 或 Memcached 之类的称为分布式缓存，在多实例的情况下，各实例共享一份缓存数据，缓存具有一致性。这是Redis或者Memcached的优点所在，但它也有缺点，那就是需要保持 Redis 或 Memcached服务的高可用，整个程序架构上较为复杂</li>
</ul>
<h4 id="6、使用Redis的好处有哪些？"><a href="#6、使用Redis的好处有哪些？" class="headerlink" title="6、使用Redis的好处有哪些？"></a>6、使用Redis的好处有哪些？</h4><ul>
<li>访问速度快，因为数据存在内存中，类似于Java中的HashMap或者C++中的哈希表（如unordered_map&#x2F;unordered_set），这两者的优势就是查找和操作的时间复杂度都是O(1)</li>
<li>数据类型丰富，支持String，list，set，sorted set，hash这五种数据结构</li>
<li>支持事务，Redis中的操作都是原子性，换句话说就是对数据的更改要么全部执行，要么全部不执行，这就是原子性的定义</li>
<li>特性丰富：Redis可用于缓存，消息，按key设置过期时间，过期后将会自动删除。</li>
</ul>
<h4 id="7、Memcached与Redis的区别都有哪些？"><a href="#7、Memcached与Redis的区别都有哪些？" class="headerlink" title="7、Memcached与Redis的区别都有哪些？"></a>7、Memcached与Redis的区别都有哪些？</h4><ul>
<li><p>存储方式</p>
<ul>
<li><p>Memecache把数据全部存在内存之中，断电后会挂掉，没有持久化功能，数据不能超过内存大小。</p>
</li>
<li><p>Redis有部份存在硬盘上，这样能保证数据的持久性。</p>
</li>
</ul>
</li>
<li><p>数据支持类型</p>
<ul>
<li><p>Memcache对数据类型支持相对简单,只有String这一种类型</p>
</li>
<li><p>Redis有复杂的数据类型。Redis不仅仅支持简单的k&#x2F;v类型的数据，同时还提供 list，set，zset，hash等数据结构的存储</p>
</li>
</ul>
</li>
<li><p>使用底层模型不同</p>
<ul>
<li>它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li>
</ul>
</li>
<li><p>集群模式：Memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前 是原生支持 cluster 模式的.</p>
</li>
<li><p>Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。</p>
</li>
<li><p>Value 值大小不同：Redis 最大可以达到 512MB；Memcached 只有 1MB。</p>
</li>
</ul>
<h4 id="8、Redis比Memcached的优势在哪里？"><a href="#8、Redis比Memcached的优势在哪里？" class="headerlink" title="8、Redis比Memcached的优势在哪里？"></a>8、Redis比Memcached的优势在哪里？</h4><ul>
<li>Memcached所有的值均是简单字符串，Redis作为其替代者，支持更为丰富的数据类型</li>
<li>Redis 的速度比 Memcached 快很多</li>
<li>Redis可以做到持久化数据</li>
</ul>
<h4 id="9、缓存中常说的热点数据和冷数据是什么？"><a href="#9、缓存中常说的热点数据和冷数据是什么？" class="headerlink" title="9、缓存中常说的热点数据和冷数据是什么？"></a>9、缓存中常说的热点数据和冷数据是什么？</h4><ul>
<li>热数据就是访问次数较多的数据，冷数据就是访问很少或者从不访问的数据。</li>
<li>需要注意的是只有热点数据，缓存才有价值；对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。</li>
<li><strong>数据更新前至少读取两次</strong>，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。</li>
</ul>
<h4 id="10、Redis-为什么是单线程的而不采用多线程方案？"><a href="#10、Redis-为什么是单线程的而不采用多线程方案？" class="headerlink" title="10、Redis 为什么是单线程的而不采用多线程方案？"></a>10、Redis 为什么是单线程的而不采用多线程方案？</h4><ul>
<li>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦）</li>
</ul>
<h4 id="11、单线程的Redis为什么这么快？"><a href="#11、单线程的Redis为什么这么快？" class="headerlink" title="11、单线程的Redis为什么这么快？"></a>11、单线程的Redis为什么这么快？</h4><ul>
<li>Redis的全部操作都是纯内存的操作；</li>
<li>Redis采用单线程，有效避免了频繁的上下文切换；</li>
<li>采用了非阻塞I&#x2F;O多路复用机制。</li>
</ul>
<h4 id="12、了解Redis的线程模型吗？可以大致说说吗？"><a href="#12、了解Redis的线程模型吗？可以大致说说吗？" class="headerlink" title="12、了解Redis的线程模型吗？可以大致说说吗？"></a>12、了解Redis的线程模型吗？可以大致说说吗？</h4><ul>
<li><p>Redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。</p>
</li>
<li><p>文件事件处理器的结构包含 4 个部分：</p>
<ul>
<li>多个 socket</li>
<li>IO多路复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
</li>
<li><p>使用 I&#x2F;O 多路复用程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p>
</li>
<li><p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p>
</li>
</ul>
<h4 id="13、Redis设置过期时间的两种方案是什么？"><a href="#13、Redis设置过期时间的两种方案是什么？" class="headerlink" title="13、Redis设置过期时间的两种方案是什么？"></a>13、Redis设置过期时间的两种方案是什么？</h4><ul>
<li>Redis中有个设置时间过期的功能，即对存储在 Redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库， 这是非常实用的，比如一些 token 或者登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。</li>
<li>我们 set key 的时候，都可以给一个 expire time，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间，主要可采用<strong>定期删除和惰性删除</strong>两种方案。</li>
<li>定期删除：Redis默认是每隔 100ms 就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。<ul>
<li>为什么要随机呢？假如 Redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载</li>
</ul>
</li>
<li>惰性删除 ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。它是指某个键值过期后,此键值不会马上被删除,而是等到下次被使用的时候,才会被检查到过期,此时才能得到删除,惰性删除的缺点很明显是浪费内存。除非系统去查一下那个 key，才会被Redis给删除掉。</li>
</ul>
<h4 id="14、定期和惰性一定能保证删除数据吗？如果不能，Redis会有什么应对措施？"><a href="#14、定期和惰性一定能保证删除数据吗？如果不能，Redis会有什么应对措施？" class="headerlink" title="14、定期和惰性一定能保证删除数据吗？如果不能，Redis会有什么应对措施？"></a>14、定期和惰性一定能保证删除数据吗？如果不能，Redis会有什么应对措施？</h4><ul>
<li><p>并不能保证一定删除，Redis有一个Redis 内存淘汰机制来确保数据一定会被删除。</p>
</li>
<li><p>在Redis.conf中有一行配置:maxmemory-policy volatile-lru，该配置就是配内存淘汰策略的，主要有以下六种方案：</p>
<ul>
<li><strong>volatile-lru</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰 </li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰 </li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰 </li>
<li><strong>allkeys-lru</strong>：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰 </li>
<li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰 </li>
<li><strong>no-enviction</strong>（驱逐）：禁止驱逐数据，新写入操作会报错</li>
</ul>
</li>
<li><p>如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。</p>
</li>
</ul>
<h4 id="15、Redis对于大量的请求，是怎样处理的？"><a href="#15、Redis对于大量的请求，是怎样处理的？" class="headerlink" title="15、Redis对于大量的请求，是怎样处理的？"></a>15、Redis对于大量的请求，是怎样处理的？</h4><ul>
<li>Redis是一个单线程程序，也就说同一时刻它只能处理一个客户端请求； </li>
<li>Redis是通过IO多路复用（select，epoll，kqueue，依据不同的平台，采取不同的实现）来处理多个客户端请求。</li>
</ul>
</article><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/202307192211377.png" target="_blank"><img class="post-qr-code-img" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/202307192211377.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/202307192207910.png" target="_blank"><img class="post-qr-code-img" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/202307192207910.png" alt="alipayautoh"/></a><div class="post-qr-code-desc">alipayautoh</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://acall.love/2023/03/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=undefined&amp;url=http://acall.love/2023/03/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/&amp;pic=undefined" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/C/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>C++<span class="tagsPageCount">23</span></a><a class="post-meta__box__tags" href="/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>后端开发<span class="tagsPageCount">22</span></a><a class="post-meta__box__tags" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>面试<span class="tagsPageCount">3</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/d6g1gl.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://npm.elemecdn.com/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><div class="post-copyright"><i class="anzhiyufont anzhiyu-icon-copyright"></i><div class="post-copyright__author"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://acall.love/2023/03/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/">原创</a><a class="post-copyright-title"><span>学习笔记面试合集</span></a></div><div class="post-copyright-info-box"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"></span><a class="link" href="http://acall.love">🎵张小佑♪</a></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a class="link" href="http://acall.love/2023/03/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/">http://acall.love/2023/03/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/</a></span><span class="copy-button" onclick="rm.copyPageUrl('http://acall.love/2023/03/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/')"><i class="anzhiyufont anzhiyu-icon-copy"></i></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://acall.love" target="_blank">♪张小佑</a>！</span></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/20/day12%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/gp8z6l.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">12.C++入门</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/jx5yq5.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">设计模式之美 读书心得</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/05/01/1.%E4%B8%AA%E4%BA%BA%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/" title="1.个人问题"><img class="cover" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/p9918p.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-05-01</div><div class="title">1.个人问题</div></div></a></div><div><a href="/2023/04/05/2.%E7%B3%BB%E5%88%97%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" title="2.系统知识点整理"><img class="cover" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/mpxy18.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-05</div><div class="title">2.系统知识点整理</div></div></a></div><div><a href="/2023/06/05/2.C++%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="2.C++读书笔记"><img class="cover" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/gp5k23.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-06-05</div><div class="title">2.C++读书笔记</div></div></a></div><div><a href="/2023/06/01/1.C++%E5%B2%97%E4%BD%8D%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E5%AE%9D%E5%85%B8/" title="1.C++岗位面试真题宝典"><img class="cover" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/iTab-p92mj3%20(2).webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-06-01</div><div class="title">1.C++岗位面试真题宝典</div></div></a></div><div><a href="/2023/05/05/2.%E6%9E%81%E5%AE%A2%E4%B8%93%E6%A0%8F%E7%AC%94%E8%AE%B0/" title="2.极客笔记"><img class="cover" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/o5g6r7.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-05-05</div><div class="title">2.极客笔记</div></div></a></div><div><a href="/2023/06/10/3.C++%20%E9%9D%A2%E8%AF%95%E7%AA%81%E7%A0%B4/" title="3.面试突破"><img class="cover" src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/d6g1gl.webp" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-06-10</div><div class="title">3.面试突破</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">学习笔记操作系统面经整理：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-number">1.0.1.</span> <span class="toc-text">1、进程、线程和协程的区别和联系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.0.2.</span> <span class="toc-text">2、线程与进程的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%92%8C%E4%BB%80%E4%B9%88%E6%9C%89%E5%85%B3%EF%BC%9F"><span class="toc-number">1.0.3.</span> <span class="toc-text">3、一个进程可以创建多少线程，和什么有关？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%A4%96%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.0.4.</span> <span class="toc-text">4、外中断和异常有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%BD%A0%E7%9F%A5%E9%81%93%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">1.0.5.</span> <span class="toc-text">5、进程线程模型你知道多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">1.0.6.</span> <span class="toc-text">6、进程调度算法你了解多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81Linux%E4%B8%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.0.7.</span> <span class="toc-text">7、Linux下进程间通信方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81Linux%E4%B8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">1.0.8.</span> <span class="toc-text">8、Linux下同步机制？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81%E5%A6%82%E6%9E%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E5%90%8E%EF%BC%8C%E9%82%A3%E4%B9%88%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B%E5%8F%98%E6%88%90%E4%BB%80%E4%B9%88%E6%A0%B7%E4%BA%86%EF%BC%9F"><span class="toc-number">1.0.9.</span> <span class="toc-text">9、如果系统中具有快表后，那么地址的转换过程变成什么样了？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E5%92%8C%E8%A6%86%E7%9B%96%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.0.10.</span> <span class="toc-text">10、内存交换和覆盖有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F%E5%8F%AF%E4%BB%A5%E5%88%86%E5%88%AB%E8%AF%B4%E8%AF%B4%E5%90%97%EF%BC%9F"><span class="toc-number">1.0.11.</span> <span class="toc-text">11、动态分区分配算法有哪几种？可以分别说说吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E3%80%81%E8%99%9A%E6%8B%9F%E6%8A%80%E6%9C%AF%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">1.0.12.</span> <span class="toc-text">12、虚拟技术你了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E3%80%81%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2%E4%BD%A0%E7%9F%A5%E9%81%93%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">1.0.13.</span> <span class="toc-text">13、进程状态的切换你知道多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E3%80%81%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E4%BB%8E%E5%BC%80%E5%A7%8B%E8%BF%90%E8%A1%8C%E5%88%B0%E7%BB%93%E6%9D%9F%E7%9A%84%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B%EF%BC%8C%E4%BD%A0%E8%83%BD%E8%AF%B4%E5%87%BA%E6%9D%A5%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">1.0.14.</span> <span class="toc-text">14、一个程序从开始运行到结束的完整过程，你能说出来多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15%E3%80%81%E9%80%9A%E8%BF%87%E4%BE%8B%E5%AD%90%E8%AE%B2%E8%A7%A3%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B"><span class="toc-number">1.0.15.</span> <span class="toc-text">15、通过例子讲解逻辑地址转换为物理地址的基本过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16%E3%80%81%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.0.16.</span> <span class="toc-text">16、进程同步的四种方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9C%A8%E5%AF%B9%E5%86%85%E5%AD%98%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%81%9A%E4%BA%9B%E4%BB%80%E4%B9%88"><span class="toc-number">1.0.17.</span> <span class="toc-text">17、操作系统在对内存进行管理的时候需要做些什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18%E3%80%81%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E6%B3%95%EF%BC%88Linux%E5%92%8Cwindows%E4%B8%8B%EF%BC%89%EF%BC%8C%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E6%B3%95%EF%BC%88Linux%E5%92%8Cwindows%E4%B8%8B%EF%BC%89"><span class="toc-number">1.0.18.</span> <span class="toc-text">18、进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.19.</span> <span class="toc-text">20、虚拟内存的目的是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E7%90%86%E8%A7%A3%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%EF%BC%9F%E4%BB%96%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%E5%91%A2%EF%BC%9F"><span class="toc-number">1.0.20.</span> <span class="toc-text">21、说一下你理解中的内存？他有什么作用呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E4%B9%8B%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.21.</span> <span class="toc-text">22、操作系统经典问题之哲学家进餐问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E4%B9%8B%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.22.</span> <span class="toc-text">23、操作系统经典问题之读者-写者问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24%E3%80%81%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%87%A0%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%9A%84%E9%94%81%EF%BC%9F"><span class="toc-number">1.0.23.</span> <span class="toc-text">24、介绍一下几种典型的锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25%E3%80%81%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80VS%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-number">1.0.24.</span> <span class="toc-text">25、逻辑地址VS物理地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28%E3%80%81%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">1.0.25.</span> <span class="toc-text">28、内存交换是什么？有什么特点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E7%9A%84%E4%BA%A4%E6%8D%A2%EF%BC%9F"><span class="toc-number">1.0.26.</span> <span class="toc-text">29、什么时候会进行内存的交换？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30%E3%80%81%E7%BB%88%E7%AB%AF%E9%80%80%E5%87%BA%EF%BC%8C%E7%BB%88%E7%AB%AF%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BC%9A%E6%80%8E%E6%A0%B7"><span class="toc-number">1.0.27.</span> <span class="toc-text">30、终端退出，终端运行的进程会怎样</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E3%80%81%E5%A6%82%E4%BD%95%E8%AE%A9%E8%BF%9B%E7%A8%8B%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C"><span class="toc-number">1.0.28.</span> <span class="toc-text">31、如何让进程后台运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%BF%AB%E8%A1%A8%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E5%A4%9A%E5%B0%91%E5%85%B3%E4%BA%8E%E5%BF%AB%E8%A1%A8%E7%9A%84%E7%9F%A5%E8%AF%86%EF%BC%9F"><span class="toc-number">1.0.29.</span> <span class="toc-text">32、什么是快表，你知道多少关于快表的知识？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34%E3%80%81%E5%9C%A8%E6%89%A7%E8%A1%8Cmalloc%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F"><span class="toc-number">1.0.30.</span> <span class="toc-text">34、在执行malloc申请内存的时候，操作系统是怎么做的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#35%E3%80%81-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.0.31.</span> <span class="toc-text">35、 守护进程、僵尸进程和孤儿进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#36%E3%80%81%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.0.32.</span> <span class="toc-text">36、如何避免僵尸进程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#37%E3%80%81%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F%E4%B8%BB%E8%A6%81%E6%9C%89%E5%93%AA%E4%B8%A4%E5%A4%A7%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%EF%BC%9F%E5%90%84%E8%87%AA%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.33.</span> <span class="toc-text">37、局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#38%E3%80%81%E7%88%B6%E8%BF%9B%E7%A8%8B%E3%80%81%E5%AD%90%E8%BF%9B%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E7%BB%84%E3%80%81%E4%BD%9C%E4%B8%9A%E5%92%8C%E4%BC%9A%E8%AF%9D"><span class="toc-number">1.0.34.</span> <span class="toc-text">38、父进程、子进程、进程组、作业和会话</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#39%E3%80%81%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.0.35.</span> <span class="toc-text">39、进程终止的几种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40%E3%80%81Linux%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.36.</span> <span class="toc-text">40、Linux中异常和中断的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#41%E3%80%81Windows%E5%92%8CLinux%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5"><span class="toc-number">1.0.37.</span> <span class="toc-text">41、Windows和Linux环境下内存分布情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42%E3%80%81%E4%B8%80%E4%B8%AA%E7%94%B1C-x2F-C-%E7%BC%96%E8%AF%91%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%8D%A0%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E4%B8%BA%E5%93%AA%E5%87%A0%E4%B8%AA%E9%83%A8%E5%88%86%EF%BC%9F"><span class="toc-number">1.0.38.</span> <span class="toc-text">42、一个由C&#x2F;C++编译的程序占用的内存分为哪几个部分？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#43%E3%80%81%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B%E5%9C%A8Linux-x2F-windows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E6%A0%88%E7%A9%BA%E9%97%B4%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.0.39.</span> <span class="toc-text">43、一般情况下在Linux&#x2F;windows平台下栈空间的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#44%E3%80%81%E7%A8%8B%E5%BA%8F%E4%BB%8E%E5%A0%86%E4%B8%AD%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E6%97%B6%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%8A%E6%80%8E%E4%B9%88%E6%93%8D%E4%BD%9C%E7%9A%84"><span class="toc-number">1.0.40.</span> <span class="toc-text">44、程序从堆中动态分配内存时，虚拟内存上怎么操作的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#45%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.0.41.</span> <span class="toc-text">45、常见的几种磁盘调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#46%E3%80%81%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4%E4%B8%8E%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.0.42.</span> <span class="toc-text">46、交换空间与虚拟内存的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#47%E3%80%81%E6%8A%96%E5%8A%A8%E4%BD%A0%E7%9F%A5%E9%81%93%E6%98%AF%E4%BB%80%E4%B9%88%E5%90%97%EF%BC%9F%E5%AE%83%E4%B9%9F%E5%8F%AB%E9%A2%A0%E7%B0%B8%E7%8E%B0%E8%B1%A1"><span class="toc-number">1.0.43.</span> <span class="toc-text">47、抖动你知道是什么吗？它也叫颠簸现象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#48%E3%80%81%E4%BB%8E%E5%A0%86%E5%92%8C%E6%A0%88%E4%B8%8A%E5%BB%BA%E7%AB%8B%E5%AF%B9%E8%B1%A1%E5%93%AA%E4%B8%AA%E5%BF%AB%EF%BC%9F%EF%BC%88%E8%80%83%E5%AF%9F%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%88%86%E9%85%8D%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83%EF%BC%89"><span class="toc-number">1.0.44.</span> <span class="toc-text">48、从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#49%E3%80%81%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.0.45.</span> <span class="toc-text">49、常见内存分配方式有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#50%E3%80%81%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF"><span class="toc-number">1.0.46.</span> <span class="toc-text">50、常见内存分配内存错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#51%E3%80%81%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E4%B8%AD%EF%BC%8C%E8%A2%AB%E6%8D%A2%E5%87%BA%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">1.0.47.</span> <span class="toc-text">51、内存交换中，被换出的进程保存在哪里？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#52%E3%80%81%E5%9C%A8%E5%8F%91%E7%94%9F%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E6%97%B6%EF%BC%8C%E6%9C%89%E4%BA%9B%E8%BF%9B%E7%A8%8B%E6%98%AF%E8%A2%AB%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E7%9A%84%EF%BC%9F%E4%BD%A0%E5%8F%AF%E4%BB%A5%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%90%97%EF%BC%9F"><span class="toc-number">1.0.48.</span> <span class="toc-text">52、在发生内存交换时，有些进程是被优先考虑的？你可以说一说吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#53%E3%80%81ASCII%E3%80%81Unicode%E5%92%8CUTF-8%E7%BC%96%E7%A0%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.0.49.</span> <span class="toc-text">53、ASCII、Unicode和UTF-8编码的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#54%E3%80%81%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">1.0.50.</span> <span class="toc-text">54、原子操作的是如何实现的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#55%E3%80%81%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E4%BD%A0%E7%9F%A5%E9%81%93%E6%9C%89%E5%93%AA%E4%BA%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%85%B3%E9%94%AE%E7%82%B9%E5%90%97%EF%BC%9F"><span class="toc-number">1.0.51.</span> <span class="toc-text">55、内存交换你知道有哪些需要注意的关键点吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#56%E3%80%81%E7%B3%BB%E7%BB%9F%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%EF%BC%8C%E5%88%86%E5%BE%97%E6%B8%85%E5%90%97%EF%BC%9F"><span class="toc-number">1.0.52.</span> <span class="toc-text">56、系统并发和并行，分得清吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#57%E3%80%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-number">1.0.53.</span> <span class="toc-text">57、页面置换算法总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#58%E3%80%81%E5%85%B1%E4%BA%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.54.</span> <span class="toc-text">58、共享是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#59%E3%80%81%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-number">1.0.55.</span> <span class="toc-text">59、死锁问题总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#60%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%86%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%9C%89%E5%A4%96%E9%83%A8%E7%A2%8E%E7%89%87%E8%80%8C%E6%97%A0%E5%86%85%E9%83%A8%E7%A2%8E%E7%89%87%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E6%9C%89%E5%86%85%E9%83%A8%E7%A2%8E%E7%89%87%E8%80%8C%E4%B8%8D%E4%BC%9A%E6%9C%89%E5%A4%96%E9%83%A8%E7%A2%8E%E7%89%87%EF%BC%9F"><span class="toc-number">1.0.56.</span> <span class="toc-text">60、为什么分段式存储管理有外部碎片而无内部碎片？为什么固定分区分配有内部碎片而不会有外部碎片？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#61%E3%80%81%E5%86%85%E9%83%A8%E7%A2%8E%E7%89%87%E4%B8%8E%E5%A4%96%E9%83%A8%E7%A2%8E%E7%89%87"><span class="toc-number">1.0.57.</span> <span class="toc-text">61、内部碎片与外部碎片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#62%E3%80%81%E5%A6%82%E4%BD%95%E6%B6%88%E9%99%A4%E7%A2%8E%E7%89%87%E6%96%87%E4%BB%B6"><span class="toc-number">1.0.58.</span> <span class="toc-text">62、如何消除碎片文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#63%E3%80%81%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E5%87%A0%E4%B8%AA%E6%A8%A1%E5%9D%97%EF%BC%9F%E5%88%86%E5%88%AB%E5%AF%B9%E5%BA%94%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%93%AA%E5%87%A0%E4%B8%AA%E9%83%A8%E5%88%86%EF%BC%9F"><span class="toc-number">1.0.59.</span> <span class="toc-text">63、冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#64%E3%80%81%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%8D%A2%E5%8F%A5%E8%AF%9D%E8%AF%B4%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.0.60.</span> <span class="toc-text">64、多进程和多线程的区别是什么？换句话说，什么时候该用多线程，什么时候该用多进程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#65%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%BD%A0%E7%9F%A5%E9%81%93%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">1.0.61.</span> <span class="toc-text">65、服务器高并发的解决方案你知道多少？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BF%E7%A7%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%AE%A1%E7%BD%91%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">阿秀学习笔记计网面经整理：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81OSI-%E7%9A%84%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%88%86%E5%88%AB%E6%98%AF%EF%BC%9F%E5%90%84%E8%87%AA%E7%9A%84%E5%8A%9F%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.0.1.</span> <span class="toc-text">1、OSI 的七层模型分别是？各自的功能是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9%EF%BC%9F"><span class="toc-number">2.0.2.</span> <span class="toc-text">2、说一下一次完整的HTTP请求过程包括哪些内容？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%BD%A0%E7%9F%A5%E9%81%93DNS%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.0.3.</span> <span class="toc-text">3、你知道DNS是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81DNS%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">2.0.4.</span> <span class="toc-text">4、DNS的工作原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%94%A8UDP%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-number">2.0.5.</span> <span class="toc-text">5、为什么域名解析用UDP协议？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8C%BA%E5%9F%9F%E4%BC%A0%E9%80%81%E7%94%A8TCP%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-number">2.0.6.</span> <span class="toc-text">6、为什么区域传送用TCP协议？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81HTTP%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.0.7.</span> <span class="toc-text">7、HTTP长连接和短连接的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFTCP%E7%B2%98%E5%8C%85-x2F-%E6%8B%86%E5%8C%85%EF%BC%9F%E5%8F%91%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-number">2.0.8.</span> <span class="toc-text">8、什么是TCP粘包&#x2F;拆包？发生的原因？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%9A%E7%BC%93%E5%AD%98%E8%BF%99%E4%B8%80%E9%A1%B9%E5%8A%9F%E8%83%BD-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">2.0.9.</span> <span class="toc-text">9、为什么服务器会缓存这一项功能?如何实现的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E4%BD%A0%E7%9F%A5%E9%81%93%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">2.0.10.</span> <span class="toc-text">10、HTTP请求方法你知道多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81GET-%E5%92%8C-POST-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.0.11.</span> <span class="toc-text">11、GET 和 POST 的区别，你知道哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E3%80%81%E4%B8%80%E4%B8%AATCP%E8%BF%9E%E6%8E%A5%E5%8F%AF%E4%BB%A5%E5%AF%B9%E5%BA%94%E5%87%A0%E4%B8%AAHTTP%E8%AF%B7%E6%B1%82%EF%BC%9F"><span class="toc-number">2.0.12.</span> <span class="toc-text">12、一个TCP连接可以对应几个HTTP请求？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E3%80%81%E4%B8%80%E4%B8%AA-TCP-%E8%BF%9E%E6%8E%A5%E4%B8%AD-HTTP-%E8%AF%B7%E6%B1%82%E5%8F%91%E9%80%81%E5%8F%AF%E4%BB%A5%E4%B8%80%E8%B5%B7%E5%8F%91%E9%80%81%E4%B9%88%EF%BC%88%E6%AF%94%E5%A6%82%E4%B8%80%E8%B5%B7%E5%8F%91%E4%B8%89%E4%B8%AA%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%86%8D%E4%B8%89%E4%B8%AA%E5%93%8D%E5%BA%94%E4%B8%80%E8%B5%B7%E6%8E%A5%E6%94%B6%EF%BC%89%EF%BC%9F"><span class="toc-number">2.0.13.</span> <span class="toc-text">13、一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E5%90%8C%E4%B8%80-Host-%E5%BB%BA%E7%AB%8B-TCP-%E8%BF%9E%E6%8E%A5%E5%88%B0%E7%9A%84%E6%95%B0%E9%87%8F%E6%9C%89%E6%B2%A1%E6%9C%89%E9%99%90%E5%88%B6%EF%BC%9F"><span class="toc-number">2.0.14.</span> <span class="toc-text">14、浏览器对同一 Host 建立 TCP 连接到的数量有没有限制？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15%E3%80%81%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5url%E5%9C%B0%E5%9D%80%E5%90%8E%E6%98%BE%E7%A4%BA%E4%B8%BB%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">2.0.15.</span> <span class="toc-text">15、在浏览器中输入url地址后显示主页的过程?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16%E3%80%81%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAURL%E5%90%8E%E5%9B%9E%E8%BD%A6%EF%BC%8C%E8%83%8C%E5%90%8E%E4%BC%9A%E8%BF%9B%E8%A1%8C%E5%93%AA%E4%BA%9B%E6%8A%80%E6%9C%AF%E6%AD%A5%E9%AA%A4%EF%BC%9F"><span class="toc-number">2.0.16.</span> <span class="toc-text">16、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17%E3%80%81%E8%B0%88%E8%B0%88DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%8C%E5%85%B7%E4%BD%93%E4%B8%80%E7%82%B9"><span class="toc-number">2.0.17.</span> <span class="toc-text">17、谈谈DNS解析过程，具体一点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18%E3%80%81DNS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%98%AF%E4%BB%80%E4%B9%88%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-number">2.0.18.</span> <span class="toc-text">18、DNS负载均衡是什么策略？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19%E3%80%81HTTPS%E5%92%8CHTTP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.0.19.</span> <span class="toc-text">19、HTTPS和HTTP的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFSSL-x2F-TLS-%EF%BC%9F"><span class="toc-number">2.0.20.</span> <span class="toc-text">20、什么是SSL&#x2F;TLS ？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21%E3%80%81HTTPS%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%89%E5%85%A8%EF%BC%8C%E6%95%B4%E4%BD%93%E7%9A%84%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88SSL%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%89"><span class="toc-number">2.0.21.</span> <span class="toc-text">21、HTTPS是如何保证数据传输的安全，整体的流程是什么？（SSL是怎么工作保证安全的）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22%E3%80%81%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%85%AC%E9%92%A5%E4%B8%8D%E8%A2%AB%E7%AF%A1%E6%94%B9%EF%BC%9F"><span class="toc-number">2.0.22.</span> <span class="toc-text">22、如何保证公钥不被篡改？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23%E3%80%81HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%BB%E8%A6%81%E5%AD%97%E6%AE%B5%EF%BC%9F"><span class="toc-number">2.0.23.</span> <span class="toc-text">23、HTTP请求和响应报文有哪些主要字段？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24%E3%80%81Cookie%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.0.24.</span> <span class="toc-text">24、Cookie是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25%E3%80%81Cookie%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%E9%80%94%EF%BC%9F%E7%94%A8%E9%80%94"><span class="toc-number">2.0.25.</span> <span class="toc-text">25、Cookie有什么用途？用途</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26%E3%80%81Session%E7%9F%A5%E8%AF%86%E5%A4%A7%E6%80%BB%E7%BB%93"><span class="toc-number">2.0.26.</span> <span class="toc-text">26、Session知识大总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27%E3%80%81Session-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.0.27.</span> <span class="toc-text">27、Session 的工作原理是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28%E3%80%81Cookie%E4%B8%8ESession%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">2.0.28.</span> <span class="toc-text">28、Cookie与Session的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29%E3%80%81SQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">2.0.29.</span> <span class="toc-text">29、SQL注入攻击了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFRARP%EF%BC%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.0.30.</span> <span class="toc-text">31、什么是RARP？工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E3%80%81%E7%AB%AF%E5%8F%A3%E6%9C%89%E6%95%88%E8%8C%83%E5%9B%B4%E6%98%AF%E5%A4%9A%E5%B0%91%E5%88%B0%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">2.0.31.</span> <span class="toc-text">32、端口有效范围是多少到多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33%E3%80%81%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E6%8A%8A-TCP-x2F-IP-%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%88%86%E6%88%90-5-%E5%B1%82%EF%BC%88%E6%88%967%E5%B1%82%EF%BC%89%EF%BC%9F"><span class="toc-number">2.0.32.</span> <span class="toc-text">33、为何需要把 TCP&#x2F;IP 协议栈分成 5 层（或7层）？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BF%E7%A7%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0C-%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">阿秀学习笔记C++面经整理：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.</span> <span class="toc-text">C++常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81-%E5%9C%A8main%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%89%8D%E5%92%8C%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.1.1.</span> <span class="toc-text">1、 在main执行之前和之后执行的代码可能是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">3.1.2.</span> <span class="toc-text">2、结构体内存对齐问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.3.</span> <span class="toc-text">3、指针和引用的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%9C%A8%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%97%B6%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%E5%91%A2%EF%BC%9F"><span class="toc-number">3.1.4.</span> <span class="toc-text">4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.5.</span> <span class="toc-text">5、堆和栈的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E4%BD%A0%E8%A7%89%E5%BE%97%E5%A0%86%E5%BF%AB%E4%B8%80%E7%82%B9%E8%BF%98%E6%98%AF%E6%A0%88%E5%BF%AB%E4%B8%80%E7%82%B9%EF%BC%9F"><span class="toc-number">3.1.6.</span> <span class="toc-text">6、你觉得堆快一点还是栈快一点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E5%8C%BA%E5%88%AB%E4%BB%A5%E4%B8%8B%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.7.</span> <span class="toc-text">7、区别以下指针类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81new-x2F-delete-%E4%B8%8E-malloc-x2F-free%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">3.1.8.</span> <span class="toc-text">8、new &#x2F; delete 与 malloc &#x2F; free的异同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81new%E5%92%8Cdelete%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">3.1.9.</span> <span class="toc-text">9、new和delete是如何实现的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81%E6%97%A2%E7%84%B6%E6%9C%89%E4%BA%86malloc-x2F-free%EF%BC%8CC-%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81new-x2F-delete%E5%91%A2%EF%BC%9F%E7%9B%B4%E6%8E%A5%E7%94%A8malloc-x2F-free%E4%B8%8D%E5%A5%BD%E5%90%97%EF%BC%9F"><span class="toc-number">3.1.10.</span> <span class="toc-text">11、既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？直接用malloc&#x2F;free不好吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E3%80%81%E8%A2%ABfree%E5%9B%9E%E6%94%B6%E7%9A%84%E5%86%85%E5%AD%98%E6%98%AF%E7%AB%8B%E5%8D%B3%E8%BF%94%E8%BF%98%E7%BB%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%97%EF%BC%9F"><span class="toc-number">3.1.11.</span> <span class="toc-text">12、被free回收的内存是立即返还给操作系统吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E3%80%81%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8C%E5%87%BD%E6%95%B0%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.1.12.</span> <span class="toc-text">13、宏定义和函数有何区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E3%80%81%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8Ctypedef%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.1.13.</span> <span class="toc-text">14、宏定义和typedef区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15%E3%80%81%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.1.14.</span> <span class="toc-text">15、变量声明和定义区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16%E3%80%81strlen%E5%92%8Csizeof%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.1.15.</span> <span class="toc-text">16、strlen和sizeof区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-2%E3%80%81%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E5%8D%A0%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82%EF%BC%9F"><span class="toc-number">3.1.16.</span> <span class="toc-text">16.2、一个指针占多少字节？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17%E3%80%81%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.1.17.</span> <span class="toc-text">17、常量指针和指针常量区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18%E3%80%81a%E5%92%8C-amp-a%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.1.18.</span> <span class="toc-text">18、a和&amp;a有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19%E3%80%81C-%E5%92%8CPython%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.19.</span> <span class="toc-text">19、C++和Python的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20%E3%80%81C-%E5%92%8CC%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.20.</span> <span class="toc-text">20、C++和C语言的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21%E3%80%81C-%E4%B8%8EJava%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.21.</span> <span class="toc-text">21、C++与Java的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22%E3%80%81C-%E4%B8%ADstruct%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.22.</span> <span class="toc-text">22、C++中struct和class的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%92%8CC%E7%9A%84struct%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">3.1.23.</span> <span class="toc-text">C++和C的struct区别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23%E3%80%81define%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.24.</span> <span class="toc-text">23、define宏定义和const的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24%E3%80%81C-%E4%B8%ADconst%E5%92%8Cstatic%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.1.25.</span> <span class="toc-text">24、C++中const和static的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25%E3%80%81C-%E7%9A%84%E9%A1%B6%E5%B1%82const%E5%92%8C%E5%BA%95%E5%B1%82const"><span class="toc-number">3.1.26.</span> <span class="toc-text">25、C++的顶层const和底层const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26%E3%80%81%E6%95%B0%E7%BB%84%E5%90%8D%E5%92%8C%E6%8C%87%E9%92%88%EF%BC%88%E8%BF%99%E9%87%8C%E4%B8%BA%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E9%A6%96%E5%85%83%E7%B4%A0%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%89%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.1.27.</span> <span class="toc-text">26、数组名和指针（这里为指向数组首元素的指针）区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27%E3%80%81final%E5%92%8Coverride%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.1.28.</span> <span class="toc-text">27、final和override关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28%E3%80%81%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.1.29.</span> <span class="toc-text">28、拷贝初始化和直接初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%B5%8B%E5%80%BC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.30.</span> <span class="toc-text">29、初始化和赋值的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30%E3%80%81extern%E2%80%9DC%E2%80%9D%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">3.1.31.</span> <span class="toc-text">30、extern”C”的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E3%80%81%E9%87%8E%E6%8C%87%E9%92%88%E5%92%8C%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-number">3.1.32.</span> <span class="toc-text">31、野指针和悬空指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E3%80%81C%E5%92%8CC-%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8"><span class="toc-number">3.1.33.</span> <span class="toc-text">32、C和C++的类型安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33%E3%80%81C-%E4%B8%AD%E7%9A%84%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%EF%BC%88%E8%A6%86%E7%9B%96%EF%BC%89%E5%92%8C%E9%9A%90%E8%97%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.34.</span> <span class="toc-text">33、C++中的重载、重写（覆盖）和隐藏的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34%E3%80%81C-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.35.</span> <span class="toc-text">34、C++有哪几种的构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#35%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.36.</span> <span class="toc-text">35、浅拷贝和深拷贝的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#36%E3%80%81%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.37.</span> <span class="toc-text">36、内联函数和宏定义的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#37%E3%80%81public%EF%BC%8Cprotected%E5%92%8Cprivate%E8%AE%BF%E9%97%AE%E5%92%8C%E7%BB%A7%E6%89%BF%E6%9D%83%E9%99%90%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.1.38.</span> <span class="toc-text">37、public，protected和private访问和继承权限的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#38%E3%80%81%E5%A6%82%E4%BD%95%E7%94%A8%E4%BB%A3%E7%A0%81%E5%88%A4%E6%96%AD%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8%EF%BC%9F"><span class="toc-number">3.1.39.</span> <span class="toc-text">38、如何用代码判断大小端存储？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#39%E3%80%81volatile%E3%80%81mutable%E5%92%8Cexplicit%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">3.1.40.</span> <span class="toc-text">39、volatile、mutable和explicit关键字的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40%E3%80%81%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%B0%83%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.41.</span> <span class="toc-text">40、什么情况下会调用拷贝构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#41%E3%80%81C-%E4%B8%AD%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84new"><span class="toc-number">3.1.42.</span> <span class="toc-text">41、C++中有几种类型的new</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42%E3%80%81C-%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.43.</span> <span class="toc-text">42、C++的异常处理的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#43%E3%80%81static%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">3.1.44.</span> <span class="toc-text">43、static的用法和作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#44%E3%80%81%E6%8C%87%E9%92%88%E5%92%8Cconst%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">3.1.45.</span> <span class="toc-text">44、指针和const的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#45%E3%80%81%E5%BD%A2%E5%8F%82%E4%B8%8E%E5%AE%9E%E5%8F%82%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.1.46.</span> <span class="toc-text">45、形参与实参的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#46%E3%80%81%E5%80%BC%E4%BC%A0%E9%80%92%E3%80%81%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E3%80%81%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E6%95%88%E7%8E%87"><span class="toc-number">3.1.47.</span> <span class="toc-text">46、值传递、指针传递、引用传递的区别和效率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#47%E3%80%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.1.48.</span> <span class="toc-text">47、静态变量什么时候初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#49%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-number">3.1.49.</span> <span class="toc-text">49、什么是类的继承？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#50%E3%80%81%E4%BB%8E%E6%B1%87%E7%BC%96%E5%B1%82%E5%8E%BB%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E5%BC%95%E7%94%A8"><span class="toc-number">3.1.50.</span> <span class="toc-text">50、从汇编层去解释一下引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#53%E3%80%81delete-p%E3%80%81delete-p%E3%80%81allocator%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">3.1.51.</span> <span class="toc-text">53、delete p、delete [] p、allocator都有什么作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#54%E3%80%81new%E5%92%8Cdelete%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%8C-delete%E6%98%AF%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%9A%84%EF%BC%9F"><span class="toc-number">3.1.52.</span> <span class="toc-text">54、new和delete的实现原理， delete是如何知道释放内存的大小的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#55%E3%80%81malloc%E7%94%B3%E8%AF%B7%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E8%83%BD%E7%94%A8delete%E9%87%8A%E6%94%BE%E5%90%97"><span class="toc-number">3.1.53.</span> <span class="toc-text">55、malloc申请的存储空间能用delete释放吗?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#56%E3%80%81malloc%E4%B8%8Efree%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">3.1.54.</span> <span class="toc-text">56、malloc与free的实现原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#57%E3%80%81malloc%E3%80%81realloc%E3%80%81calloc%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.55.</span> <span class="toc-text">57、malloc、realloc、calloc的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#58%E3%80%81%E7%B1%BB%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E4%BC%9A%E5%BF%AB%E4%B8%80%E4%BA%9B"><span class="toc-number">3.1.56.</span> <span class="toc-text">58、类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#59%E3%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E5%BF%85%E9%A1%BB%E7%94%A8%E5%88%B0%E6%88%90%E5%91%98%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9F%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.1.57.</span> <span class="toc-text">59、有哪些情况必须用到成员列表初始化？作用是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#60%E3%80%81C-%E4%B8%AD%E6%96%B0%E5%A2%9E%E4%BA%86string%EF%BC%8C%E5%AE%83%E4%B8%8EC%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84-char-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%90%97%EF%BC%9F%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">3.1.58.</span> <span class="toc-text">60、C++中新增了string，它与C语言中的 char *有什么区别吗？它是如何实现的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#61%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%8C%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%81%BF%E5%85%8D"><span class="toc-number">3.1.59.</span> <span class="toc-text">61、什么是内存泄露，如何检测与避免</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#62%E3%80%81%E5%AF%B9%E8%B1%A1%E5%A4%8D%E7%94%A8%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="toc-number">3.1.60.</span> <span class="toc-text">62、对象复用的了解，零拷贝的了解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#63%E3%80%81%E4%BB%8B%E7%BB%8D%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%8C%E5%B9%B6%E4%B8%94%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">3.1.61.</span> <span class="toc-text">63、介绍面向对象的三大特性，并且举例说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#64%E3%80%81%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E5%AE%83%E4%BC%9A%E5%BF%AB%E4%B8%80%E4%BA%9B%EF%BC%9F"><span class="toc-number">3.1.62.</span> <span class="toc-text">64、成员初始化列表的概念，为什么用它会快一些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2reinterpret-cast-x2F-const-cast-x2F-static-cast-x2F-dynamic-cast"><span class="toc-number">3.1.63.</span> <span class="toc-text">C++的四种强制转换reinterpret_cast &#x2F; const_cast &#x2F; static_cast &#x2F; dynamic_cast</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#66%E3%80%81C-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%8E%8B%E6%A0%88%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.64.</span> <span class="toc-text">66、C++函数调用的压栈过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#67%E3%80%81%E5%86%99C-%E4%BB%A3%E7%A0%81%E6%97%B6%E6%9C%89%E4%B8%80%E7%B1%BB%E9%94%99%E8%AF%AF%E6%98%AF-coredump-%EF%BC%8C%E5%BE%88%E5%B8%B8%E8%A7%81%EF%BC%8C%E4%BD%A0%E9%81%87%E5%88%B0%E8%BF%87%E5%90%97%EF%BC%9F%E6%80%8E%E4%B9%88%E8%B0%83%E8%AF%95%E8%BF%99%E4%B8%AA%E9%94%99%E8%AF%AF%EF%BC%9F"><span class="toc-number">3.1.65.</span> <span class="toc-text">67、写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#68%E3%80%81%E8%AF%B4%E8%AF%B4%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.66.</span> <span class="toc-text">68、说说移动构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#69%E3%80%81C-%E4%B8%AD%E5%B0%86%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.67.</span> <span class="toc-text">69、C++中将临时变量作为返回值时的处理过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#70%E3%80%81%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98%E7%9B%B8%E5%AF%B9%E4%BA%8E%E7%BB%93%E6%9E%84%E5%BC%80%E5%A4%B4%E7%9A%84%E5%AD%97%E8%8A%82%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="toc-number">3.1.68.</span> <span class="toc-text">70、如何获得结构成员相对于结构开头的字节偏移量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#71%E3%80%81%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%EF%BC%8C%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.69.</span> <span class="toc-text">71、静态类型和动态类型，静态绑定和动态绑定的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#72%E3%80%81%E5%BC%95%E7%94%A8%E6%98%AF%E5%90%A6%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">3.1.70.</span> <span class="toc-text">72、引用是否能实现动态绑定，为什么可以实现？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#73%E3%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.1.71.</span> <span class="toc-text">73、全局变量和局部变量有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#74%E3%80%81%E6%8C%87%E9%92%88%E5%8A%A0%E5%87%8F%E8%AE%A1%E7%AE%97%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.1.72.</span> <span class="toc-text">74、指针加减计算要注意什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#75%E3%80%81-%E6%80%8E%E6%A0%B7%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%B5%AE%E7%82%B9%E6%95%B0%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89%EF%BC%9F"><span class="toc-number">3.1.73.</span> <span class="toc-text">75、 怎样判断两个浮点数是否相等？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#76%E3%80%81%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%88%E6%A0%88%EF%BC%8C%E6%B1%87%E7%BC%96%EF%BC%89"><span class="toc-number">3.1.74.</span> <span class="toc-text">76、方法调用的原理（栈，汇编）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#77%E3%80%81C-%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="toc-number">3.1.75.</span> <span class="toc-text">77、C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#78%E3%80%81%E7%B1%BB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AA%E8%83%BD%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D%E5%92%8C%E5%8F%AA%E8%83%BD%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-number">3.1.76.</span> <span class="toc-text">78、类如何实现只能静态分配和只能动态分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#79%E3%80%81%E5%A6%82%E6%9E%9C%E6%83%B3%E5%B0%86%E6%9F%90%E4%B8%AA%E7%B1%BB%E7%94%A8%E4%BD%9C%E5%9F%BA%E7%B1%BB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%A5%E7%B1%BB%E5%BF%85%E9%A1%BB%E5%AE%9A%E4%B9%89%E8%80%8C%E9%9D%9E%E5%A3%B0%E6%98%8E%EF%BC%9F"><span class="toc-number">3.1.77.</span> <span class="toc-text">79、如果想将某个类用作基类，为什么该类必须定义而非声明？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#80%E3%80%81-%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6%E4%B8%AD%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2%EF%BC%9F%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="toc-number">3.1.78.</span> <span class="toc-text">80、 继承机制中对象之间如何转换？指针和引用之间如何转换？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#81%E3%80%81%E7%9F%A5%E9%81%93C-%E4%B8%AD%E7%9A%84%E7%BB%84%E5%90%88%E5%90%97%EF%BC%9F%E5%AE%83%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9B%B8%E6%AF%94%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%E5%90%97%EF%BC%9F"><span class="toc-number">3.1.79.</span> <span class="toc-text">81、知道C++中的组合吗？它与继承相比有什么优缺点吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#82%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">3.1.80.</span> <span class="toc-text">82、什么是函数指针?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#83%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.1.81.</span> <span class="toc-text">83、说一说你理解的内存对齐以及原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#84%E3%80%81-%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E6%AF%94%E8%BE%83%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89"><span class="toc-number">3.1.82.</span> <span class="toc-text">84、 结构体变量比较是否相等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#85%E3%80%81-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E6%A0%88%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E5%92%8C%E5%8F%82%E6%95%B0%E5%8F%98%E9%87%8F%E5%93%AA%E4%B8%AA%E5%85%88%E5%85%A5%E6%A0%88%EF%BC%9F"><span class="toc-number">3.1.83.</span> <span class="toc-text">85、 函数调用过程栈的变化，返回值和参数变量哪个先入栈？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#86%E3%80%81define%E3%80%81const%E3%80%81typedef%E3%80%81inline%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9F%E4%BB%96%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.1.84.</span> <span class="toc-text">86、define、const、typedef、inline的使用方法？他们之间有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#87%E3%80%81%E4%BD%A0%E7%9F%A5%E9%81%93printf%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%E5%90%97"><span class="toc-number">3.1.85.</span> <span class="toc-text">87、你知道printf函数的实现原理是什么吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#88%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A8%A1%E6%9D%BF%E7%B1%BB%E4%B8%80%E8%88%AC%E9%83%BD%E6%98%AF%E6%94%BE%E5%9C%A8%E4%B8%80%E4%B8%AAh%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="toc-number">3.1.86.</span> <span class="toc-text">88、为什么模板类一般都是放在一个h文件中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#89%E3%80%81C-%E4%B8%AD%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E5%92%8C%E7%BB%A7%E6%89%BF%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.87.</span> <span class="toc-text">89、C++中类成员的访问权限和继承权限问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#90%E3%80%81cout%E5%92%8Cprintf%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.1.88.</span> <span class="toc-text">90、cout和printf有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#91%E3%80%81%E4%BD%A0%E7%9F%A5%E9%81%93%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%90%97%EF%BC%9F"><span class="toc-number">3.1.89.</span> <span class="toc-text">91、你知道重载运算符吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#92%E3%80%81%E5%BD%93%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%9C%89%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%97%B6%EF%BC%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%E5%92%8C%E9%A1%BA%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.1.90.</span> <span class="toc-text">92、当程序中有函数重载时，函数的匹配原则和顺序是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#93%E3%80%81%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.91.</span> <span class="toc-text">93、定义和声明的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#94%E3%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8Cstatic%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.92.</span> <span class="toc-text">94、全局变量和static变量的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#95%E3%80%81-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%8E%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.1.93.</span> <span class="toc-text">95、 静态成员与普通成员的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#96%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84-ifdef-endif%E4%BB%A3%E8%A1%A8%E7%9D%80%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.1.94.</span> <span class="toc-text">96、说一下你理解的 ifdef endif代表着什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#97%E3%80%81%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%EF%BC%8C%E5%A6%82%E4%BD%95%E6%B6%88%E9%99%A4%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="toc-number">3.1.95.</span> <span class="toc-text">97、隐式转换，如何消除隐式转换？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#98%E3%80%81C-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E5%BC%82%E5%B8%B8%E7%9A%84%EF%BC%9F"><span class="toc-number">3.1.96.</span> <span class="toc-text">98、C++如何处理多个异常的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#100%E3%80%81%E4%BD%A0%E7%9F%A5%E9%81%93strcpy%E5%92%8Cmemcpy%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E5%90%97%EF%BC%9F"><span class="toc-number">3.1.97.</span> <span class="toc-text">100、你知道strcpy和memcpy的区别是什么吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#101%E3%80%81%E7%A8%8B%E5%BA%8F%E5%9C%A8%E6%89%A7%E8%A1%8Cint-main-int-argc-char-argv-%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%8C%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">3.1.98.</span> <span class="toc-text">101、程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#102%E3%80%81volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">3.1.99.</span> <span class="toc-text">102、volatile关键字的作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#104%E3%80%81C-%E4%B8%AD%E6%A0%87%E5%87%86%E5%BA%93%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.1.100.</span> <span class="toc-text">104、C++中标准库是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#105%E3%80%81%E4%BD%A0%E7%9F%A5%E9%81%93const-char-%E4%B8%8Estring%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88%E5%90%97%EF%BC%9F"><span class="toc-number">3.1.101.</span> <span class="toc-text">105、你知道const char* 与string之间的关系是什么吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#106%E3%80%81%E4%BD%A0%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E7%94%A8%E6%8C%87%E9%92%88%E5%BD%93%E5%8F%82%E6%95%B0%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%BC%95%E7%94%A8%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.1.102.</span> <span class="toc-text">106、你什么情况用指针当参数，什么时候用引用，为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#107%E3%80%81%E4%BD%A0%E7%9F%A5%E9%81%93%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E5%90%97%EF%BC%9F%E8%AE%B2%E8%AE%B2%EF%BC%9F"><span class="toc-number">3.1.103.</span> <span class="toc-text">107、你知道静态绑定和动态绑定吗？讲讲？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#108%E3%80%81%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E8%AE%A1%E7%AE%97%E4%BB%85%E5%8D%95%E4%B8%AA%E5%AD%90%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%AA%E6%95%B0%EF%BC%9F"><span class="toc-number">3.1.104.</span> <span class="toc-text">108、如何设计一个计算仅单个子类的对象个数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#109%E3%80%81%E6%80%8E%E4%B9%88%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E9%94%99%E8%AF%AF%E5%87%BA%E7%8E%B0%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">3.1.105.</span> <span class="toc-text">109、怎么快速定位错误出现的地方?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#110%E3%80%81%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E4%BC%9A%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%88%B0%EF%BC%9F%E5%AE%83%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.1.106.</span> <span class="toc-text">110、成员初始化列表会在什么时候用到？它的调用过程是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#111%E3%80%81%E5%9C%A8%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BB%A5%E5%8F%8A%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%A0%E9%80%92%E6%97%B6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%E6%88%96%E8%80%85%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%8C%E5%85%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%E7%9A%84%E5%A5%BD%E5%A4%84%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">3.1.107.</span> <span class="toc-text">111、在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#112%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4strcpy%E3%80%81sprintf%E4%B8%8Ememcpy%E8%BF%99%E4%B8%89%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-number">3.1.108.</span> <span class="toc-text">112、说一说strcpy、sprintf与memcpy这三个函数的不同之处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#114%E3%80%81%E4%BD%A0%E7%9F%A5%E9%81%93%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB%E5%90%97%EF%BC%9F"><span class="toc-number">3.1.109.</span> <span class="toc-text">114、你知道数组和指针的区别吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#115%E3%80%81%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%B8%80%E4%B8%AA%E7%B1%BB%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">3.1.110.</span> <span class="toc-text">115、如何阻止一个类被实例化？有哪些方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#116%E3%80%81-%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">3.1.111.</span> <span class="toc-text">116、 如何禁止程序自动生成拷贝构造函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#117%E3%80%81%E4%BD%A0%E7%9F%A5%E9%81%93Debug%E5%92%8CRelease%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E5%90%97%EF%BC%9F"><span class="toc-number">3.1.112.</span> <span class="toc-text">117、你知道Debug和Release的区别是什么吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#118%E3%80%81main%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E6%9C%89%E4%BB%80%E4%B9%88%E5%80%BC%E5%BE%97%E8%80%83%E7%A9%B6%E4%B9%8B%E5%A4%84%E5%90%97%EF%BC%9F"><span class="toc-number">3.1.113.</span> <span class="toc-text">118、main函数的返回值有什么值得考究之处吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#120%E3%80%81strcpy%E5%87%BD%E6%95%B0%E5%92%8Cstrncpy%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%93%AA%E4%B8%AA%E5%87%BD%E6%95%B0%E6%9B%B4%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">3.1.114.</span> <span class="toc-text">120、strcpy函数和strncpy函数的区别？哪个函数更安全？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#121%E3%80%81static-cast%E6%AF%94C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%BC%BA%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">3.1.115.</span> <span class="toc-text">121、static_cast比C语言中的转换强在哪里？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#122%E3%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%87%8Cmemset-this-0-sizeof-this-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-number">3.1.116.</span> <span class="toc-text">122、成员函数里memset(this,0,sizeof(*this))会发生什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#123%E3%80%81%E4%BD%A0%E7%9F%A5%E9%81%93%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F%E5%AE%83%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">3.1.117.</span> <span class="toc-text">123、你知道回调函数吗？它的作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#125%E3%80%81C-%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.1.118.</span> <span class="toc-text">125、C++从代码到可执行程序经历了什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#126%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%EF%BC%88%E5%8F%8B%E5%85%83%E5%B7%A5%E5%8E%82%EF%BC%89%E5%BF%85%E9%A1%BB%E5%9C%A8%E7%B1%BB%E5%86%85%E9%83%A8%E5%A3%B0%E6%98%8E%EF%BC%9F"><span class="toc-number">3.1.119.</span> <span class="toc-text">126、为什么友元函数（友元工厂）必须在类内部声明？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#127%E3%80%81%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5"><span class="toc-number">3.1.120.</span> <span class="toc-text">127、友元函数和友元类的基本情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#129%E3%80%81%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91%E4%B8%8E%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91"><span class="toc-number">3.1.121.</span> <span class="toc-text">129、动态编译与静态编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#132%E3%80%81delete%E5%92%8Cdelete-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.1.122.</span> <span class="toc-text">132、delete和delete[]区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#133%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%8A%8A%E6%89%80%E6%9C%89%E7%9A%84%E5%87%BD%E6%95%B0%E5%86%99%E6%88%90%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.123.</span> <span class="toc-text">133、为什么不能把所有的函数写成内联函数?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#134%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88C-%E6%B2%A1%E6%9C%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%9F%E8%BF%99%E7%82%B9%E8%B7%9FJava%E4%B8%8D%E5%A4%AA%E4%B8%80%E6%A0%B7%E3%80%82"><span class="toc-number">3.1.124.</span> <span class="toc-text">134、为什么C++没有垃圾回收机制？这点跟Java不太一样。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">C++ 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%EF%BC%9F"><span class="toc-number">3.2.1.</span> <span class="toc-text">1、类的对象存储空间？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8EC-%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%EF%BC%88%E5%8F%AF%E4%BB%A5%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84C-%E5%BE%97%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%90%97%EF%BC%9F%EF%BC%89"><span class="toc-number">3.2.2.</span> <span class="toc-text">2、简要说明C++的内存分区（可以说一下你了解的C++得内存管理吗？）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B1%A0%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.3.</span> <span class="toc-text">3、什么是内存池，如何实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81C-%E4%B8%AD%E7%B1%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5"><span class="toc-number">3.2.4.</span> <span class="toc-text">5、C++中类的数据成员和成员函数内存分布情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E5%85%B3%E4%BA%8Ethis%E6%8C%87%E9%92%88%E4%BD%A0%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88%EF%BC%9F%E5%85%A8%E8%AF%B4%E5%87%BA%E6%9D%A5"><span class="toc-number">3.2.5.</span> <span class="toc-text">6、关于this指针你知道什么？全说出来</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81A-this%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%9B%E5%BB%BA%E7%9A%84%EF%BC%9F"><span class="toc-number">3.2.6.</span> <span class="toc-text">7、A. this指针是什么时候创建的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-this%E6%8C%87%E9%92%88%E5%AD%98%E6%94%BE%E5%9C%A8%E4%BD%95%E5%A4%84%EF%BC%9F%E5%A0%86%E3%80%81%E6%A0%88%E3%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%EF%BC%8C%E8%BF%98%E6%98%AF%E5%85%B6%E4%BB%96%EF%BC%9F"><span class="toc-number">3.2.7.</span> <span class="toc-text">B. this指针存放在何处？堆、栈、全局变量，还是其他？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-this%E6%8C%87%E9%92%88%E6%98%AF%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E7%9A%84%EF%BC%9Fthis%E6%8C%87%E9%92%88%E5%8F%88%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E2%80%9C%E7%B1%BB%E5%AE%9E%E4%BE%8B%E5%90%8E%E5%87%BD%E6%95%B0%E7%9A%84%E2%80%9D%EF%BC%9F"><span class="toc-number">3.2.8.</span> <span class="toc-text">C. this指针是如何传递类中的函数的？this指针又是如何找到“类实例后函数的”？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-this%E6%8C%87%E9%92%88%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E7%9A%84%EF%BC%9F"><span class="toc-number">3.2.9.</span> <span class="toc-text">D. this指针是如何访问类中的变量的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#E-%E6%88%91%E4%BB%AC%E5%8F%AA%E6%9C%89%E8%8E%B7%E5%BE%97%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%90%8E%EF%BC%8C%E6%89%8D%E8%83%BD%E9%80%9A%E8%BF%87%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8this%E6%8C%87%E9%92%88%E3%80%82%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E7%9F%A5%E9%81%93%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1this%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F"><span class="toc-number">3.2.10.</span> <span class="toc-text">E.我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#F-%E6%AF%8F%E4%B8%AA%E7%B1%BB%E7%BC%96%E8%AF%91%E5%90%8E%EF%BC%8C%E6%98%AF%E5%90%A6%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%AD%E5%87%BD%E6%95%B0%E8%A1%A8%E4%BF%9D%E5%AD%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%8C%E4%BB%A5%E4%BE%BF%E7%94%A8%E6%9D%A5%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">3.2.11.</span> <span class="toc-text">F.每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%90%8E%E6%9E%9C%EF%BC%9F%E5%A6%82%E4%BD%95%E7%9B%91%E6%B5%8B%EF%BC%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">3.2.12.</span> <span class="toc-text">8、 内存泄漏的后果？如何监测？解决方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81%E5%9C%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8delete-this%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E5%AF%B9%E8%B1%A1%E8%BF%98%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F"><span class="toc-number">3.2.13.</span> <span class="toc-text">9、在成员函数中调用delete this会出现什么问题？对象还可以使用吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E9%A2%84%E6%9C%9F%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">3.2.14.</span> <span class="toc-text">10、为什么是不可预期的问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81-%E5%A6%82%E6%9E%9C%E5%9C%A8%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8delete-this%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.2.15.</span> <span class="toc-text">11、 如果在类的析构函数中调用delete this，会发生什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E3%80%81%E4%BD%A0%E7%9F%A5%E9%81%93%E7%A9%BA%E7%B1%BB%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%98%AF%E5%A4%9A%E5%B0%91%E5%90%97%EF%BC%9F"><span class="toc-number">3.2.16.</span> <span class="toc-text">12、你知道空类的大小是多少吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E3%80%81this%E6%8C%87%E9%92%88%E8%B0%83%E7%94%A8%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E6%97%B6%EF%BC%8C%E5%A0%86%E6%A0%88%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96%EF%BC%9F"><span class="toc-number">3.2.17.</span> <span class="toc-text">14、this指针调用成员变量时，堆栈会发生什么变化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15%E3%80%81%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%8F%97%E5%93%AA%E4%BA%9B%E5%9B%A0%E7%B4%A0%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-number">3.2.18.</span> <span class="toc-text">15、类对象的大小受哪些因素影响？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-11%E6%96%B0%E6%A0%87%E5%87%86"><span class="toc-number">3.3.</span> <span class="toc-text">C++11新标准</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81C-11%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">3.3.1.</span> <span class="toc-text">1、C++ 11有哪些新特性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81auto%E3%80%81decltype%E5%92%8Cdecltype-auto-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">3.3.2.</span> <span class="toc-text">2、auto、decltype和decltype(auto)的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81C-%E4%B8%ADNULL%E5%92%8Cnullptr%E5%8C%BA%E5%88%AB"><span class="toc-number">3.3.3.</span> <span class="toc-text">3、C++中NULL和nullptr区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.4.</span> <span class="toc-text">4、智能指针的原理、常用的智能指针及实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84%E5%85%B3%E4%BA%8Elambda%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%A8%E9%83%A8%E7%9F%A5%E8%AF%86"><span class="toc-number">3.3.5.</span> <span class="toc-text">5、说一说你了解的关于lambda函数的全部知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E8%AF%B4%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84auto-ptr%E4%BD%9C%E7%94%A8"><span class="toc-number">3.3.6.</span> <span class="toc-text">7、说说你了解的auto_ptr作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.7.</span> <span class="toc-text">8、智能指针的循环引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%B1%BB%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">3.3.8.</span> <span class="toc-text">9、手写实现智能指针类需要实现哪些函数？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B9%8BSTL%E6%A8%A1%E6%9D%BF%E5%BA%93"><span class="toc-number">3.4.</span> <span class="toc-text">C++之STL模板库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFSTL%EF%BC%9F"><span class="toc-number">3.4.1.</span> <span class="toc-text">1、什么是STL？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AFtrivial-destructor"><span class="toc-number">3.4.2.</span> <span class="toc-text">2、解释一下什么是trivial destructor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98%E8%B5%84%E6%BA%90%EF%BC%8CRAII%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%9F"><span class="toc-number">3.4.3.</span> <span class="toc-text">3、使用智能指针管理内存资源，RAII是怎么回事？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%9A-it%E3%80%81it-%E5%93%AA%E4%B8%AA%E5%A5%BD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">3.4.4.</span> <span class="toc-text">4、迭代器：++it、it++哪个好，为什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8BC-%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">3.4.5.</span> <span class="toc-text">5、说一下C++左值引用和右值引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81STL%E4%B8%ADhashtable%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">3.4.6.</span> <span class="toc-text">6、STL中hashtable的实现？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8Btraits%E6%8A%80%E6%B3%95"><span class="toc-number">3.4.7.</span> <span class="toc-text">7、简单说一下traits技法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81STL%E7%9A%84%E4%B8%A4%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8"><span class="toc-number">3.4.8.</span> <span class="toc-text">8、STL的两级空间配置器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81-vector%E4%B8%8Elist%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%BA%94%E7%94%A8%EF%BC%9F%E6%80%8E%E4%B9%88%E6%89%BE%E6%9F%90vector%E6%88%96%E8%80%85list%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-number">3.4.9.</span> <span class="toc-text">9、 vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81STL-%E4%B8%ADvector%E5%88%A0%E9%99%A4%E5%85%B6%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%A4%E5%80%8D%E6%89%A9%E5%AE%B9%EF%BC%9F%E9%87%8A%E6%94%BE%E7%A9%BA%E9%97%B4%EF%BC%9F"><span class="toc-number">3.4.10.</span> <span class="toc-text">10、STL 中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81Vector%E5%A6%82%E4%BD%95%E9%87%8A%E6%94%BE%E7%A9%BA%E9%97%B4"><span class="toc-number">3.4.11.</span> <span class="toc-text">11、Vector如何释放空间?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E3%80%81%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-number">3.4.12.</span> <span class="toc-text">12、容器内部删除一个元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E3%80%81STL%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.13.</span> <span class="toc-text">13、STL迭代器如何实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E3%80%81map%E3%80%81set%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E6%98%AF%E6%80%8E%E4%B9%88%E8%83%BD%E5%A4%9F%E5%90%8C%E6%97%B6%E5%AE%9E%E7%8E%B0%E8%BF%99%E4%B8%A4%E7%A7%8D%E5%AE%B9%E5%99%A8%EF%BC%9F-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F"><span class="toc-number">3.4.14.</span> <span class="toc-text">14、map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15%E3%80%81%E5%A6%82%E4%BD%95%E5%9C%A8%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%B8%8A%E4%BD%BF%E7%94%A8STL%E6%A0%87%E5%87%86%E5%BA%93%EF%BC%9F"><span class="toc-number">3.4.15.</span> <span class="toc-text">15、如何在共享内存上使用STL标准库？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16%E3%80%81map%E6%8F%92%E5%85%A5%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">3.4.16.</span> <span class="toc-text">16、map插入方式有哪几种？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17%E3%80%81STL%E4%B8%ADunordered-map-hash-map-%E5%92%8Cmap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8Chash-map%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81%E4%BB%A5%E5%8F%8A%E6%89%A9%E5%AE%B9"><span class="toc-number">3.4.17.</span> <span class="toc-text">17、STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18%E3%80%81vector%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE%E4%B8%8B%E6%A0%87%EF%BC%8Cmap%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE%E4%B8%8B%E6%A0%87%EF%BC%9Fvector%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E6%97%B6%E4%BC%9A%E4%B8%8D%E4%BC%9A%E9%87%8A%E6%94%BE%E7%A9%BA%E9%97%B4%EF%BC%9F"><span class="toc-number">3.4.18.</span> <span class="toc-text">18、vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19%E3%80%81map%E4%B8%AD-%E4%B8%8Efind%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.4.19.</span> <span class="toc-text">19、map中[]与find的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20%E3%80%81-STL%E4%B8%ADlist%E4%B8%8Edeque%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.4.20.</span> <span class="toc-text">20、 STL中list与deque之间的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21%E3%80%81STL%E4%B8%AD%E7%9A%84allocator%E3%80%81deallocator"><span class="toc-number">3.4.21.</span> <span class="toc-text">21、STL中的allocator、deallocator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22%E3%80%81STL%E4%B8%ADhash-table%E6%89%A9%E5%AE%B9%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.4.22.</span> <span class="toc-text">22、STL中hash table扩容发生什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23%E3%80%81%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E6%80%A7%E8%B4%A8%E6%80%BB%E7%BB%93%EF%BC%9F"><span class="toc-number">3.4.23.</span> <span class="toc-text">23、常见容器性质总结？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24%E3%80%81vector%E7%9A%84%E5%A2%9E%E5%8A%A0%E5%88%A0%E9%99%A4%E9%83%BD%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF1-5%E6%88%96%E8%80%85%E6%98%AF2%E5%80%8D%EF%BC%9F"><span class="toc-number">3.4.24.</span> <span class="toc-text">24、vector的增加删除都是怎么做的？为什么是1.5或者是2倍？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8BSTL%E6%AF%8F%E7%A7%8D%E5%AE%B9%E5%99%A8%E5%AF%B9%E5%BA%94%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">3.4.25.</span> <span class="toc-text">25、说一下STL每种容器对应的迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26%E3%80%81STL%E4%B8%AD%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">3.4.26.</span> <span class="toc-text">26、STL中迭代器失效的情况有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27%E3%80%81STL%E4%B8%ADvector%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.27.</span> <span class="toc-text">27、STL中vector的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28%E3%80%81STL%E4%B8%ADslist%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.28.</span> <span class="toc-text">28、STL中slist的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29%E3%80%81STL%E4%B8%ADlist%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.29.</span> <span class="toc-text">29、STL中list的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30%E3%80%81STL%E4%B8%AD%E7%9A%84deque%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.30.</span> <span class="toc-text">30、STL中的deque的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E3%80%81STL%E4%B8%ADstack%E5%92%8Cqueue%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.31.</span> <span class="toc-text">31、STL中stack和queue的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E3%80%81STL%E4%B8%AD%E7%9A%84heap%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.32.</span> <span class="toc-text">32、STL中的heap的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34%E3%80%81STL%E4%B8%ADset%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">3.4.33.</span> <span class="toc-text">34、STL中set的实现？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#35%E3%80%81STL%E4%B8%ADmap%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.34.</span> <span class="toc-text">35、STL中map的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#36%E3%80%81set%E5%92%8Cmap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8Cmultimap%E5%92%8Cmultiset%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.4.35.</span> <span class="toc-text">36、set和map的区别，multimap和multiset的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#37%E3%80%81STL%E4%B8%ADunordered-map%E5%92%8Cmap%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.4.36.</span> <span class="toc-text">37、STL中unordered_map和map的区别和应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#38%E3%80%81hashtable%E4%B8%AD%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">3.4.37.</span> <span class="toc-text">38、hashtable中解决冲突有哪些方法？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B9%8B%E5%85%B6%E4%BD%99%E9%97%AE%E9%A2%98"><span class="toc-number">3.5.</span> <span class="toc-text">C++之其余问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81C-%E7%9A%84%E5%A4%9A%E6%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.5.1.</span> <span class="toc-text">1、C++的多态如何实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%80%E8%88%AC%E5%86%99%E6%88%90%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">3.5.2.</span> <span class="toc-text">2、为什么析构函数一般写成虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%83%BD%E5%90%A6%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%E6%88%96%E8%80%85%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%91%A2%EF%BC%9F"><span class="toc-number">3.5.3.</span> <span class="toc-text">3、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%9F%BA%E7%B1%BB%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%AD%98%E6%94%BE%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E4%BB%80%E4%B9%88%E5%8C%BA%EF%BC%8C%E8%99%9A%E8%A1%A8%E6%8C%87%E9%92%88vptr%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E9%97%B4"><span class="toc-number">3.5.4.</span> <span class="toc-text">4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%9A%84%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="toc-number">3.5.5.</span> <span class="toc-text">5、模板函数和模板类的特例化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E5%8F%AF%E5%90%A6%E5%A3%B0%E6%98%8E%E4%B8%BA%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">3.5.6.</span> <span class="toc-text">6、构造函数、析构函数、虚函数可否声明为内联函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81C-%E6%A8%A1%E6%9D%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E5%BA%95%E5%B1%82%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">3.5.7.</span> <span class="toc-text">7、C++模板是什么，你知道底层怎么实现的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">3.5.8.</span> <span class="toc-text">8、构造函数为什么不能为虚函数？析构函数为什么要虚函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%A6%82%E4%BD%95%E8%B5%B7%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">3.5.9.</span> <span class="toc-text">9、析构函数的作用，如何起作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">3.5.10.</span> <span class="toc-text">10、构造函数和析构函数可以调用虚函数吗，为什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E7%9A%84%E5%86%85%E9%83%A8%E9%83%BD%E5%B9%B2%E4%BA%86%E5%95%A5%EF%BC%9F"><span class="toc-number">3.5.11.</span> <span class="toc-text">11、构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E5%90%A6%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">3.5.12.</span> <span class="toc-text">13、构造函数析构函数可否抛出异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15%E3%80%81%E7%B1%BB%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E6%9E%90%E6%9E%84%EF%BC%9F"><span class="toc-number">3.5.13.</span> <span class="toc-text">15、类什么时候会析构？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.5.14.</span> <span class="toc-text">17、构造函数的几种关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.5.15.</span> <span class="toc-text">18、构造函数、拷贝构造函数和赋值操作符的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.5.16.</span> <span class="toc-text">19、拷贝构造函数和赋值运算符重载的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF"><span class="toc-number">3.5.17.</span> <span class="toc-text">20、什么是虚拟继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21%E3%80%81%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">3.5.18.</span> <span class="toc-text">21、什么情况会自动生成默认构造函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22%E3%80%81%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">3.5.19.</span> <span class="toc-text">22、抽象基类为什么不能创建对象？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23%E3%80%81%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%92%8C%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.5.20.</span> <span class="toc-text">23、模板类和模板函数的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24%E3%80%81%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%8C%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%BC%80%E5%8F%91%E8%80%85%E6%80%8E%E4%B9%88%E7%9C%8B%E5%BE%85%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">3.5.21.</span> <span class="toc-text">24、多继承的优缺点，作为一个开发者怎么看待多继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25%E3%80%81%E6%A8%A1%E6%9D%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%86%99%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E9%87%8C%E9%9D%A2%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.5.22.</span> <span class="toc-text">25、模板和实现可不可以不写在一个文件里面？为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26%E3%80%81%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%80%9Chello-world%E2%80%9D%E4%BB%8E%E5%BC%80%E5%A7%8B%E5%88%B0%E6%89%93%E5%8D%B0%E5%88%B0%E5%B1%8F%E5%B9%95%E4%B8%8A%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">3.5.23.</span> <span class="toc-text">26、将字符串“hello world”从开始到打印到屏幕上的全过程?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E4%BC%A0%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E4%BC%A0%E5%80%BC%EF%BC%9F"><span class="toc-number">3.5.24.</span> <span class="toc-text">27、为什么拷贝构造函数必须传引用不能传值？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28%E3%80%81%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E8%83%BD%E5%AE%9A%E4%B9%89%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F%E5%B8%B8%E5%87%BD%E6%95%B0%E5%91%A2%EF%BC%9F%E8%AF%B4%E8%AF%B4%E4%BD%A0%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.5.25.</span> <span class="toc-text">28、静态函数能定义为虚函数吗？常函数呢？说说你的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%A3%E4%BB%B7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.5.26.</span> <span class="toc-text">29、虚函数的代价是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%88%B0%E7%9A%84%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">3.5.27.</span> <span class="toc-text">30、说一说你了解到的移动构造函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E3%80%81%E9%82%A3%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%90%88%E6%88%90%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%91%A2%EF%BC%9F"><span class="toc-number">3.5.28.</span> <span class="toc-text">32、那什么时候需要合成拷贝构造函数呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.5.29.</span> <span class="toc-text">33、构造函数的执行顺序是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#35%E3%80%81%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F%E6%8A%8A%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E8%AF%B4%E4%B8%80%E8%AF%B4"><span class="toc-number">3.5.30.</span> <span class="toc-text">35、哪些函数不能是虚函数？把你知道的都说一说</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#36%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.5.31.</span> <span class="toc-text">36、什么是纯虚函数，与虚函数的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">MySQL笔记整理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">4.0.1.</span> <span class="toc-text">1、关系型和非关系型数据库的区别你了解多少？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F"><span class="toc-number">4.0.2.</span> <span class="toc-text">2、什么是非关系型数据库？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">4.0.3.</span> <span class="toc-text">3、为什么使用索引？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81Innodb%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E8%87%AA%E5%A2%9Eid%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE%EF%BC%9F"><span class="toc-number">4.0.4.</span> <span class="toc-text">4、Innodb为什么要用自增id作为主键？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81MyISAM%E5%92%8CInnoDB%E5%AE%9E%E7%8E%B0B%E6%A0%91%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.0.5.</span> <span class="toc-text">5、MyISAM和InnoDB实现B树索引方式的区别是什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">Redis笔记整理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%90%AC%E8%AF%B4%E8%BF%87Redis%E5%90%97%EF%BC%9F%E5%AE%83%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.0.1.</span> <span class="toc-text">1、听说过Redis吗？它是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Redis%E7%9A%84%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%B4%E7%90%86"><span class="toc-number">5.0.2.</span> <span class="toc-text">2、Redis的五种数据结构整理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81Redis%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.0.3.</span> <span class="toc-text">3、Redis常见数据结构以及使用场景分别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E6%9C%89MySQL%E4%B8%8D%E5%B0%B1%E5%A4%9F%E7%94%A8%E4%BA%86%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Redis%E8%BF%99%E7%A7%8D%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F"><span class="toc-number">5.0.4.</span> <span class="toc-text">4、有MySQL不就够用了吗？为什么要用Redis这种新的数据库？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81C-%E4%B8%AD%E7%9A%84Map%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E7%BC%93%E5%AD%98%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8Map%EF%BC%8C%E8%80%8C%E9%80%89%E6%8B%A9Redis%E5%81%9A%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">5.0.5.</span> <span class="toc-text">5、C++中的Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E4%BD%BF%E7%94%A8Redis%E7%9A%84%E5%A5%BD%E5%A4%84%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">5.0.6.</span> <span class="toc-text">6、使用Redis的好处有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81Memcached%E4%B8%8ERedis%E7%9A%84%E5%8C%BA%E5%88%AB%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">5.0.7.</span> <span class="toc-text">7、Memcached与Redis的区别都有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81Redis%E6%AF%94Memcached%E7%9A%84%E4%BC%98%E5%8A%BF%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">5.0.8.</span> <span class="toc-text">8、Redis比Memcached的优势在哪里？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81%E7%BC%93%E5%AD%98%E4%B8%AD%E5%B8%B8%E8%AF%B4%E7%9A%84%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%E5%92%8C%E5%86%B7%E6%95%B0%E6%8D%AE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.0.9.</span> <span class="toc-text">9、缓存中常说的热点数据和冷数据是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81Redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%80%8C%E4%B8%8D%E9%87%87%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">5.0.10.</span> <span class="toc-text">10、Redis 为什么是单线程的而不采用多线程方案？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-number">5.0.11.</span> <span class="toc-text">11、单线程的Redis为什么这么快？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E3%80%81%E4%BA%86%E8%A7%A3Redis%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%90%97%EF%BC%9F%E5%8F%AF%E4%BB%A5%E5%A4%A7%E8%87%B4%E8%AF%B4%E8%AF%B4%E5%90%97%EF%BC%9F"><span class="toc-number">5.0.12.</span> <span class="toc-text">12、了解Redis的线程模型吗？可以大致说说吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E3%80%81Redis%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%A1%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.0.13.</span> <span class="toc-text">13、Redis设置过期时间的两种方案是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E3%80%81%E5%AE%9A%E6%9C%9F%E5%92%8C%E6%83%B0%E6%80%A7%E4%B8%80%E5%AE%9A%E8%83%BD%E4%BF%9D%E8%AF%81%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C%E4%B8%8D%E8%83%BD%EF%BC%8CRedis%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E5%BA%94%E5%AF%B9%E6%8E%AA%E6%96%BD%EF%BC%9F"><span class="toc-number">5.0.14.</span> <span class="toc-text">14、定期和惰性一定能保证删除数据吗？如果不能，Redis会有什么应对措施？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15%E3%80%81Redis%E5%AF%B9%E4%BA%8E%E5%A4%A7%E9%87%8F%E7%9A%84%E8%AF%B7%E6%B1%82%EF%BC%8C%E6%98%AF%E6%80%8E%E6%A0%B7%E5%A4%84%E7%90%86%E7%9A%84%EF%BC%9F"><span class="toc-number">5.0.15.</span> <span class="toc-text">15、Redis对于大量的请求，是怎样处理的？</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 🎵张小佑♪</div></div></footer></div></div></div><div id="sidebar"><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://acallcf.oss-cn-qingdao.aliyuncs.com/images/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child" style="left:17px;"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child" style="left:-79px;"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li></ul></div></div></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.4.0/source/js/utils.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.4.0/source/js/main.js"></script><script src="https://npm.elemecdn.com/hexo-theme-anzhiyu@1.4.0/source/js/tw_cn.js"></script><script src="https://npm.elemecdn.com/@fancyapps/ui@4.0.31/dist/fancybox.umd.js"></script><script src="https://npm.elemecdn.com/instant.page@5.1.1/instantpage.js" type="module"></script><script src="https://npm.elemecdn.com/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://npm.elemecdn.com/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("09/01/2022 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2022 By 安知鱼 1.4.0",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 🎵张小佑♪ 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anheyu.com";</script><script>//动态标题
let leaveTitle = '♪张小佑 - 分享思考与科技生活';
let backTitle = '♪张小佑 - 分享思考与科技生活';
let OriginTitile = document.title
let titleTime
document.addEventListener('visibilitychange', function () {
  if (document.hidden) {
    //离开当前页面时标签显示内容
    document.title = leaveTitle
    clearTimeout(titleTime)
  } else {
    //返回当前页面时标签显示内容
    document.title = backTitle + OriginTitile
    //两秒后变回正常标题
    titleTime = setTimeout(function () {
      document.title = OriginTitile
    }, 2000)
  }
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script>// 初始化函数
let rm = {};

//禁止图片与超链接拖拽
let aElements = document.getElementsByTagName("a");
for (let i = 0; i < aElements.length; i++) {
  aElements[i].setAttribute("draggable", "false");
  let imgElements = aElements[i].getElementsByTagName("img");
  for (let j = 0; j < imgElements.length; j++) {
    imgElements[j].setAttribute("draggable", "false");
  }
}

// 显示菜单
rm.showRightMenu = function (isTrue, x = 0, y = 0) {
  console.info(x, y)
  let rightMenu = document.getElementById("rightMenu");
  rightMenu.style.top = x + "px";
  rightMenu.style.left = y + "px";
  if (isTrue) {
    rightMenu.style.display = "block";
    stopMaskScroll();
  } else {
    rightMenu.style.display = "none";
  }
};

// 隐藏菜单
rm.hideRightMenu = function () {
  rm.showRightMenu(false);
  let rightMenuMask = document.querySelector("#rightmenu-mask");
  rightMenuMask.style.display = "none";
};

// 尺寸
let rmWidth = document.getElementById("rightMenu").offsetWidth;
let rmHeight = document.getElementById("rightMenu").offsetHeight;

// 重新定义尺寸
rm.reloadrmSize = function () {
  rightMenu.style.visibility = "hidden";
  rightMenu.style.display = "block";
  // 获取宽度和高度
  rmWidth = document.getElementById("rightMenu").offsetWidth;
  rmHeight = document.getElementById("rightMenu").offsetHeight;
  rightMenu.style.visibility = "visible";
};

// 获取点击的href
let domhref = "";
let domImgSrc = "";
let globalEvent = null;

var oncontextmenuFunction = function (event) {
  if (document.body.clientWidth > 768) {
    let pageX = event.clientX + 10; //加10是为了防止显示时鼠标遮在菜单上
    let pageY = event.clientY;

    //其他额外菜单
    const $rightMenuOther = document.querySelector(".rightMenuOther");
    const $rightMenuPlugin = document.querySelector(".rightMenuPlugin");
    const $rightMenuCopyText = document.querySelector("#menu-copytext");
    const $rightMenuPasteText = document.querySelector("#menu-pastetext");
    const $rightMenuCommentText = document.querySelector("#menu-commenttext");
    const $rightMenuNewWindow = document.querySelector("#menu-newwindow");
    const $rightMenuNewWindowImg = document.querySelector("#menu-newwindowimg");
    const $rightMenuCopyLink = document.querySelector("#menu-copylink");
    const $rightMenuCopyImg = document.querySelector("#menu-copyimg");
    const $rightMenuDownloadImg = document.querySelector("#menu-downloadimg");
    const $rightMenuSearch = document.querySelector("#menu-search");
    const $rightMenuSearchBaidu = document.querySelector("#menu-searchBaidu");
    const $rightMenuMusicToggle = document.querySelector("#menu-music-toggle");
    const $rightMenuMusicBack = document.querySelector("#menu-music-back");
    const $rightMenuMusicForward = document.querySelector("#menu-music-forward");
    const $rightMenuMusicPlaylist = document.querySelector("#menu-music-playlist");
    const $rightMenuMusicCopyMusicName = document.querySelector("#menu-music-copyMusicName");

    let href = event.target.href;
    let imgsrc = event.target.currentSrc;

    // 判断模式 扩展模式为有事件
    let pluginMode = false;
    $rightMenuOther.style.display = "block";
    globalEvent = event;

    // 检查是否需要复制 是否有选中文本
    if (selectTextNow && window.getSelection()) {
      pluginMode = true;
      $rightMenuCopyText.style.display = "block";
      $rightMenuCommentText.style.display = "block";
      $rightMenuSearch.style.display = "block";
      $rightMenuSearchBaidu.style.display = "block";
    } else {
      $rightMenuCopyText.style.display = "none";
      $rightMenuCommentText.style.display = "none";
      $rightMenuSearchBaidu.style.display = "none";
      $rightMenuSearch.style.display = "none";
    }

    //检查是否右键点击了链接a标签
    if (href) {
      pluginMode = true;
      $rightMenuNewWindow.style.display = "block";
      $rightMenuCopyLink.style.display = "block";
      domhref = href;
    } else {
      $rightMenuNewWindow.style.display = "none";
      $rightMenuCopyLink.style.display = "none";
    }

    //检查是否需要复制图片
    if (imgsrc) {
      pluginMode = true;
      $rightMenuCopyImg.style.display = "block";
      $rightMenuDownloadImg.style.display = "block";
      $rightMenuNewWindowImg.style.display = "block";
      document.getElementById("rightMenu").style.width="12rem"
      domImgSrc = imgsrc;
    } else {
      $rightMenuCopyImg.style.display = "none";
      $rightMenuDownloadImg.style.display = "none";
      $rightMenuNewWindowImg.style.display = "none";
    }

    // 判断是否为输入框
    if (event.target.tagName.toLowerCase() === "input" || event.target.tagName.toLowerCase() === "textarea") {
      pluginMode = true;
      $rightMenuPasteText.style.display = "block";
    } else {
      $rightMenuPasteText.style.display = "none";
    }
    const navMusicEl = document.querySelector("#nav-music");
    //判断是否是音乐
    if (navMusicEl && navMusicEl.contains(event.target)) {
      pluginMode = true;
      $rightMenuMusicToggle.style.display = "block";
      $rightMenuMusicBack.style.display = "block";
      $rightMenuMusicForward.style.display = "block";
      $rightMenuMusicPlaylist.style.display = "block";
      $rightMenuMusicCopyMusicName.style.display = "block";
    } else {
      $rightMenuMusicToggle.style.display = "none";
      $rightMenuMusicBack.style.display = "none";
      $rightMenuMusicForward.style.display = "none";
      $rightMenuMusicPlaylist.style.display = "none";
      $rightMenuMusicCopyMusicName.style.display = "none";
    }

    // 如果不是扩展模式则隐藏扩展模块
    if (pluginMode) {
      $rightMenuOther.style.display = "none";
      $rightMenuPlugin.style.display = "block";
    } else {
      $rightMenuPlugin.style.display = "none";
    }

    rm.reloadrmSize();

    // 鼠标默认显示在鼠标右下方，当鼠标靠右或靠下时，将菜单显示在鼠标左方\上方
    if (pageX + rmWidth > window.innerWidth) {
      pageX -= rmWidth + 10;
    }
    if (pageY + rmHeight > window.innerHeight) {
      pageY -= pageY + rmHeight - window.innerHeight;
    }

    rm.showRightMenu(true, pageY, pageX);
    document.getElementById("rightmenu-mask").style.display = "flex";
    return false;
  }
};

// 监听右键初始化
window.oncontextmenu = oncontextmenuFunction

// 下载图片状态
rm.downloadimging = false;

// 复制图片到剪贴板
rm.writeClipImg = function (imgsrc) {
  console.log("按下复制");
  rm.hideRightMenu();
  anzhiyu.snackbarShow("正在下载中，请稍后", false, 10000);
  if (rm.downloadimging == false) {
    rm.downloadimging = true;
    setTimeout(function () {
      copyImage(imgsrc);
      anzhiyu.snackbarShow("复制成功！图片已添加盲水印，请遵守版权协议");
      rm.downloadimging = false;
    }, "10000");
  }
};

function imageToBlob(imageURL) {
  const img = new Image();
  const c = document.createElement("canvas");
  const ctx = c.getContext("2d");
  img.crossOrigin = "";
  img.src = imageURL;
  return new Promise(resolve => {
    img.onload = function () {
      c.width = this.naturalWidth;
      c.height = this.naturalHeight;
      ctx.drawImage(this, 0, 0);
      c.toBlob(
        blob => {
          // here the image is a blob
          resolve(blob);
        },
        "image/png",
        0.75
      );
    };
  });
}

async function copyImage(imageURL) {
  const blob = await imageToBlob(imageURL);
  const item = new ClipboardItem({ "image/png": blob });
  navigator.clipboard.write([item]);
}

rm.copyUrl = function (id) {
  const input = document.createElement("input"); // Create a new <input> element
  input.id = "copyVal"; // Set the id of the new element to "copyVal"
  document.body.appendChild(input); // Append the new element to the end of the <body> element
  
  const text = id;
  input.value = text;
  input.select();
  input.setSelectionRange(0, input.value.length);
  document.execCommand("copy");
  
  input.remove(); // Remove the <input> element from the DOM
};

function stopMaskScroll() {
  if (document.getElementById("rightmenu-mask")) {
    let xscroll = document.getElementById("rightmenu-mask");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      { passive: true }
    );
  }
  if (document.getElementById("rightMenu")) {
    let xscroll = document.getElementById("rightMenu");
    xscroll.addEventListener(
      "mousewheel",
      function (e) {
        //阻止浏览器默认方法
        rm.hideRightMenu();
        // e.preventDefault();
      },
      { passive: true }
    );
  }
}

rm.rightmenuCopyText = function (txt) {
  if (navigator.clipboard) {
    navigator.clipboard.writeText(txt);
  }
  rm.hideRightMenu();
};

rm.copyPageUrl = function (url) {
  if (!url) {
    url = window.location.href;
  }
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制本页链接地址成功", false, 2000);
  rm.hideRightMenu();
};

rm.sharePage = function () {
  var content = window.location.href;
  rm.copyUrl(url);
  anzhiyu.snackbarShow("复制本页链接地址成功", false, 2000);
  rm.hideRightMenu();
};

// 复制当前选中文本
var selectTextNow = "";
document.onmouseup = document.ondblclick = selceText;

function selceText() {
  var txt;
  if (document.selection) {
    txt = document.selection.createRange().text;
  } else {
    txt = window.getSelection().toString();
  }
  selectTextNow = txt !== "" ? txt : "";
}

// 读取剪切板
rm.readClipboard = function () {
  if (navigator.clipboard) {
    navigator.clipboard.readText().then(clipText => rm.insertAtCaret(globalEvent.target, clipText));
  }
};

// 粘贴文本到焦点
rm.insertAtCaret = function (elemt, value) {
  const startPos = elemt.selectionStart,
    endPos = elemt.selectionEnd;
  if (document.selection) {
    elemt.focus();
    var sel = document.selection.createRange();
    sel.text = value;
    elemt.focus();
  } else {
    if (startPos || startPos == "0") {
      var scrollTop = elemt.scrollTop;
      elemt.value = elemt.value.substring(0, startPos) + value + elemt.value.substring(endPos, elemt.value.length);
      elemt.focus();
      elemt.selectionStart = startPos + value.length;
      elemt.selectionEnd = startPos + value.length;
      elemt.scrollTop = scrollTop;
    } else {
      elemt.value += value;
      elemt.focus();
    }
  }
};

//粘贴文本
rm.pasteText = function () {
  const result = rm.readClipboard() || "";
  rm.hideRightMenu();
};

//引用到评论
rm.rightMenuCommentText = function (txt) {
  rm.hideRightMenu();
  const postCommentDom = document.getElementById("post-comment");
  var domTop = postCommentDom.offsetTop;
  window.scrollTo(0, domTop - 80);
  if (txt == "undefined" || txt == "null") txt = "好棒！";
  function setText() {
    setTimeout(() => {
      var input = document.getElementsByClassName("el-textarea__inner")[0];
      if (!input) setText();
      let evt = document.createEvent("HTMLEvents");
      evt.initEvent("input", true, true);
      let inputValue = replaceAll(txt, "\n", "\n> ");
      input.value = "> " + inputValue + "\n\n";
      input.dispatchEvent(evt);
      input.focus();
      input.setSelectionRange(-1, -1);
      if (document.getElementById("comment-tips")) {
        document.getElementById("comment-tips").classList.add("show");
      }
    }, 100);
  }
  setText();
};

//替换所有内容
function replaceAll(string, search, replace) {
  return string.split(search).join(replace);
}

// 百度搜索
rm.searchBaidu = function () {
  anzhiyu.snackbarShow("即将跳转到百度搜索", false, 2000);
  setTimeout(function () {
    window.open("https://www.baidu.com/s?wd=" + selectTextNow);
  }, "2000");
  rm.hideRightMenu();
};

//分享链接
rm.copyLink = function () {
  rm.rightmenuCopyText(domhref);
  anzhiyu.snackbarShow("已复制链接地址");
};

function addRightMenuClickEvent() {
  // 添加点击事件
  document.getElementById("menu-backward").addEventListener("click", function () {
  window.history.back();
    rm.hideRightMenu();
  });

  document.getElementById("menu-forward").addEventListener("click", function () {
    window.history.forward();
    rm.hideRightMenu();
  });

  document.getElementById("menu-refresh").addEventListener("click", function () {
    window.location.reload();
  });

  document.getElementById("menu-top").addEventListener("click", function () {
    anzhiyu.scrollToDest(0, 500);
    rm.hideRightMenu();
  });

  const menuLinks = document.querySelectorAll(".menu-link");
  menuLinks.forEach(function (link) {
    link.addEventListener("click", rm.hideRightMenu);
  });

  document.getElementById("menu-darkmode").addEventListener("click", anzhiyu.switchDarkMode);

  document.getElementById("menu-home") && document.getElementById("menu-home").addEventListener("click", function () {
    window.location.href = window.location.origin;
  });

  document.getElementById("menu-randomPost").addEventListener("click", function () {
    toRandomPost();
  });

  document.getElementById("menu-commentBarrage").addEventListener("click", anzhiyu.switchCommentBarrage);

  document.getElementById("rightmenu-mask").addEventListener("click", rm.hideRightMenu);

  document.getElementById("rightmenu-mask").addEventListener("contextmenu", function (event) {
    rm.hideRightMenu();
    event.preventDefault(); // Prevent the default context menu from appearing
  });

  document.getElementById("menu-copy").addEventListener("click", rm.copyPageUrl);

  document.getElementById("menu-pastetext").addEventListener("click", rm.pasteText);

  document.getElementById("menu-copytext").addEventListener("click", function () {
    rm.rightmenuCopyText(selectTextNow);
    anzhiyu.snackbarShow("复制成功，复制和转载请标注本文地址");
  });

  document.getElementById("menu-commenttext").addEventListener("click", function () {
    rm.rightMenuCommentText(selectTextNow);
  });

  document.getElementById("menu-newwindow").addEventListener("click", function () {
    window.open(domhref, "_blank");
    rm.hideRightMenu();
  });

  document.getElementById("menu-copylink").addEventListener("click", rm.copyLink);

  document.getElementById("menu-downloadimg").addEventListener("click", function () {
    anzhiyu.downloadImage(domImgSrc, "anzhiyu");
  });

  document.getElementById("menu-newwindowimg").addEventListener("click", function () {
    window.open(domImgSrc, "_blank");
    rm.hideRightMenu();
  });

  document.getElementById("menu-copyimg").addEventListener("click", function () {
    rm.writeClipImg(domImgSrc);
  });

  document.getElementById("menu-searchBaidu").addEventListener("click", rm.searchBaidu);

  //音乐
  document.getElementById("menu-music-toggle").addEventListener("click", anzhiyu.musicToggle);

  document.getElementById("menu-music-back").addEventListener("click", anzhiyu.musicSkipBack);

  document.getElementById("menu-music-forward").addEventListener("click", anzhiyu.musicSkipForward);

  document.getElementById("menu-music-copyMusicName").addEventListener("click", function () {
    rm.rightmenuCopyText(anzhiyu.musicGetName());
    anzhiyu.snackbarShow("复制歌曲名称成功", false, 3000);
  });

}

addRightMenuClickEvent();</script><script data-pjax>var themeColorMeta = document.querySelector('meta[name="theme-color"]');
var pageHeaderEl = document.getElementById("page-header");
var navMusicEl = document.getElementById("nav-music");
var consoleEl = document.getElementById("console");
// 已随机的歌曲
var selectRandomSong = [];
// 音乐默认声音大小
var musicVolume = 0.8;
// 是否切换了周杰伦音乐列表
var changeMusicListFlag = false;
// 当前默认播放列表
var defaultPlayMusicList = [];

document.getElementById("page-name").innerText = document.title.split(" | ♪张小佑")[0];
anzhiyu.initIndexEssay();
anzhiyu.changeTimeInEssay();
anzhiyu.removeBodyPaceClass();
anzhiyu.qrcodeCreate();
anzhiyu.changeTimeInAlbumDetail();
anzhiyu.reflashEssayWaterFall();
anzhiyu.sayhi();
anzhiyu.stopImgRightDrag();
anzhiyu.addNavBackgroundInit();
anzhiyu.setValueToBodyType();
anzhiyu.catalogActive();
anzhiyu.tagsPageActive();
anzhiyu.categoriesBarActive();
anzhiyu.topCategoriesBarScroll();
anzhiyu.switchRightClickMenuHotReview();
anzhiyu.getCustomPlayList();
anzhiyu.addEventListenerConsoleMusicList(false);
setTimeout(() => {
  if (typeof addFriendLinksInFooter === "function") {
    addFriendLinksInFooter();
  }
}, 200)</script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.1.4/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://npm.elemecdn.com/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://npm.elemecdn.com/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://npm.elemecdn.com/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>